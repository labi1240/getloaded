
/**
 * Client
**/

import * as runtime from './runtime/client.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Brand
 * 
 */
export type Brand = $Result.DefaultSelection<Prisma.$BrandPayload>
/**
 * Model Caliber
 * 
 */
export type Caliber = $Result.DefaultSelection<Prisma.$CaliberPayload>
/**
 * Model Offer
 * 
 */
export type Offer = $Result.DefaultSelection<Prisma.$OfferPayload>
/**
 * Model Retailer
 * 
 */
export type Retailer = $Result.DefaultSelection<Prisma.$RetailerPayload>
/**
 * Model AccessoryFitment
 * 
 */
export type AccessoryFitment = $Result.DefaultSelection<Prisma.$AccessoryFitmentPayload>
/**
 * Model AccessorySpecs
 * 
 */
export type AccessorySpecs = $Result.DefaultSelection<Prisma.$AccessorySpecsPayload>
/**
 * Model AccessoryType
 * 
 */
export type AccessoryType = $Result.DefaultSelection<Prisma.$AccessoryTypePayload>
/**
 * Model Alert
 * 
 */
export type Alert = $Result.DefaultSelection<Prisma.$AlertPayload>
/**
 * Model AlertDelivery
 * 
 */
export type AlertDelivery = $Result.DefaultSelection<Prisma.$AlertDeliveryPayload>
/**
 * Model AmmoSpecs
 * 
 */
export type AmmoSpecs = $Result.DefaultSelection<Prisma.$AmmoSpecsPayload>
/**
 * Model BlockedRetailer
 * 
 */
export type BlockedRetailer = $Result.DefaultSelection<Prisma.$BlockedRetailerPayload>
/**
 * Model CaliberAlias
 * 
 */
export type CaliberAlias = $Result.DefaultSelection<Prisma.$CaliberAliasPayload>
/**
 * Model CatalogItem
 * 
 */
export type CatalogItem = $Result.DefaultSelection<Prisma.$CatalogItemPayload>
/**
 * Model FirearmCategory
 * 
 */
export type FirearmCategory = $Result.DefaultSelection<Prisma.$FirearmCategoryPayload>
/**
 * Model FirearmChamber
 * 
 */
export type FirearmChamber = $Result.DefaultSelection<Prisma.$FirearmChamberPayload>
/**
 * Model FirearmSpecs
 * 
 */
export type FirearmSpecs = $Result.DefaultSelection<Prisma.$FirearmSpecsPayload>
/**
 * Model OwnedFirearm
 * 
 */
export type OwnedFirearm = $Result.DefaultSelection<Prisma.$OwnedFirearmPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model raw_offer_ingest
 * This table has subclasses and requires additional setup for migrations. Visit https://pris.ly/d/table-inheritance for more info.
 * The underlying table does not contain a valid unique identifier and can therefore currently not be handled by Prisma Client.
 */
export type raw_offer_ingest = $Result.DefaultSelection<Prisma.$raw_offer_ingestPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const AlertType: {
  CALIBER: 'CALIBER',
  ITEM: 'ITEM',
  KEYWORD: 'KEYWORD'
};

export type AlertType = (typeof AlertType)[keyof typeof AlertType]


export const AmmoPressure: {
  UNKNOWN: 'UNKNOWN',
  STANDARD: 'STANDARD',
  PLUS_P: 'PLUS_P',
  PLUS_P_PLUS: 'PLUS_P_PLUS'
};

export type AmmoPressure = (typeof AmmoPressure)[keyof typeof AmmoPressure]


export const CaliberType: {
  PISTOL: 'PISTOL',
  RIFLE: 'RIFLE',
  SHOTGUN: 'SHOTGUN',
  RIMFIRE: 'RIMFIRE',
  UNKNOWN: 'UNKNOWN'
};

export type CaliberType = (typeof CaliberType)[keyof typeof CaliberType]


export const CatalogKind: {
  AMMO: 'AMMO',
  FIREARM: 'FIREARM',
  ACCESSORY: 'ACCESSORY'
};

export type CatalogKind = (typeof CatalogKind)[keyof typeof CatalogKind]


export const FirearmPressureRating: {
  UNKNOWN: 'UNKNOWN',
  STANDARD_ONLY: 'STANDARD_ONLY',
  PLUS_P_OK: 'PLUS_P_OK',
  PLUS_P_PLUS_OK: 'PLUS_P_PLUS_OK'
};

export type FirearmPressureRating = (typeof FirearmPressureRating)[keyof typeof FirearmPressureRating]


export const FitmentType: {
  EXACT_MODEL: 'EXACT_MODEL',
  PLATFORM: 'PLATFORM',
  UNIVERSAL: 'UNIVERSAL'
};

export type FitmentType = (typeof FitmentType)[keyof typeof FitmentType]

}

export type AlertType = $Enums.AlertType

export const AlertType: typeof $Enums.AlertType

export type AmmoPressure = $Enums.AmmoPressure

export const AmmoPressure: typeof $Enums.AmmoPressure

export type CaliberType = $Enums.CaliberType

export const CaliberType: typeof $Enums.CaliberType

export type CatalogKind = $Enums.CatalogKind

export const CatalogKind: typeof $Enums.CatalogKind

export type FirearmPressureRating = $Enums.FirearmPressureRating

export const FirearmPressureRating: typeof $Enums.FirearmPressureRating

export type FitmentType = $Enums.FitmentType

export const FitmentType: typeof $Enums.FitmentType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Brands
 * const brands = await prisma.brand.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://pris.ly/d/client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Brands
   * const brands = await prisma.brand.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://pris.ly/d/client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.brand`: Exposes CRUD operations for the **Brand** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Brands
    * const brands = await prisma.brand.findMany()
    * ```
    */
  get brand(): Prisma.BrandDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.caliber`: Exposes CRUD operations for the **Caliber** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Calibers
    * const calibers = await prisma.caliber.findMany()
    * ```
    */
  get caliber(): Prisma.CaliberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.offer`: Exposes CRUD operations for the **Offer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Offers
    * const offers = await prisma.offer.findMany()
    * ```
    */
  get offer(): Prisma.OfferDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.retailer`: Exposes CRUD operations for the **Retailer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Retailers
    * const retailers = await prisma.retailer.findMany()
    * ```
    */
  get retailer(): Prisma.RetailerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.accessoryFitment`: Exposes CRUD operations for the **AccessoryFitment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AccessoryFitments
    * const accessoryFitments = await prisma.accessoryFitment.findMany()
    * ```
    */
  get accessoryFitment(): Prisma.AccessoryFitmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.accessorySpecs`: Exposes CRUD operations for the **AccessorySpecs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AccessorySpecs
    * const accessorySpecs = await prisma.accessorySpecs.findMany()
    * ```
    */
  get accessorySpecs(): Prisma.AccessorySpecsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.accessoryType`: Exposes CRUD operations for the **AccessoryType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AccessoryTypes
    * const accessoryTypes = await prisma.accessoryType.findMany()
    * ```
    */
  get accessoryType(): Prisma.AccessoryTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.alert`: Exposes CRUD operations for the **Alert** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Alerts
    * const alerts = await prisma.alert.findMany()
    * ```
    */
  get alert(): Prisma.AlertDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.alertDelivery`: Exposes CRUD operations for the **AlertDelivery** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AlertDeliveries
    * const alertDeliveries = await prisma.alertDelivery.findMany()
    * ```
    */
  get alertDelivery(): Prisma.AlertDeliveryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ammoSpecs`: Exposes CRUD operations for the **AmmoSpecs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AmmoSpecs
    * const ammoSpecs = await prisma.ammoSpecs.findMany()
    * ```
    */
  get ammoSpecs(): Prisma.AmmoSpecsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.blockedRetailer`: Exposes CRUD operations for the **BlockedRetailer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BlockedRetailers
    * const blockedRetailers = await prisma.blockedRetailer.findMany()
    * ```
    */
  get blockedRetailer(): Prisma.BlockedRetailerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.caliberAlias`: Exposes CRUD operations for the **CaliberAlias** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CaliberAliases
    * const caliberAliases = await prisma.caliberAlias.findMany()
    * ```
    */
  get caliberAlias(): Prisma.CaliberAliasDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.catalogItem`: Exposes CRUD operations for the **CatalogItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CatalogItems
    * const catalogItems = await prisma.catalogItem.findMany()
    * ```
    */
  get catalogItem(): Prisma.CatalogItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.firearmCategory`: Exposes CRUD operations for the **FirearmCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FirearmCategories
    * const firearmCategories = await prisma.firearmCategory.findMany()
    * ```
    */
  get firearmCategory(): Prisma.FirearmCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.firearmChamber`: Exposes CRUD operations for the **FirearmChamber** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FirearmChambers
    * const firearmChambers = await prisma.firearmChamber.findMany()
    * ```
    */
  get firearmChamber(): Prisma.FirearmChamberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.firearmSpecs`: Exposes CRUD operations for the **FirearmSpecs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FirearmSpecs
    * const firearmSpecs = await prisma.firearmSpecs.findMany()
    * ```
    */
  get firearmSpecs(): Prisma.FirearmSpecsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ownedFirearm`: Exposes CRUD operations for the **OwnedFirearm** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OwnedFirearms
    * const ownedFirearms = await prisma.ownedFirearm.findMany()
    * ```
    */
  get ownedFirearm(): Prisma.OwnedFirearmDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.raw_offer_ingest`: Exposes CRUD operations for the **raw_offer_ingest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Raw_offer_ingests
    * const raw_offer_ingests = await prisma.raw_offer_ingest.findMany()
    * ```
    */
  get raw_offer_ingest(): Prisma.raw_offer_ingestDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 7.2.0
   * Query Engine version: 0c8ef2ce45c83248ab3df073180d5eda9e8be7a3
   */
  export type PrismaVersion = {
    client: string
    engine: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Brand: 'Brand',
    Caliber: 'Caliber',
    Offer: 'Offer',
    Retailer: 'Retailer',
    AccessoryFitment: 'AccessoryFitment',
    AccessorySpecs: 'AccessorySpecs',
    AccessoryType: 'AccessoryType',
    Alert: 'Alert',
    AlertDelivery: 'AlertDelivery',
    AmmoSpecs: 'AmmoSpecs',
    BlockedRetailer: 'BlockedRetailer',
    CaliberAlias: 'CaliberAlias',
    CatalogItem: 'CatalogItem',
    FirearmCategory: 'FirearmCategory',
    FirearmChamber: 'FirearmChamber',
    FirearmSpecs: 'FirearmSpecs',
    OwnedFirearm: 'OwnedFirearm',
    User: 'User',
    raw_offer_ingest: 'raw_offer_ingest'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]



  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "brand" | "caliber" | "offer" | "retailer" | "accessoryFitment" | "accessorySpecs" | "accessoryType" | "alert" | "alertDelivery" | "ammoSpecs" | "blockedRetailer" | "caliberAlias" | "catalogItem" | "firearmCategory" | "firearmChamber" | "firearmSpecs" | "ownedFirearm" | "user" | "raw_offer_ingest"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Brand: {
        payload: Prisma.$BrandPayload<ExtArgs>
        fields: Prisma.BrandFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BrandFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BrandFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>
          }
          findFirst: {
            args: Prisma.BrandFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BrandFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>
          }
          findMany: {
            args: Prisma.BrandFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>[]
          }
          create: {
            args: Prisma.BrandCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>
          }
          createMany: {
            args: Prisma.BrandCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BrandCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>[]
          }
          delete: {
            args: Prisma.BrandDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>
          }
          update: {
            args: Prisma.BrandUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>
          }
          deleteMany: {
            args: Prisma.BrandDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BrandUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BrandUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>[]
          }
          upsert: {
            args: Prisma.BrandUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>
          }
          aggregate: {
            args: Prisma.BrandAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBrand>
          }
          groupBy: {
            args: Prisma.BrandGroupByArgs<ExtArgs>
            result: $Utils.Optional<BrandGroupByOutputType>[]
          }
          count: {
            args: Prisma.BrandCountArgs<ExtArgs>
            result: $Utils.Optional<BrandCountAggregateOutputType> | number
          }
        }
      }
      Caliber: {
        payload: Prisma.$CaliberPayload<ExtArgs>
        fields: Prisma.CaliberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CaliberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaliberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CaliberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaliberPayload>
          }
          findFirst: {
            args: Prisma.CaliberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaliberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CaliberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaliberPayload>
          }
          findMany: {
            args: Prisma.CaliberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaliberPayload>[]
          }
          create: {
            args: Prisma.CaliberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaliberPayload>
          }
          createMany: {
            args: Prisma.CaliberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CaliberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaliberPayload>[]
          }
          delete: {
            args: Prisma.CaliberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaliberPayload>
          }
          update: {
            args: Prisma.CaliberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaliberPayload>
          }
          deleteMany: {
            args: Prisma.CaliberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CaliberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CaliberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaliberPayload>[]
          }
          upsert: {
            args: Prisma.CaliberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaliberPayload>
          }
          aggregate: {
            args: Prisma.CaliberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCaliber>
          }
          groupBy: {
            args: Prisma.CaliberGroupByArgs<ExtArgs>
            result: $Utils.Optional<CaliberGroupByOutputType>[]
          }
          count: {
            args: Prisma.CaliberCountArgs<ExtArgs>
            result: $Utils.Optional<CaliberCountAggregateOutputType> | number
          }
        }
      }
      Offer: {
        payload: Prisma.$OfferPayload<ExtArgs>
        fields: Prisma.OfferFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OfferFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OfferFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPayload>
          }
          findFirst: {
            args: Prisma.OfferFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OfferFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPayload>
          }
          findMany: {
            args: Prisma.OfferFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPayload>[]
          }
          create: {
            args: Prisma.OfferCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPayload>
          }
          createMany: {
            args: Prisma.OfferCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OfferCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPayload>[]
          }
          delete: {
            args: Prisma.OfferDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPayload>
          }
          update: {
            args: Prisma.OfferUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPayload>
          }
          deleteMany: {
            args: Prisma.OfferDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OfferUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OfferUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPayload>[]
          }
          upsert: {
            args: Prisma.OfferUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPayload>
          }
          aggregate: {
            args: Prisma.OfferAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOffer>
          }
          groupBy: {
            args: Prisma.OfferGroupByArgs<ExtArgs>
            result: $Utils.Optional<OfferGroupByOutputType>[]
          }
          count: {
            args: Prisma.OfferCountArgs<ExtArgs>
            result: $Utils.Optional<OfferCountAggregateOutputType> | number
          }
        }
      }
      Retailer: {
        payload: Prisma.$RetailerPayload<ExtArgs>
        fields: Prisma.RetailerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RetailerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RetailerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RetailerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RetailerPayload>
          }
          findFirst: {
            args: Prisma.RetailerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RetailerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RetailerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RetailerPayload>
          }
          findMany: {
            args: Prisma.RetailerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RetailerPayload>[]
          }
          create: {
            args: Prisma.RetailerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RetailerPayload>
          }
          createMany: {
            args: Prisma.RetailerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RetailerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RetailerPayload>[]
          }
          delete: {
            args: Prisma.RetailerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RetailerPayload>
          }
          update: {
            args: Prisma.RetailerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RetailerPayload>
          }
          deleteMany: {
            args: Prisma.RetailerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RetailerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RetailerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RetailerPayload>[]
          }
          upsert: {
            args: Prisma.RetailerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RetailerPayload>
          }
          aggregate: {
            args: Prisma.RetailerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRetailer>
          }
          groupBy: {
            args: Prisma.RetailerGroupByArgs<ExtArgs>
            result: $Utils.Optional<RetailerGroupByOutputType>[]
          }
          count: {
            args: Prisma.RetailerCountArgs<ExtArgs>
            result: $Utils.Optional<RetailerCountAggregateOutputType> | number
          }
        }
      }
      AccessoryFitment: {
        payload: Prisma.$AccessoryFitmentPayload<ExtArgs>
        fields: Prisma.AccessoryFitmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccessoryFitmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessoryFitmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccessoryFitmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessoryFitmentPayload>
          }
          findFirst: {
            args: Prisma.AccessoryFitmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessoryFitmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccessoryFitmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessoryFitmentPayload>
          }
          findMany: {
            args: Prisma.AccessoryFitmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessoryFitmentPayload>[]
          }
          create: {
            args: Prisma.AccessoryFitmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessoryFitmentPayload>
          }
          createMany: {
            args: Prisma.AccessoryFitmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccessoryFitmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessoryFitmentPayload>[]
          }
          delete: {
            args: Prisma.AccessoryFitmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessoryFitmentPayload>
          }
          update: {
            args: Prisma.AccessoryFitmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessoryFitmentPayload>
          }
          deleteMany: {
            args: Prisma.AccessoryFitmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccessoryFitmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccessoryFitmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessoryFitmentPayload>[]
          }
          upsert: {
            args: Prisma.AccessoryFitmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessoryFitmentPayload>
          }
          aggregate: {
            args: Prisma.AccessoryFitmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccessoryFitment>
          }
          groupBy: {
            args: Prisma.AccessoryFitmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccessoryFitmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccessoryFitmentCountArgs<ExtArgs>
            result: $Utils.Optional<AccessoryFitmentCountAggregateOutputType> | number
          }
        }
      }
      AccessorySpecs: {
        payload: Prisma.$AccessorySpecsPayload<ExtArgs>
        fields: Prisma.AccessorySpecsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccessorySpecsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessorySpecsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccessorySpecsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessorySpecsPayload>
          }
          findFirst: {
            args: Prisma.AccessorySpecsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessorySpecsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccessorySpecsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessorySpecsPayload>
          }
          findMany: {
            args: Prisma.AccessorySpecsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessorySpecsPayload>[]
          }
          create: {
            args: Prisma.AccessorySpecsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessorySpecsPayload>
          }
          createMany: {
            args: Prisma.AccessorySpecsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccessorySpecsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessorySpecsPayload>[]
          }
          delete: {
            args: Prisma.AccessorySpecsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessorySpecsPayload>
          }
          update: {
            args: Prisma.AccessorySpecsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessorySpecsPayload>
          }
          deleteMany: {
            args: Prisma.AccessorySpecsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccessorySpecsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccessorySpecsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessorySpecsPayload>[]
          }
          upsert: {
            args: Prisma.AccessorySpecsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessorySpecsPayload>
          }
          aggregate: {
            args: Prisma.AccessorySpecsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccessorySpecs>
          }
          groupBy: {
            args: Prisma.AccessorySpecsGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccessorySpecsGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccessorySpecsCountArgs<ExtArgs>
            result: $Utils.Optional<AccessorySpecsCountAggregateOutputType> | number
          }
        }
      }
      AccessoryType: {
        payload: Prisma.$AccessoryTypePayload<ExtArgs>
        fields: Prisma.AccessoryTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccessoryTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessoryTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccessoryTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessoryTypePayload>
          }
          findFirst: {
            args: Prisma.AccessoryTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessoryTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccessoryTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessoryTypePayload>
          }
          findMany: {
            args: Prisma.AccessoryTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessoryTypePayload>[]
          }
          create: {
            args: Prisma.AccessoryTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessoryTypePayload>
          }
          createMany: {
            args: Prisma.AccessoryTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccessoryTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessoryTypePayload>[]
          }
          delete: {
            args: Prisma.AccessoryTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessoryTypePayload>
          }
          update: {
            args: Prisma.AccessoryTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessoryTypePayload>
          }
          deleteMany: {
            args: Prisma.AccessoryTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccessoryTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccessoryTypeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessoryTypePayload>[]
          }
          upsert: {
            args: Prisma.AccessoryTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessoryTypePayload>
          }
          aggregate: {
            args: Prisma.AccessoryTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccessoryType>
          }
          groupBy: {
            args: Prisma.AccessoryTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccessoryTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccessoryTypeCountArgs<ExtArgs>
            result: $Utils.Optional<AccessoryTypeCountAggregateOutputType> | number
          }
        }
      }
      Alert: {
        payload: Prisma.$AlertPayload<ExtArgs>
        fields: Prisma.AlertFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AlertFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AlertFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          findFirst: {
            args: Prisma.AlertFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AlertFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          findMany: {
            args: Prisma.AlertFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>[]
          }
          create: {
            args: Prisma.AlertCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          createMany: {
            args: Prisma.AlertCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AlertCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>[]
          }
          delete: {
            args: Prisma.AlertDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          update: {
            args: Prisma.AlertUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          deleteMany: {
            args: Prisma.AlertDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AlertUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AlertUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>[]
          }
          upsert: {
            args: Prisma.AlertUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          aggregate: {
            args: Prisma.AlertAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAlert>
          }
          groupBy: {
            args: Prisma.AlertGroupByArgs<ExtArgs>
            result: $Utils.Optional<AlertGroupByOutputType>[]
          }
          count: {
            args: Prisma.AlertCountArgs<ExtArgs>
            result: $Utils.Optional<AlertCountAggregateOutputType> | number
          }
        }
      }
      AlertDelivery: {
        payload: Prisma.$AlertDeliveryPayload<ExtArgs>
        fields: Prisma.AlertDeliveryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AlertDeliveryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertDeliveryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AlertDeliveryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertDeliveryPayload>
          }
          findFirst: {
            args: Prisma.AlertDeliveryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertDeliveryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AlertDeliveryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertDeliveryPayload>
          }
          findMany: {
            args: Prisma.AlertDeliveryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertDeliveryPayload>[]
          }
          create: {
            args: Prisma.AlertDeliveryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertDeliveryPayload>
          }
          createMany: {
            args: Prisma.AlertDeliveryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AlertDeliveryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertDeliveryPayload>[]
          }
          delete: {
            args: Prisma.AlertDeliveryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertDeliveryPayload>
          }
          update: {
            args: Prisma.AlertDeliveryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertDeliveryPayload>
          }
          deleteMany: {
            args: Prisma.AlertDeliveryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AlertDeliveryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AlertDeliveryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertDeliveryPayload>[]
          }
          upsert: {
            args: Prisma.AlertDeliveryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertDeliveryPayload>
          }
          aggregate: {
            args: Prisma.AlertDeliveryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAlertDelivery>
          }
          groupBy: {
            args: Prisma.AlertDeliveryGroupByArgs<ExtArgs>
            result: $Utils.Optional<AlertDeliveryGroupByOutputType>[]
          }
          count: {
            args: Prisma.AlertDeliveryCountArgs<ExtArgs>
            result: $Utils.Optional<AlertDeliveryCountAggregateOutputType> | number
          }
        }
      }
      AmmoSpecs: {
        payload: Prisma.$AmmoSpecsPayload<ExtArgs>
        fields: Prisma.AmmoSpecsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AmmoSpecsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmmoSpecsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AmmoSpecsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmmoSpecsPayload>
          }
          findFirst: {
            args: Prisma.AmmoSpecsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmmoSpecsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AmmoSpecsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmmoSpecsPayload>
          }
          findMany: {
            args: Prisma.AmmoSpecsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmmoSpecsPayload>[]
          }
          create: {
            args: Prisma.AmmoSpecsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmmoSpecsPayload>
          }
          createMany: {
            args: Prisma.AmmoSpecsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AmmoSpecsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmmoSpecsPayload>[]
          }
          delete: {
            args: Prisma.AmmoSpecsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmmoSpecsPayload>
          }
          update: {
            args: Prisma.AmmoSpecsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmmoSpecsPayload>
          }
          deleteMany: {
            args: Prisma.AmmoSpecsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AmmoSpecsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AmmoSpecsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmmoSpecsPayload>[]
          }
          upsert: {
            args: Prisma.AmmoSpecsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmmoSpecsPayload>
          }
          aggregate: {
            args: Prisma.AmmoSpecsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAmmoSpecs>
          }
          groupBy: {
            args: Prisma.AmmoSpecsGroupByArgs<ExtArgs>
            result: $Utils.Optional<AmmoSpecsGroupByOutputType>[]
          }
          count: {
            args: Prisma.AmmoSpecsCountArgs<ExtArgs>
            result: $Utils.Optional<AmmoSpecsCountAggregateOutputType> | number
          }
        }
      }
      BlockedRetailer: {
        payload: Prisma.$BlockedRetailerPayload<ExtArgs>
        fields: Prisma.BlockedRetailerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BlockedRetailerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockedRetailerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BlockedRetailerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockedRetailerPayload>
          }
          findFirst: {
            args: Prisma.BlockedRetailerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockedRetailerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BlockedRetailerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockedRetailerPayload>
          }
          findMany: {
            args: Prisma.BlockedRetailerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockedRetailerPayload>[]
          }
          create: {
            args: Prisma.BlockedRetailerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockedRetailerPayload>
          }
          createMany: {
            args: Prisma.BlockedRetailerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BlockedRetailerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockedRetailerPayload>[]
          }
          delete: {
            args: Prisma.BlockedRetailerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockedRetailerPayload>
          }
          update: {
            args: Prisma.BlockedRetailerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockedRetailerPayload>
          }
          deleteMany: {
            args: Prisma.BlockedRetailerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BlockedRetailerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BlockedRetailerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockedRetailerPayload>[]
          }
          upsert: {
            args: Prisma.BlockedRetailerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockedRetailerPayload>
          }
          aggregate: {
            args: Prisma.BlockedRetailerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlockedRetailer>
          }
          groupBy: {
            args: Prisma.BlockedRetailerGroupByArgs<ExtArgs>
            result: $Utils.Optional<BlockedRetailerGroupByOutputType>[]
          }
          count: {
            args: Prisma.BlockedRetailerCountArgs<ExtArgs>
            result: $Utils.Optional<BlockedRetailerCountAggregateOutputType> | number
          }
        }
      }
      CaliberAlias: {
        payload: Prisma.$CaliberAliasPayload<ExtArgs>
        fields: Prisma.CaliberAliasFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CaliberAliasFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaliberAliasPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CaliberAliasFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaliberAliasPayload>
          }
          findFirst: {
            args: Prisma.CaliberAliasFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaliberAliasPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CaliberAliasFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaliberAliasPayload>
          }
          findMany: {
            args: Prisma.CaliberAliasFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaliberAliasPayload>[]
          }
          create: {
            args: Prisma.CaliberAliasCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaliberAliasPayload>
          }
          createMany: {
            args: Prisma.CaliberAliasCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CaliberAliasCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaliberAliasPayload>[]
          }
          delete: {
            args: Prisma.CaliberAliasDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaliberAliasPayload>
          }
          update: {
            args: Prisma.CaliberAliasUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaliberAliasPayload>
          }
          deleteMany: {
            args: Prisma.CaliberAliasDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CaliberAliasUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CaliberAliasUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaliberAliasPayload>[]
          }
          upsert: {
            args: Prisma.CaliberAliasUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaliberAliasPayload>
          }
          aggregate: {
            args: Prisma.CaliberAliasAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCaliberAlias>
          }
          groupBy: {
            args: Prisma.CaliberAliasGroupByArgs<ExtArgs>
            result: $Utils.Optional<CaliberAliasGroupByOutputType>[]
          }
          count: {
            args: Prisma.CaliberAliasCountArgs<ExtArgs>
            result: $Utils.Optional<CaliberAliasCountAggregateOutputType> | number
          }
        }
      }
      CatalogItem: {
        payload: Prisma.$CatalogItemPayload<ExtArgs>
        fields: Prisma.CatalogItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CatalogItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CatalogItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogItemPayload>
          }
          findFirst: {
            args: Prisma.CatalogItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CatalogItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogItemPayload>
          }
          findMany: {
            args: Prisma.CatalogItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogItemPayload>[]
          }
          create: {
            args: Prisma.CatalogItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogItemPayload>
          }
          createMany: {
            args: Prisma.CatalogItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CatalogItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogItemPayload>[]
          }
          delete: {
            args: Prisma.CatalogItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogItemPayload>
          }
          update: {
            args: Prisma.CatalogItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogItemPayload>
          }
          deleteMany: {
            args: Prisma.CatalogItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CatalogItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CatalogItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogItemPayload>[]
          }
          upsert: {
            args: Prisma.CatalogItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogItemPayload>
          }
          aggregate: {
            args: Prisma.CatalogItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCatalogItem>
          }
          groupBy: {
            args: Prisma.CatalogItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<CatalogItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.CatalogItemCountArgs<ExtArgs>
            result: $Utils.Optional<CatalogItemCountAggregateOutputType> | number
          }
        }
      }
      FirearmCategory: {
        payload: Prisma.$FirearmCategoryPayload<ExtArgs>
        fields: Prisma.FirearmCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FirearmCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FirearmCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FirearmCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FirearmCategoryPayload>
          }
          findFirst: {
            args: Prisma.FirearmCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FirearmCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FirearmCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FirearmCategoryPayload>
          }
          findMany: {
            args: Prisma.FirearmCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FirearmCategoryPayload>[]
          }
          create: {
            args: Prisma.FirearmCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FirearmCategoryPayload>
          }
          createMany: {
            args: Prisma.FirearmCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FirearmCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FirearmCategoryPayload>[]
          }
          delete: {
            args: Prisma.FirearmCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FirearmCategoryPayload>
          }
          update: {
            args: Prisma.FirearmCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FirearmCategoryPayload>
          }
          deleteMany: {
            args: Prisma.FirearmCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FirearmCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FirearmCategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FirearmCategoryPayload>[]
          }
          upsert: {
            args: Prisma.FirearmCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FirearmCategoryPayload>
          }
          aggregate: {
            args: Prisma.FirearmCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFirearmCategory>
          }
          groupBy: {
            args: Prisma.FirearmCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<FirearmCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.FirearmCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<FirearmCategoryCountAggregateOutputType> | number
          }
        }
      }
      FirearmChamber: {
        payload: Prisma.$FirearmChamberPayload<ExtArgs>
        fields: Prisma.FirearmChamberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FirearmChamberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FirearmChamberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FirearmChamberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FirearmChamberPayload>
          }
          findFirst: {
            args: Prisma.FirearmChamberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FirearmChamberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FirearmChamberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FirearmChamberPayload>
          }
          findMany: {
            args: Prisma.FirearmChamberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FirearmChamberPayload>[]
          }
          create: {
            args: Prisma.FirearmChamberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FirearmChamberPayload>
          }
          createMany: {
            args: Prisma.FirearmChamberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FirearmChamberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FirearmChamberPayload>[]
          }
          delete: {
            args: Prisma.FirearmChamberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FirearmChamberPayload>
          }
          update: {
            args: Prisma.FirearmChamberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FirearmChamberPayload>
          }
          deleteMany: {
            args: Prisma.FirearmChamberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FirearmChamberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FirearmChamberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FirearmChamberPayload>[]
          }
          upsert: {
            args: Prisma.FirearmChamberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FirearmChamberPayload>
          }
          aggregate: {
            args: Prisma.FirearmChamberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFirearmChamber>
          }
          groupBy: {
            args: Prisma.FirearmChamberGroupByArgs<ExtArgs>
            result: $Utils.Optional<FirearmChamberGroupByOutputType>[]
          }
          count: {
            args: Prisma.FirearmChamberCountArgs<ExtArgs>
            result: $Utils.Optional<FirearmChamberCountAggregateOutputType> | number
          }
        }
      }
      FirearmSpecs: {
        payload: Prisma.$FirearmSpecsPayload<ExtArgs>
        fields: Prisma.FirearmSpecsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FirearmSpecsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FirearmSpecsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FirearmSpecsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FirearmSpecsPayload>
          }
          findFirst: {
            args: Prisma.FirearmSpecsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FirearmSpecsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FirearmSpecsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FirearmSpecsPayload>
          }
          findMany: {
            args: Prisma.FirearmSpecsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FirearmSpecsPayload>[]
          }
          create: {
            args: Prisma.FirearmSpecsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FirearmSpecsPayload>
          }
          createMany: {
            args: Prisma.FirearmSpecsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FirearmSpecsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FirearmSpecsPayload>[]
          }
          delete: {
            args: Prisma.FirearmSpecsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FirearmSpecsPayload>
          }
          update: {
            args: Prisma.FirearmSpecsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FirearmSpecsPayload>
          }
          deleteMany: {
            args: Prisma.FirearmSpecsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FirearmSpecsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FirearmSpecsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FirearmSpecsPayload>[]
          }
          upsert: {
            args: Prisma.FirearmSpecsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FirearmSpecsPayload>
          }
          aggregate: {
            args: Prisma.FirearmSpecsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFirearmSpecs>
          }
          groupBy: {
            args: Prisma.FirearmSpecsGroupByArgs<ExtArgs>
            result: $Utils.Optional<FirearmSpecsGroupByOutputType>[]
          }
          count: {
            args: Prisma.FirearmSpecsCountArgs<ExtArgs>
            result: $Utils.Optional<FirearmSpecsCountAggregateOutputType> | number
          }
        }
      }
      OwnedFirearm: {
        payload: Prisma.$OwnedFirearmPayload<ExtArgs>
        fields: Prisma.OwnedFirearmFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OwnedFirearmFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnedFirearmPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OwnedFirearmFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnedFirearmPayload>
          }
          findFirst: {
            args: Prisma.OwnedFirearmFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnedFirearmPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OwnedFirearmFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnedFirearmPayload>
          }
          findMany: {
            args: Prisma.OwnedFirearmFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnedFirearmPayload>[]
          }
          create: {
            args: Prisma.OwnedFirearmCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnedFirearmPayload>
          }
          createMany: {
            args: Prisma.OwnedFirearmCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OwnedFirearmCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnedFirearmPayload>[]
          }
          delete: {
            args: Prisma.OwnedFirearmDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnedFirearmPayload>
          }
          update: {
            args: Prisma.OwnedFirearmUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnedFirearmPayload>
          }
          deleteMany: {
            args: Prisma.OwnedFirearmDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OwnedFirearmUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OwnedFirearmUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnedFirearmPayload>[]
          }
          upsert: {
            args: Prisma.OwnedFirearmUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnedFirearmPayload>
          }
          aggregate: {
            args: Prisma.OwnedFirearmAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOwnedFirearm>
          }
          groupBy: {
            args: Prisma.OwnedFirearmGroupByArgs<ExtArgs>
            result: $Utils.Optional<OwnedFirearmGroupByOutputType>[]
          }
          count: {
            args: Prisma.OwnedFirearmCountArgs<ExtArgs>
            result: $Utils.Optional<OwnedFirearmCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      raw_offer_ingest: {
        payload: Prisma.$raw_offer_ingestPayload<ExtArgs>
        fields: Prisma.raw_offer_ingestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.raw_offer_ingestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$raw_offer_ingestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.raw_offer_ingestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$raw_offer_ingestPayload>
          }
          findFirst: {
            args: Prisma.raw_offer_ingestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$raw_offer_ingestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.raw_offer_ingestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$raw_offer_ingestPayload>
          }
          findMany: {
            args: Prisma.raw_offer_ingestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$raw_offer_ingestPayload>[]
          }
          create: {
            args: Prisma.raw_offer_ingestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$raw_offer_ingestPayload>
          }
          createMany: {
            args: Prisma.raw_offer_ingestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.raw_offer_ingestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$raw_offer_ingestPayload>[]
          }
          delete: {
            args: Prisma.raw_offer_ingestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$raw_offer_ingestPayload>
          }
          update: {
            args: Prisma.raw_offer_ingestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$raw_offer_ingestPayload>
          }
          deleteMany: {
            args: Prisma.raw_offer_ingestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.raw_offer_ingestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.raw_offer_ingestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$raw_offer_ingestPayload>[]
          }
          upsert: {
            args: Prisma.raw_offer_ingestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$raw_offer_ingestPayload>
          }
          aggregate: {
            args: Prisma.Raw_offer_ingestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRaw_offer_ingest>
          }
          groupBy: {
            args: Prisma.raw_offer_ingestGroupByArgs<ExtArgs>
            result: $Utils.Optional<Raw_offer_ingestGroupByOutputType>[]
          }
          count: {
            args: Prisma.raw_offer_ingestCountArgs<ExtArgs>
            result: $Utils.Optional<Raw_offer_ingestCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://pris.ly/d/logging).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory
    /**
     * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
     */
    accelerateUrl?: string
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
    /**
     * SQL commenter plugins that add metadata to SQL queries as comments.
     * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   adapter,
     *   comments: [
     *     traceContext(),
     *     queryInsights(),
     *   ],
     * })
     * ```
     */
    comments?: runtime.SqlCommenterPlugin[]
  }
  export type GlobalOmitConfig = {
    brand?: BrandOmit
    caliber?: CaliberOmit
    offer?: OfferOmit
    retailer?: RetailerOmit
    accessoryFitment?: AccessoryFitmentOmit
    accessorySpecs?: AccessorySpecsOmit
    accessoryType?: AccessoryTypeOmit
    alert?: AlertOmit
    alertDelivery?: AlertDeliveryOmit
    ammoSpecs?: AmmoSpecsOmit
    blockedRetailer?: BlockedRetailerOmit
    caliberAlias?: CaliberAliasOmit
    catalogItem?: CatalogItemOmit
    firearmCategory?: FirearmCategoryOmit
    firearmChamber?: FirearmChamberOmit
    firearmSpecs?: FirearmSpecsOmit
    ownedFirearm?: OwnedFirearmOmit
    user?: UserOmit
    raw_offer_ingest?: raw_offer_ingestOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type BrandCountOutputType
   */

  export type BrandCountOutputType = {
    CatalogItem: number
  }

  export type BrandCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CatalogItem?: boolean | BrandCountOutputTypeCountCatalogItemArgs
  }

  // Custom InputTypes
  /**
   * BrandCountOutputType without action
   */
  export type BrandCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BrandCountOutputType
     */
    select?: BrandCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BrandCountOutputType without action
   */
  export type BrandCountOutputTypeCountCatalogItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CatalogItemWhereInput
  }


  /**
   * Count Type CaliberCountOutputType
   */

  export type CaliberCountOutputType = {
    Alert: number
    AmmoSpecs: number
    CaliberAlias: number
    FirearmChamber: number
  }

  export type CaliberCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Alert?: boolean | CaliberCountOutputTypeCountAlertArgs
    AmmoSpecs?: boolean | CaliberCountOutputTypeCountAmmoSpecsArgs
    CaliberAlias?: boolean | CaliberCountOutputTypeCountCaliberAliasArgs
    FirearmChamber?: boolean | CaliberCountOutputTypeCountFirearmChamberArgs
  }

  // Custom InputTypes
  /**
   * CaliberCountOutputType without action
   */
  export type CaliberCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaliberCountOutputType
     */
    select?: CaliberCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CaliberCountOutputType without action
   */
  export type CaliberCountOutputTypeCountAlertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlertWhereInput
  }

  /**
   * CaliberCountOutputType without action
   */
  export type CaliberCountOutputTypeCountAmmoSpecsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AmmoSpecsWhereInput
  }

  /**
   * CaliberCountOutputType without action
   */
  export type CaliberCountOutputTypeCountCaliberAliasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CaliberAliasWhereInput
  }

  /**
   * CaliberCountOutputType without action
   */
  export type CaliberCountOutputTypeCountFirearmChamberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FirearmChamberWhereInput
  }


  /**
   * Count Type OfferCountOutputType
   */

  export type OfferCountOutputType = {
    AlertDelivery: number
  }

  export type OfferCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AlertDelivery?: boolean | OfferCountOutputTypeCountAlertDeliveryArgs
  }

  // Custom InputTypes
  /**
   * OfferCountOutputType without action
   */
  export type OfferCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferCountOutputType
     */
    select?: OfferCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OfferCountOutputType without action
   */
  export type OfferCountOutputTypeCountAlertDeliveryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlertDeliveryWhereInput
  }


  /**
   * Count Type RetailerCountOutputType
   */

  export type RetailerCountOutputType = {
    BlockedRetailer: number
    offers: number
  }

  export type RetailerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BlockedRetailer?: boolean | RetailerCountOutputTypeCountBlockedRetailerArgs
    offers?: boolean | RetailerCountOutputTypeCountOffersArgs
  }

  // Custom InputTypes
  /**
   * RetailerCountOutputType without action
   */
  export type RetailerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RetailerCountOutputType
     */
    select?: RetailerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RetailerCountOutputType without action
   */
  export type RetailerCountOutputTypeCountBlockedRetailerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlockedRetailerWhereInput
  }

  /**
   * RetailerCountOutputType without action
   */
  export type RetailerCountOutputTypeCountOffersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OfferWhereInput
  }


  /**
   * Count Type AccessorySpecsCountOutputType
   */

  export type AccessorySpecsCountOutputType = {
    AccessoryFitment: number
  }

  export type AccessorySpecsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AccessoryFitment?: boolean | AccessorySpecsCountOutputTypeCountAccessoryFitmentArgs
  }

  // Custom InputTypes
  /**
   * AccessorySpecsCountOutputType without action
   */
  export type AccessorySpecsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessorySpecsCountOutputType
     */
    select?: AccessorySpecsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AccessorySpecsCountOutputType without action
   */
  export type AccessorySpecsCountOutputTypeCountAccessoryFitmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccessoryFitmentWhereInput
  }


  /**
   * Count Type AccessoryTypeCountOutputType
   */

  export type AccessoryTypeCountOutputType = {
    AccessorySpecs: number
  }

  export type AccessoryTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AccessorySpecs?: boolean | AccessoryTypeCountOutputTypeCountAccessorySpecsArgs
  }

  // Custom InputTypes
  /**
   * AccessoryTypeCountOutputType without action
   */
  export type AccessoryTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessoryTypeCountOutputType
     */
    select?: AccessoryTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AccessoryTypeCountOutputType without action
   */
  export type AccessoryTypeCountOutputTypeCountAccessorySpecsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccessorySpecsWhereInput
  }


  /**
   * Count Type AlertCountOutputType
   */

  export type AlertCountOutputType = {
    AlertDelivery: number
  }

  export type AlertCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AlertDelivery?: boolean | AlertCountOutputTypeCountAlertDeliveryArgs
  }

  // Custom InputTypes
  /**
   * AlertCountOutputType without action
   */
  export type AlertCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertCountOutputType
     */
    select?: AlertCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AlertCountOutputType without action
   */
  export type AlertCountOutputTypeCountAlertDeliveryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlertDeliveryWhereInput
  }


  /**
   * Count Type CatalogItemCountOutputType
   */

  export type CatalogItemCountOutputType = {
    AccessoryFitment: number
    Alert: number
    Offer: number
    OwnedFirearm: number
  }

  export type CatalogItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AccessoryFitment?: boolean | CatalogItemCountOutputTypeCountAccessoryFitmentArgs
    Alert?: boolean | CatalogItemCountOutputTypeCountAlertArgs
    Offer?: boolean | CatalogItemCountOutputTypeCountOfferArgs
    OwnedFirearm?: boolean | CatalogItemCountOutputTypeCountOwnedFirearmArgs
  }

  // Custom InputTypes
  /**
   * CatalogItemCountOutputType without action
   */
  export type CatalogItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogItemCountOutputType
     */
    select?: CatalogItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CatalogItemCountOutputType without action
   */
  export type CatalogItemCountOutputTypeCountAccessoryFitmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccessoryFitmentWhereInput
  }

  /**
   * CatalogItemCountOutputType without action
   */
  export type CatalogItemCountOutputTypeCountAlertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlertWhereInput
  }

  /**
   * CatalogItemCountOutputType without action
   */
  export type CatalogItemCountOutputTypeCountOfferArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OfferWhereInput
  }

  /**
   * CatalogItemCountOutputType without action
   */
  export type CatalogItemCountOutputTypeCountOwnedFirearmArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OwnedFirearmWhereInput
  }


  /**
   * Count Type FirearmCategoryCountOutputType
   */

  export type FirearmCategoryCountOutputType = {
    FirearmSpecs: number
  }

  export type FirearmCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    FirearmSpecs?: boolean | FirearmCategoryCountOutputTypeCountFirearmSpecsArgs
  }

  // Custom InputTypes
  /**
   * FirearmCategoryCountOutputType without action
   */
  export type FirearmCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FirearmCategoryCountOutputType
     */
    select?: FirearmCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FirearmCategoryCountOutputType without action
   */
  export type FirearmCategoryCountOutputTypeCountFirearmSpecsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FirearmSpecsWhereInput
  }


  /**
   * Count Type FirearmSpecsCountOutputType
   */

  export type FirearmSpecsCountOutputType = {
    FirearmChamber: number
  }

  export type FirearmSpecsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    FirearmChamber?: boolean | FirearmSpecsCountOutputTypeCountFirearmChamberArgs
  }

  // Custom InputTypes
  /**
   * FirearmSpecsCountOutputType without action
   */
  export type FirearmSpecsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FirearmSpecsCountOutputType
     */
    select?: FirearmSpecsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FirearmSpecsCountOutputType without action
   */
  export type FirearmSpecsCountOutputTypeCountFirearmChamberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FirearmChamberWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    Alert: number
    AlertDelivery: number
    BlockedRetailer: number
    OwnedFirearm: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Alert?: boolean | UserCountOutputTypeCountAlertArgs
    AlertDelivery?: boolean | UserCountOutputTypeCountAlertDeliveryArgs
    BlockedRetailer?: boolean | UserCountOutputTypeCountBlockedRetailerArgs
    OwnedFirearm?: boolean | UserCountOutputTypeCountOwnedFirearmArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAlertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlertWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAlertDeliveryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlertDeliveryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBlockedRetailerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlockedRetailerWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOwnedFirearmArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OwnedFirearmWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Brand
   */

  export type AggregateBrand = {
    _count: BrandCountAggregateOutputType | null
    _avg: BrandAvgAggregateOutputType | null
    _sum: BrandSumAggregateOutputType | null
    _min: BrandMinAggregateOutputType | null
    _max: BrandMaxAggregateOutputType | null
  }

  export type BrandAvgAggregateOutputType = {
    id: number | null
  }

  export type BrandSumAggregateOutputType = {
    id: number | null
  }

  export type BrandMinAggregateOutputType = {
    id: number | null
    name: string | null
    slug: string | null
    website: string | null
    logo: string | null
    description: string | null
  }

  export type BrandMaxAggregateOutputType = {
    id: number | null
    name: string | null
    slug: string | null
    website: string | null
    logo: string | null
    description: string | null
  }

  export type BrandCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    website: number
    logo: number
    description: number
    _all: number
  }


  export type BrandAvgAggregateInputType = {
    id?: true
  }

  export type BrandSumAggregateInputType = {
    id?: true
  }

  export type BrandMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    website?: true
    logo?: true
    description?: true
  }

  export type BrandMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    website?: true
    logo?: true
    description?: true
  }

  export type BrandCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    website?: true
    logo?: true
    description?: true
    _all?: true
  }

  export type BrandAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Brand to aggregate.
     */
    where?: BrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Brands to fetch.
     */
    orderBy?: BrandOrderByWithRelationInput | BrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Brands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Brands
    **/
    _count?: true | BrandCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BrandAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BrandSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BrandMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BrandMaxAggregateInputType
  }

  export type GetBrandAggregateType<T extends BrandAggregateArgs> = {
        [P in keyof T & keyof AggregateBrand]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBrand[P]>
      : GetScalarType<T[P], AggregateBrand[P]>
  }




  export type BrandGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BrandWhereInput
    orderBy?: BrandOrderByWithAggregationInput | BrandOrderByWithAggregationInput[]
    by: BrandScalarFieldEnum[] | BrandScalarFieldEnum
    having?: BrandScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BrandCountAggregateInputType | true
    _avg?: BrandAvgAggregateInputType
    _sum?: BrandSumAggregateInputType
    _min?: BrandMinAggregateInputType
    _max?: BrandMaxAggregateInputType
  }

  export type BrandGroupByOutputType = {
    id: number
    name: string
    slug: string
    website: string | null
    logo: string | null
    description: string | null
    _count: BrandCountAggregateOutputType | null
    _avg: BrandAvgAggregateOutputType | null
    _sum: BrandSumAggregateOutputType | null
    _min: BrandMinAggregateOutputType | null
    _max: BrandMaxAggregateOutputType | null
  }

  type GetBrandGroupByPayload<T extends BrandGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BrandGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BrandGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BrandGroupByOutputType[P]>
            : GetScalarType<T[P], BrandGroupByOutputType[P]>
        }
      >
    >


  export type BrandSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    website?: boolean
    logo?: boolean
    description?: boolean
    CatalogItem?: boolean | Brand$CatalogItemArgs<ExtArgs>
    _count?: boolean | BrandCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["brand"]>

  export type BrandSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    website?: boolean
    logo?: boolean
    description?: boolean
  }, ExtArgs["result"]["brand"]>

  export type BrandSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    website?: boolean
    logo?: boolean
    description?: boolean
  }, ExtArgs["result"]["brand"]>

  export type BrandSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    website?: boolean
    logo?: boolean
    description?: boolean
  }

  export type BrandOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "website" | "logo" | "description", ExtArgs["result"]["brand"]>
  export type BrandInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CatalogItem?: boolean | Brand$CatalogItemArgs<ExtArgs>
    _count?: boolean | BrandCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BrandIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type BrandIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BrandPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Brand"
    objects: {
      CatalogItem: Prisma.$CatalogItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      slug: string
      website: string | null
      logo: string | null
      description: string | null
    }, ExtArgs["result"]["brand"]>
    composites: {}
  }

  type BrandGetPayload<S extends boolean | null | undefined | BrandDefaultArgs> = $Result.GetResult<Prisma.$BrandPayload, S>

  type BrandCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BrandFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BrandCountAggregateInputType | true
    }

  export interface BrandDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Brand'], meta: { name: 'Brand' } }
    /**
     * Find zero or one Brand that matches the filter.
     * @param {BrandFindUniqueArgs} args - Arguments to find a Brand
     * @example
     * // Get one Brand
     * const brand = await prisma.brand.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BrandFindUniqueArgs>(args: SelectSubset<T, BrandFindUniqueArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Brand that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BrandFindUniqueOrThrowArgs} args - Arguments to find a Brand
     * @example
     * // Get one Brand
     * const brand = await prisma.brand.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BrandFindUniqueOrThrowArgs>(args: SelectSubset<T, BrandFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Brand that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandFindFirstArgs} args - Arguments to find a Brand
     * @example
     * // Get one Brand
     * const brand = await prisma.brand.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BrandFindFirstArgs>(args?: SelectSubset<T, BrandFindFirstArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Brand that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandFindFirstOrThrowArgs} args - Arguments to find a Brand
     * @example
     * // Get one Brand
     * const brand = await prisma.brand.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BrandFindFirstOrThrowArgs>(args?: SelectSubset<T, BrandFindFirstOrThrowArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Brands that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Brands
     * const brands = await prisma.brand.findMany()
     * 
     * // Get first 10 Brands
     * const brands = await prisma.brand.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const brandWithIdOnly = await prisma.brand.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BrandFindManyArgs>(args?: SelectSubset<T, BrandFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Brand.
     * @param {BrandCreateArgs} args - Arguments to create a Brand.
     * @example
     * // Create one Brand
     * const Brand = await prisma.brand.create({
     *   data: {
     *     // ... data to create a Brand
     *   }
     * })
     * 
     */
    create<T extends BrandCreateArgs>(args: SelectSubset<T, BrandCreateArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Brands.
     * @param {BrandCreateManyArgs} args - Arguments to create many Brands.
     * @example
     * // Create many Brands
     * const brand = await prisma.brand.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BrandCreateManyArgs>(args?: SelectSubset<T, BrandCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Brands and returns the data saved in the database.
     * @param {BrandCreateManyAndReturnArgs} args - Arguments to create many Brands.
     * @example
     * // Create many Brands
     * const brand = await prisma.brand.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Brands and only return the `id`
     * const brandWithIdOnly = await prisma.brand.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BrandCreateManyAndReturnArgs>(args?: SelectSubset<T, BrandCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Brand.
     * @param {BrandDeleteArgs} args - Arguments to delete one Brand.
     * @example
     * // Delete one Brand
     * const Brand = await prisma.brand.delete({
     *   where: {
     *     // ... filter to delete one Brand
     *   }
     * })
     * 
     */
    delete<T extends BrandDeleteArgs>(args: SelectSubset<T, BrandDeleteArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Brand.
     * @param {BrandUpdateArgs} args - Arguments to update one Brand.
     * @example
     * // Update one Brand
     * const brand = await prisma.brand.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BrandUpdateArgs>(args: SelectSubset<T, BrandUpdateArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Brands.
     * @param {BrandDeleteManyArgs} args - Arguments to filter Brands to delete.
     * @example
     * // Delete a few Brands
     * const { count } = await prisma.brand.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BrandDeleteManyArgs>(args?: SelectSubset<T, BrandDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Brands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Brands
     * const brand = await prisma.brand.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BrandUpdateManyArgs>(args: SelectSubset<T, BrandUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Brands and returns the data updated in the database.
     * @param {BrandUpdateManyAndReturnArgs} args - Arguments to update many Brands.
     * @example
     * // Update many Brands
     * const brand = await prisma.brand.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Brands and only return the `id`
     * const brandWithIdOnly = await prisma.brand.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BrandUpdateManyAndReturnArgs>(args: SelectSubset<T, BrandUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Brand.
     * @param {BrandUpsertArgs} args - Arguments to update or create a Brand.
     * @example
     * // Update or create a Brand
     * const brand = await prisma.brand.upsert({
     *   create: {
     *     // ... data to create a Brand
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Brand we want to update
     *   }
     * })
     */
    upsert<T extends BrandUpsertArgs>(args: SelectSubset<T, BrandUpsertArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Brands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandCountArgs} args - Arguments to filter Brands to count.
     * @example
     * // Count the number of Brands
     * const count = await prisma.brand.count({
     *   where: {
     *     // ... the filter for the Brands we want to count
     *   }
     * })
    **/
    count<T extends BrandCountArgs>(
      args?: Subset<T, BrandCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BrandCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Brand.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BrandAggregateArgs>(args: Subset<T, BrandAggregateArgs>): Prisma.PrismaPromise<GetBrandAggregateType<T>>

    /**
     * Group by Brand.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BrandGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BrandGroupByArgs['orderBy'] }
        : { orderBy?: BrandGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BrandGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBrandGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Brand model
   */
  readonly fields: BrandFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Brand.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BrandClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    CatalogItem<T extends Brand$CatalogItemArgs<ExtArgs> = {}>(args?: Subset<T, Brand$CatalogItemArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatalogItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Brand model
   */
  interface BrandFieldRefs {
    readonly id: FieldRef<"Brand", 'Int'>
    readonly name: FieldRef<"Brand", 'String'>
    readonly slug: FieldRef<"Brand", 'String'>
    readonly website: FieldRef<"Brand", 'String'>
    readonly logo: FieldRef<"Brand", 'String'>
    readonly description: FieldRef<"Brand", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Brand findUnique
   */
  export type BrandFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * Filter, which Brand to fetch.
     */
    where: BrandWhereUniqueInput
  }

  /**
   * Brand findUniqueOrThrow
   */
  export type BrandFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * Filter, which Brand to fetch.
     */
    where: BrandWhereUniqueInput
  }

  /**
   * Brand findFirst
   */
  export type BrandFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * Filter, which Brand to fetch.
     */
    where?: BrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Brands to fetch.
     */
    orderBy?: BrandOrderByWithRelationInput | BrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Brands.
     */
    cursor?: BrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Brands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Brands.
     */
    distinct?: BrandScalarFieldEnum | BrandScalarFieldEnum[]
  }

  /**
   * Brand findFirstOrThrow
   */
  export type BrandFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * Filter, which Brand to fetch.
     */
    where?: BrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Brands to fetch.
     */
    orderBy?: BrandOrderByWithRelationInput | BrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Brands.
     */
    cursor?: BrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Brands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Brands.
     */
    distinct?: BrandScalarFieldEnum | BrandScalarFieldEnum[]
  }

  /**
   * Brand findMany
   */
  export type BrandFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * Filter, which Brands to fetch.
     */
    where?: BrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Brands to fetch.
     */
    orderBy?: BrandOrderByWithRelationInput | BrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Brands.
     */
    cursor?: BrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Brands.
     */
    skip?: number
    distinct?: BrandScalarFieldEnum | BrandScalarFieldEnum[]
  }

  /**
   * Brand create
   */
  export type BrandCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * The data needed to create a Brand.
     */
    data: XOR<BrandCreateInput, BrandUncheckedCreateInput>
  }

  /**
   * Brand createMany
   */
  export type BrandCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Brands.
     */
    data: BrandCreateManyInput | BrandCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Brand createManyAndReturn
   */
  export type BrandCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * The data used to create many Brands.
     */
    data: BrandCreateManyInput | BrandCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Brand update
   */
  export type BrandUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * The data needed to update a Brand.
     */
    data: XOR<BrandUpdateInput, BrandUncheckedUpdateInput>
    /**
     * Choose, which Brand to update.
     */
    where: BrandWhereUniqueInput
  }

  /**
   * Brand updateMany
   */
  export type BrandUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Brands.
     */
    data: XOR<BrandUpdateManyMutationInput, BrandUncheckedUpdateManyInput>
    /**
     * Filter which Brands to update
     */
    where?: BrandWhereInput
    /**
     * Limit how many Brands to update.
     */
    limit?: number
  }

  /**
   * Brand updateManyAndReturn
   */
  export type BrandUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * The data used to update Brands.
     */
    data: XOR<BrandUpdateManyMutationInput, BrandUncheckedUpdateManyInput>
    /**
     * Filter which Brands to update
     */
    where?: BrandWhereInput
    /**
     * Limit how many Brands to update.
     */
    limit?: number
  }

  /**
   * Brand upsert
   */
  export type BrandUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * The filter to search for the Brand to update in case it exists.
     */
    where: BrandWhereUniqueInput
    /**
     * In case the Brand found by the `where` argument doesn't exist, create a new Brand with this data.
     */
    create: XOR<BrandCreateInput, BrandUncheckedCreateInput>
    /**
     * In case the Brand was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BrandUpdateInput, BrandUncheckedUpdateInput>
  }

  /**
   * Brand delete
   */
  export type BrandDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * Filter which Brand to delete.
     */
    where: BrandWhereUniqueInput
  }

  /**
   * Brand deleteMany
   */
  export type BrandDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Brands to delete
     */
    where?: BrandWhereInput
    /**
     * Limit how many Brands to delete.
     */
    limit?: number
  }

  /**
   * Brand.CatalogItem
   */
  export type Brand$CatalogItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogItem
     */
    select?: CatalogItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CatalogItem
     */
    omit?: CatalogItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogItemInclude<ExtArgs> | null
    where?: CatalogItemWhereInput
    orderBy?: CatalogItemOrderByWithRelationInput | CatalogItemOrderByWithRelationInput[]
    cursor?: CatalogItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CatalogItemScalarFieldEnum | CatalogItemScalarFieldEnum[]
  }

  /**
   * Brand without action
   */
  export type BrandDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
  }


  /**
   * Model Caliber
   */

  export type AggregateCaliber = {
    _count: CaliberCountAggregateOutputType | null
    _avg: CaliberAvgAggregateOutputType | null
    _sum: CaliberSumAggregateOutputType | null
    _min: CaliberMinAggregateOutputType | null
    _max: CaliberMaxAggregateOutputType | null
  }

  export type CaliberAvgAggregateOutputType = {
    id: number | null
  }

  export type CaliberSumAggregateOutputType = {
    id: number | null
  }

  export type CaliberMinAggregateOutputType = {
    id: number | null
    name: string | null
    slug: string | null
    type: string | null
  }

  export type CaliberMaxAggregateOutputType = {
    id: number | null
    name: string | null
    slug: string | null
    type: string | null
  }

  export type CaliberCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    type: number
    _all: number
  }


  export type CaliberAvgAggregateInputType = {
    id?: true
  }

  export type CaliberSumAggregateInputType = {
    id?: true
  }

  export type CaliberMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    type?: true
  }

  export type CaliberMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    type?: true
  }

  export type CaliberCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    type?: true
    _all?: true
  }

  export type CaliberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Caliber to aggregate.
     */
    where?: CaliberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Calibers to fetch.
     */
    orderBy?: CaliberOrderByWithRelationInput | CaliberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CaliberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Calibers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Calibers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Calibers
    **/
    _count?: true | CaliberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CaliberAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CaliberSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CaliberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CaliberMaxAggregateInputType
  }

  export type GetCaliberAggregateType<T extends CaliberAggregateArgs> = {
        [P in keyof T & keyof AggregateCaliber]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCaliber[P]>
      : GetScalarType<T[P], AggregateCaliber[P]>
  }




  export type CaliberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CaliberWhereInput
    orderBy?: CaliberOrderByWithAggregationInput | CaliberOrderByWithAggregationInput[]
    by: CaliberScalarFieldEnum[] | CaliberScalarFieldEnum
    having?: CaliberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CaliberCountAggregateInputType | true
    _avg?: CaliberAvgAggregateInputType
    _sum?: CaliberSumAggregateInputType
    _min?: CaliberMinAggregateInputType
    _max?: CaliberMaxAggregateInputType
  }

  export type CaliberGroupByOutputType = {
    id: number
    name: string
    slug: string
    type: string | null
    _count: CaliberCountAggregateOutputType | null
    _avg: CaliberAvgAggregateOutputType | null
    _sum: CaliberSumAggregateOutputType | null
    _min: CaliberMinAggregateOutputType | null
    _max: CaliberMaxAggregateOutputType | null
  }

  type GetCaliberGroupByPayload<T extends CaliberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CaliberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CaliberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CaliberGroupByOutputType[P]>
            : GetScalarType<T[P], CaliberGroupByOutputType[P]>
        }
      >
    >


  export type CaliberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    type?: boolean
    Alert?: boolean | Caliber$AlertArgs<ExtArgs>
    AmmoSpecs?: boolean | Caliber$AmmoSpecsArgs<ExtArgs>
    CaliberAlias?: boolean | Caliber$CaliberAliasArgs<ExtArgs>
    FirearmChamber?: boolean | Caliber$FirearmChamberArgs<ExtArgs>
    _count?: boolean | CaliberCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["caliber"]>

  export type CaliberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    type?: boolean
  }, ExtArgs["result"]["caliber"]>

  export type CaliberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    type?: boolean
  }, ExtArgs["result"]["caliber"]>

  export type CaliberSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    type?: boolean
  }

  export type CaliberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "type", ExtArgs["result"]["caliber"]>
  export type CaliberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Alert?: boolean | Caliber$AlertArgs<ExtArgs>
    AmmoSpecs?: boolean | Caliber$AmmoSpecsArgs<ExtArgs>
    CaliberAlias?: boolean | Caliber$CaliberAliasArgs<ExtArgs>
    FirearmChamber?: boolean | Caliber$FirearmChamberArgs<ExtArgs>
    _count?: boolean | CaliberCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CaliberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CaliberIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CaliberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Caliber"
    objects: {
      Alert: Prisma.$AlertPayload<ExtArgs>[]
      AmmoSpecs: Prisma.$AmmoSpecsPayload<ExtArgs>[]
      CaliberAlias: Prisma.$CaliberAliasPayload<ExtArgs>[]
      FirearmChamber: Prisma.$FirearmChamberPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      slug: string
      type: string | null
    }, ExtArgs["result"]["caliber"]>
    composites: {}
  }

  type CaliberGetPayload<S extends boolean | null | undefined | CaliberDefaultArgs> = $Result.GetResult<Prisma.$CaliberPayload, S>

  type CaliberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CaliberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CaliberCountAggregateInputType | true
    }

  export interface CaliberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Caliber'], meta: { name: 'Caliber' } }
    /**
     * Find zero or one Caliber that matches the filter.
     * @param {CaliberFindUniqueArgs} args - Arguments to find a Caliber
     * @example
     * // Get one Caliber
     * const caliber = await prisma.caliber.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CaliberFindUniqueArgs>(args: SelectSubset<T, CaliberFindUniqueArgs<ExtArgs>>): Prisma__CaliberClient<$Result.GetResult<Prisma.$CaliberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Caliber that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CaliberFindUniqueOrThrowArgs} args - Arguments to find a Caliber
     * @example
     * // Get one Caliber
     * const caliber = await prisma.caliber.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CaliberFindUniqueOrThrowArgs>(args: SelectSubset<T, CaliberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CaliberClient<$Result.GetResult<Prisma.$CaliberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Caliber that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaliberFindFirstArgs} args - Arguments to find a Caliber
     * @example
     * // Get one Caliber
     * const caliber = await prisma.caliber.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CaliberFindFirstArgs>(args?: SelectSubset<T, CaliberFindFirstArgs<ExtArgs>>): Prisma__CaliberClient<$Result.GetResult<Prisma.$CaliberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Caliber that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaliberFindFirstOrThrowArgs} args - Arguments to find a Caliber
     * @example
     * // Get one Caliber
     * const caliber = await prisma.caliber.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CaliberFindFirstOrThrowArgs>(args?: SelectSubset<T, CaliberFindFirstOrThrowArgs<ExtArgs>>): Prisma__CaliberClient<$Result.GetResult<Prisma.$CaliberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Calibers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaliberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Calibers
     * const calibers = await prisma.caliber.findMany()
     * 
     * // Get first 10 Calibers
     * const calibers = await prisma.caliber.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const caliberWithIdOnly = await prisma.caliber.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CaliberFindManyArgs>(args?: SelectSubset<T, CaliberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CaliberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Caliber.
     * @param {CaliberCreateArgs} args - Arguments to create a Caliber.
     * @example
     * // Create one Caliber
     * const Caliber = await prisma.caliber.create({
     *   data: {
     *     // ... data to create a Caliber
     *   }
     * })
     * 
     */
    create<T extends CaliberCreateArgs>(args: SelectSubset<T, CaliberCreateArgs<ExtArgs>>): Prisma__CaliberClient<$Result.GetResult<Prisma.$CaliberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Calibers.
     * @param {CaliberCreateManyArgs} args - Arguments to create many Calibers.
     * @example
     * // Create many Calibers
     * const caliber = await prisma.caliber.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CaliberCreateManyArgs>(args?: SelectSubset<T, CaliberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Calibers and returns the data saved in the database.
     * @param {CaliberCreateManyAndReturnArgs} args - Arguments to create many Calibers.
     * @example
     * // Create many Calibers
     * const caliber = await prisma.caliber.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Calibers and only return the `id`
     * const caliberWithIdOnly = await prisma.caliber.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CaliberCreateManyAndReturnArgs>(args?: SelectSubset<T, CaliberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CaliberPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Caliber.
     * @param {CaliberDeleteArgs} args - Arguments to delete one Caliber.
     * @example
     * // Delete one Caliber
     * const Caliber = await prisma.caliber.delete({
     *   where: {
     *     // ... filter to delete one Caliber
     *   }
     * })
     * 
     */
    delete<T extends CaliberDeleteArgs>(args: SelectSubset<T, CaliberDeleteArgs<ExtArgs>>): Prisma__CaliberClient<$Result.GetResult<Prisma.$CaliberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Caliber.
     * @param {CaliberUpdateArgs} args - Arguments to update one Caliber.
     * @example
     * // Update one Caliber
     * const caliber = await prisma.caliber.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CaliberUpdateArgs>(args: SelectSubset<T, CaliberUpdateArgs<ExtArgs>>): Prisma__CaliberClient<$Result.GetResult<Prisma.$CaliberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Calibers.
     * @param {CaliberDeleteManyArgs} args - Arguments to filter Calibers to delete.
     * @example
     * // Delete a few Calibers
     * const { count } = await prisma.caliber.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CaliberDeleteManyArgs>(args?: SelectSubset<T, CaliberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Calibers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaliberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Calibers
     * const caliber = await prisma.caliber.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CaliberUpdateManyArgs>(args: SelectSubset<T, CaliberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Calibers and returns the data updated in the database.
     * @param {CaliberUpdateManyAndReturnArgs} args - Arguments to update many Calibers.
     * @example
     * // Update many Calibers
     * const caliber = await prisma.caliber.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Calibers and only return the `id`
     * const caliberWithIdOnly = await prisma.caliber.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CaliberUpdateManyAndReturnArgs>(args: SelectSubset<T, CaliberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CaliberPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Caliber.
     * @param {CaliberUpsertArgs} args - Arguments to update or create a Caliber.
     * @example
     * // Update or create a Caliber
     * const caliber = await prisma.caliber.upsert({
     *   create: {
     *     // ... data to create a Caliber
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Caliber we want to update
     *   }
     * })
     */
    upsert<T extends CaliberUpsertArgs>(args: SelectSubset<T, CaliberUpsertArgs<ExtArgs>>): Prisma__CaliberClient<$Result.GetResult<Prisma.$CaliberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Calibers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaliberCountArgs} args - Arguments to filter Calibers to count.
     * @example
     * // Count the number of Calibers
     * const count = await prisma.caliber.count({
     *   where: {
     *     // ... the filter for the Calibers we want to count
     *   }
     * })
    **/
    count<T extends CaliberCountArgs>(
      args?: Subset<T, CaliberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CaliberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Caliber.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaliberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CaliberAggregateArgs>(args: Subset<T, CaliberAggregateArgs>): Prisma.PrismaPromise<GetCaliberAggregateType<T>>

    /**
     * Group by Caliber.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaliberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CaliberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CaliberGroupByArgs['orderBy'] }
        : { orderBy?: CaliberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CaliberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCaliberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Caliber model
   */
  readonly fields: CaliberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Caliber.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CaliberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Alert<T extends Caliber$AlertArgs<ExtArgs> = {}>(args?: Subset<T, Caliber$AlertArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    AmmoSpecs<T extends Caliber$AmmoSpecsArgs<ExtArgs> = {}>(args?: Subset<T, Caliber$AmmoSpecsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AmmoSpecsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    CaliberAlias<T extends Caliber$CaliberAliasArgs<ExtArgs> = {}>(args?: Subset<T, Caliber$CaliberAliasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CaliberAliasPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    FirearmChamber<T extends Caliber$FirearmChamberArgs<ExtArgs> = {}>(args?: Subset<T, Caliber$FirearmChamberArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FirearmChamberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Caliber model
   */
  interface CaliberFieldRefs {
    readonly id: FieldRef<"Caliber", 'Int'>
    readonly name: FieldRef<"Caliber", 'String'>
    readonly slug: FieldRef<"Caliber", 'String'>
    readonly type: FieldRef<"Caliber", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Caliber findUnique
   */
  export type CaliberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Caliber
     */
    select?: CaliberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Caliber
     */
    omit?: CaliberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaliberInclude<ExtArgs> | null
    /**
     * Filter, which Caliber to fetch.
     */
    where: CaliberWhereUniqueInput
  }

  /**
   * Caliber findUniqueOrThrow
   */
  export type CaliberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Caliber
     */
    select?: CaliberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Caliber
     */
    omit?: CaliberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaliberInclude<ExtArgs> | null
    /**
     * Filter, which Caliber to fetch.
     */
    where: CaliberWhereUniqueInput
  }

  /**
   * Caliber findFirst
   */
  export type CaliberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Caliber
     */
    select?: CaliberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Caliber
     */
    omit?: CaliberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaliberInclude<ExtArgs> | null
    /**
     * Filter, which Caliber to fetch.
     */
    where?: CaliberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Calibers to fetch.
     */
    orderBy?: CaliberOrderByWithRelationInput | CaliberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Calibers.
     */
    cursor?: CaliberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Calibers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Calibers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Calibers.
     */
    distinct?: CaliberScalarFieldEnum | CaliberScalarFieldEnum[]
  }

  /**
   * Caliber findFirstOrThrow
   */
  export type CaliberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Caliber
     */
    select?: CaliberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Caliber
     */
    omit?: CaliberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaliberInclude<ExtArgs> | null
    /**
     * Filter, which Caliber to fetch.
     */
    where?: CaliberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Calibers to fetch.
     */
    orderBy?: CaliberOrderByWithRelationInput | CaliberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Calibers.
     */
    cursor?: CaliberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Calibers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Calibers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Calibers.
     */
    distinct?: CaliberScalarFieldEnum | CaliberScalarFieldEnum[]
  }

  /**
   * Caliber findMany
   */
  export type CaliberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Caliber
     */
    select?: CaliberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Caliber
     */
    omit?: CaliberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaliberInclude<ExtArgs> | null
    /**
     * Filter, which Calibers to fetch.
     */
    where?: CaliberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Calibers to fetch.
     */
    orderBy?: CaliberOrderByWithRelationInput | CaliberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Calibers.
     */
    cursor?: CaliberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Calibers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Calibers.
     */
    skip?: number
    distinct?: CaliberScalarFieldEnum | CaliberScalarFieldEnum[]
  }

  /**
   * Caliber create
   */
  export type CaliberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Caliber
     */
    select?: CaliberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Caliber
     */
    omit?: CaliberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaliberInclude<ExtArgs> | null
    /**
     * The data needed to create a Caliber.
     */
    data: XOR<CaliberCreateInput, CaliberUncheckedCreateInput>
  }

  /**
   * Caliber createMany
   */
  export type CaliberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Calibers.
     */
    data: CaliberCreateManyInput | CaliberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Caliber createManyAndReturn
   */
  export type CaliberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Caliber
     */
    select?: CaliberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Caliber
     */
    omit?: CaliberOmit<ExtArgs> | null
    /**
     * The data used to create many Calibers.
     */
    data: CaliberCreateManyInput | CaliberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Caliber update
   */
  export type CaliberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Caliber
     */
    select?: CaliberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Caliber
     */
    omit?: CaliberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaliberInclude<ExtArgs> | null
    /**
     * The data needed to update a Caliber.
     */
    data: XOR<CaliberUpdateInput, CaliberUncheckedUpdateInput>
    /**
     * Choose, which Caliber to update.
     */
    where: CaliberWhereUniqueInput
  }

  /**
   * Caliber updateMany
   */
  export type CaliberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Calibers.
     */
    data: XOR<CaliberUpdateManyMutationInput, CaliberUncheckedUpdateManyInput>
    /**
     * Filter which Calibers to update
     */
    where?: CaliberWhereInput
    /**
     * Limit how many Calibers to update.
     */
    limit?: number
  }

  /**
   * Caliber updateManyAndReturn
   */
  export type CaliberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Caliber
     */
    select?: CaliberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Caliber
     */
    omit?: CaliberOmit<ExtArgs> | null
    /**
     * The data used to update Calibers.
     */
    data: XOR<CaliberUpdateManyMutationInput, CaliberUncheckedUpdateManyInput>
    /**
     * Filter which Calibers to update
     */
    where?: CaliberWhereInput
    /**
     * Limit how many Calibers to update.
     */
    limit?: number
  }

  /**
   * Caliber upsert
   */
  export type CaliberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Caliber
     */
    select?: CaliberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Caliber
     */
    omit?: CaliberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaliberInclude<ExtArgs> | null
    /**
     * The filter to search for the Caliber to update in case it exists.
     */
    where: CaliberWhereUniqueInput
    /**
     * In case the Caliber found by the `where` argument doesn't exist, create a new Caliber with this data.
     */
    create: XOR<CaliberCreateInput, CaliberUncheckedCreateInput>
    /**
     * In case the Caliber was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CaliberUpdateInput, CaliberUncheckedUpdateInput>
  }

  /**
   * Caliber delete
   */
  export type CaliberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Caliber
     */
    select?: CaliberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Caliber
     */
    omit?: CaliberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaliberInclude<ExtArgs> | null
    /**
     * Filter which Caliber to delete.
     */
    where: CaliberWhereUniqueInput
  }

  /**
   * Caliber deleteMany
   */
  export type CaliberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Calibers to delete
     */
    where?: CaliberWhereInput
    /**
     * Limit how many Calibers to delete.
     */
    limit?: number
  }

  /**
   * Caliber.Alert
   */
  export type Caliber$AlertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    where?: AlertWhereInput
    orderBy?: AlertOrderByWithRelationInput | AlertOrderByWithRelationInput[]
    cursor?: AlertWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AlertScalarFieldEnum | AlertScalarFieldEnum[]
  }

  /**
   * Caliber.AmmoSpecs
   */
  export type Caliber$AmmoSpecsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmmoSpecs
     */
    select?: AmmoSpecsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmmoSpecs
     */
    omit?: AmmoSpecsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmmoSpecsInclude<ExtArgs> | null
    where?: AmmoSpecsWhereInput
    orderBy?: AmmoSpecsOrderByWithRelationInput | AmmoSpecsOrderByWithRelationInput[]
    cursor?: AmmoSpecsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AmmoSpecsScalarFieldEnum | AmmoSpecsScalarFieldEnum[]
  }

  /**
   * Caliber.CaliberAlias
   */
  export type Caliber$CaliberAliasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaliberAlias
     */
    select?: CaliberAliasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaliberAlias
     */
    omit?: CaliberAliasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaliberAliasInclude<ExtArgs> | null
    where?: CaliberAliasWhereInput
    orderBy?: CaliberAliasOrderByWithRelationInput | CaliberAliasOrderByWithRelationInput[]
    cursor?: CaliberAliasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CaliberAliasScalarFieldEnum | CaliberAliasScalarFieldEnum[]
  }

  /**
   * Caliber.FirearmChamber
   */
  export type Caliber$FirearmChamberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FirearmChamber
     */
    select?: FirearmChamberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FirearmChamber
     */
    omit?: FirearmChamberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FirearmChamberInclude<ExtArgs> | null
    where?: FirearmChamberWhereInput
    orderBy?: FirearmChamberOrderByWithRelationInput | FirearmChamberOrderByWithRelationInput[]
    cursor?: FirearmChamberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FirearmChamberScalarFieldEnum | FirearmChamberScalarFieldEnum[]
  }

  /**
   * Caliber without action
   */
  export type CaliberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Caliber
     */
    select?: CaliberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Caliber
     */
    omit?: CaliberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaliberInclude<ExtArgs> | null
  }


  /**
   * Model Offer
   */

  export type AggregateOffer = {
    _count: OfferCountAggregateOutputType | null
    _avg: OfferAvgAggregateOutputType | null
    _sum: OfferSumAggregateOutputType | null
    _min: OfferMinAggregateOutputType | null
    _max: OfferMaxAggregateOutputType | null
  }

  export type OfferAvgAggregateOutputType = {
    id: number | null
    retailerId: number | null
    price: number | null
    shippingCost: number | null
    total: number | null
    unitsCount: number | null
    unitPrice: number | null
    totalUnitPrice: number | null
    oosReportCount: number | null
  }

  export type OfferSumAggregateOutputType = {
    id: number | null
    retailerId: number | null
    price: number | null
    shippingCost: number | null
    total: number | null
    unitsCount: number | null
    unitPrice: number | null
    totalUnitPrice: number | null
    oosReportCount: number | null
  }

  export type OfferMinAggregateOutputType = {
    id: number | null
    itemId: string | null
    retailerId: number | null
    url: string | null
    inStock: boolean | null
    price: number | null
    currency: string | null
    shippingCost: number | null
    total: number | null
    freeShipping: boolean | null
    shippingNote: string | null
    shippingUpdatedAt: Date | null
    unitsCount: number | null
    unitLabel: string | null
    unitPrice: number | null
    totalUnitPrice: number | null
    retailerSku: string | null
    isManuallyOOS: boolean | null
    oosReportCount: number | null
    lastStockChange: Date | null
    lastSeen: Date | null
  }

  export type OfferMaxAggregateOutputType = {
    id: number | null
    itemId: string | null
    retailerId: number | null
    url: string | null
    inStock: boolean | null
    price: number | null
    currency: string | null
    shippingCost: number | null
    total: number | null
    freeShipping: boolean | null
    shippingNote: string | null
    shippingUpdatedAt: Date | null
    unitsCount: number | null
    unitLabel: string | null
    unitPrice: number | null
    totalUnitPrice: number | null
    retailerSku: string | null
    isManuallyOOS: boolean | null
    oosReportCount: number | null
    lastStockChange: Date | null
    lastSeen: Date | null
  }

  export type OfferCountAggregateOutputType = {
    id: number
    itemId: number
    retailerId: number
    url: number
    inStock: number
    price: number
    currency: number
    shippingCost: number
    total: number
    freeShipping: number
    shippingNote: number
    shippingUpdatedAt: number
    unitsCount: number
    unitLabel: number
    unitPrice: number
    totalUnitPrice: number
    retailerSku: number
    isManuallyOOS: number
    oosReportCount: number
    lastStockChange: number
    lastSeen: number
    _all: number
  }


  export type OfferAvgAggregateInputType = {
    id?: true
    retailerId?: true
    price?: true
    shippingCost?: true
    total?: true
    unitsCount?: true
    unitPrice?: true
    totalUnitPrice?: true
    oosReportCount?: true
  }

  export type OfferSumAggregateInputType = {
    id?: true
    retailerId?: true
    price?: true
    shippingCost?: true
    total?: true
    unitsCount?: true
    unitPrice?: true
    totalUnitPrice?: true
    oosReportCount?: true
  }

  export type OfferMinAggregateInputType = {
    id?: true
    itemId?: true
    retailerId?: true
    url?: true
    inStock?: true
    price?: true
    currency?: true
    shippingCost?: true
    total?: true
    freeShipping?: true
    shippingNote?: true
    shippingUpdatedAt?: true
    unitsCount?: true
    unitLabel?: true
    unitPrice?: true
    totalUnitPrice?: true
    retailerSku?: true
    isManuallyOOS?: true
    oosReportCount?: true
    lastStockChange?: true
    lastSeen?: true
  }

  export type OfferMaxAggregateInputType = {
    id?: true
    itemId?: true
    retailerId?: true
    url?: true
    inStock?: true
    price?: true
    currency?: true
    shippingCost?: true
    total?: true
    freeShipping?: true
    shippingNote?: true
    shippingUpdatedAt?: true
    unitsCount?: true
    unitLabel?: true
    unitPrice?: true
    totalUnitPrice?: true
    retailerSku?: true
    isManuallyOOS?: true
    oosReportCount?: true
    lastStockChange?: true
    lastSeen?: true
  }

  export type OfferCountAggregateInputType = {
    id?: true
    itemId?: true
    retailerId?: true
    url?: true
    inStock?: true
    price?: true
    currency?: true
    shippingCost?: true
    total?: true
    freeShipping?: true
    shippingNote?: true
    shippingUpdatedAt?: true
    unitsCount?: true
    unitLabel?: true
    unitPrice?: true
    totalUnitPrice?: true
    retailerSku?: true
    isManuallyOOS?: true
    oosReportCount?: true
    lastStockChange?: true
    lastSeen?: true
    _all?: true
  }

  export type OfferAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Offer to aggregate.
     */
    where?: OfferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Offers to fetch.
     */
    orderBy?: OfferOrderByWithRelationInput | OfferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OfferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Offers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Offers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Offers
    **/
    _count?: true | OfferCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OfferAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OfferSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OfferMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OfferMaxAggregateInputType
  }

  export type GetOfferAggregateType<T extends OfferAggregateArgs> = {
        [P in keyof T & keyof AggregateOffer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOffer[P]>
      : GetScalarType<T[P], AggregateOffer[P]>
  }




  export type OfferGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OfferWhereInput
    orderBy?: OfferOrderByWithAggregationInput | OfferOrderByWithAggregationInput[]
    by: OfferScalarFieldEnum[] | OfferScalarFieldEnum
    having?: OfferScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OfferCountAggregateInputType | true
    _avg?: OfferAvgAggregateInputType
    _sum?: OfferSumAggregateInputType
    _min?: OfferMinAggregateInputType
    _max?: OfferMaxAggregateInputType
  }

  export type OfferGroupByOutputType = {
    id: number
    itemId: string
    retailerId: number
    url: string
    inStock: boolean | null
    price: number
    currency: string | null
    shippingCost: number | null
    total: number | null
    freeShipping: boolean | null
    shippingNote: string | null
    shippingUpdatedAt: Date | null
    unitsCount: number | null
    unitLabel: string | null
    unitPrice: number | null
    totalUnitPrice: number | null
    retailerSku: string | null
    isManuallyOOS: boolean | null
    oosReportCount: number | null
    lastStockChange: Date | null
    lastSeen: Date | null
    _count: OfferCountAggregateOutputType | null
    _avg: OfferAvgAggregateOutputType | null
    _sum: OfferSumAggregateOutputType | null
    _min: OfferMinAggregateOutputType | null
    _max: OfferMaxAggregateOutputType | null
  }

  type GetOfferGroupByPayload<T extends OfferGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OfferGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OfferGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OfferGroupByOutputType[P]>
            : GetScalarType<T[P], OfferGroupByOutputType[P]>
        }
      >
    >


  export type OfferSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itemId?: boolean
    retailerId?: boolean
    url?: boolean
    inStock?: boolean
    price?: boolean
    currency?: boolean
    shippingCost?: boolean
    total?: boolean
    freeShipping?: boolean
    shippingNote?: boolean
    shippingUpdatedAt?: boolean
    unitsCount?: boolean
    unitLabel?: boolean
    unitPrice?: boolean
    totalUnitPrice?: boolean
    retailerSku?: boolean
    isManuallyOOS?: boolean
    oosReportCount?: boolean
    lastStockChange?: boolean
    lastSeen?: boolean
    AlertDelivery?: boolean | Offer$AlertDeliveryArgs<ExtArgs>
    CatalogItem?: boolean | CatalogItemDefaultArgs<ExtArgs>
    retailer?: boolean | RetailerDefaultArgs<ExtArgs>
    _count?: boolean | OfferCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["offer"]>

  export type OfferSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itemId?: boolean
    retailerId?: boolean
    url?: boolean
    inStock?: boolean
    price?: boolean
    currency?: boolean
    shippingCost?: boolean
    total?: boolean
    freeShipping?: boolean
    shippingNote?: boolean
    shippingUpdatedAt?: boolean
    unitsCount?: boolean
    unitLabel?: boolean
    unitPrice?: boolean
    totalUnitPrice?: boolean
    retailerSku?: boolean
    isManuallyOOS?: boolean
    oosReportCount?: boolean
    lastStockChange?: boolean
    lastSeen?: boolean
    CatalogItem?: boolean | CatalogItemDefaultArgs<ExtArgs>
    retailer?: boolean | RetailerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["offer"]>

  export type OfferSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itemId?: boolean
    retailerId?: boolean
    url?: boolean
    inStock?: boolean
    price?: boolean
    currency?: boolean
    shippingCost?: boolean
    total?: boolean
    freeShipping?: boolean
    shippingNote?: boolean
    shippingUpdatedAt?: boolean
    unitsCount?: boolean
    unitLabel?: boolean
    unitPrice?: boolean
    totalUnitPrice?: boolean
    retailerSku?: boolean
    isManuallyOOS?: boolean
    oosReportCount?: boolean
    lastStockChange?: boolean
    lastSeen?: boolean
    CatalogItem?: boolean | CatalogItemDefaultArgs<ExtArgs>
    retailer?: boolean | RetailerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["offer"]>

  export type OfferSelectScalar = {
    id?: boolean
    itemId?: boolean
    retailerId?: boolean
    url?: boolean
    inStock?: boolean
    price?: boolean
    currency?: boolean
    shippingCost?: boolean
    total?: boolean
    freeShipping?: boolean
    shippingNote?: boolean
    shippingUpdatedAt?: boolean
    unitsCount?: boolean
    unitLabel?: boolean
    unitPrice?: boolean
    totalUnitPrice?: boolean
    retailerSku?: boolean
    isManuallyOOS?: boolean
    oosReportCount?: boolean
    lastStockChange?: boolean
    lastSeen?: boolean
  }

  export type OfferOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "itemId" | "retailerId" | "url" | "inStock" | "price" | "currency" | "shippingCost" | "total" | "freeShipping" | "shippingNote" | "shippingUpdatedAt" | "unitsCount" | "unitLabel" | "unitPrice" | "totalUnitPrice" | "retailerSku" | "isManuallyOOS" | "oosReportCount" | "lastStockChange" | "lastSeen", ExtArgs["result"]["offer"]>
  export type OfferInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AlertDelivery?: boolean | Offer$AlertDeliveryArgs<ExtArgs>
    CatalogItem?: boolean | CatalogItemDefaultArgs<ExtArgs>
    retailer?: boolean | RetailerDefaultArgs<ExtArgs>
    _count?: boolean | OfferCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OfferIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CatalogItem?: boolean | CatalogItemDefaultArgs<ExtArgs>
    retailer?: boolean | RetailerDefaultArgs<ExtArgs>
  }
  export type OfferIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CatalogItem?: boolean | CatalogItemDefaultArgs<ExtArgs>
    retailer?: boolean | RetailerDefaultArgs<ExtArgs>
  }

  export type $OfferPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Offer"
    objects: {
      AlertDelivery: Prisma.$AlertDeliveryPayload<ExtArgs>[]
      CatalogItem: Prisma.$CatalogItemPayload<ExtArgs>
      retailer: Prisma.$RetailerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      itemId: string
      retailerId: number
      url: string
      inStock: boolean | null
      price: number
      currency: string | null
      shippingCost: number | null
      total: number | null
      freeShipping: boolean | null
      shippingNote: string | null
      shippingUpdatedAt: Date | null
      unitsCount: number | null
      unitLabel: string | null
      unitPrice: number | null
      totalUnitPrice: number | null
      retailerSku: string | null
      isManuallyOOS: boolean | null
      oosReportCount: number | null
      lastStockChange: Date | null
      lastSeen: Date | null
    }, ExtArgs["result"]["offer"]>
    composites: {}
  }

  type OfferGetPayload<S extends boolean | null | undefined | OfferDefaultArgs> = $Result.GetResult<Prisma.$OfferPayload, S>

  type OfferCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OfferFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OfferCountAggregateInputType | true
    }

  export interface OfferDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Offer'], meta: { name: 'Offer' } }
    /**
     * Find zero or one Offer that matches the filter.
     * @param {OfferFindUniqueArgs} args - Arguments to find a Offer
     * @example
     * // Get one Offer
     * const offer = await prisma.offer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OfferFindUniqueArgs>(args: SelectSubset<T, OfferFindUniqueArgs<ExtArgs>>): Prisma__OfferClient<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Offer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OfferFindUniqueOrThrowArgs} args - Arguments to find a Offer
     * @example
     * // Get one Offer
     * const offer = await prisma.offer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OfferFindUniqueOrThrowArgs>(args: SelectSubset<T, OfferFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OfferClient<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Offer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferFindFirstArgs} args - Arguments to find a Offer
     * @example
     * // Get one Offer
     * const offer = await prisma.offer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OfferFindFirstArgs>(args?: SelectSubset<T, OfferFindFirstArgs<ExtArgs>>): Prisma__OfferClient<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Offer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferFindFirstOrThrowArgs} args - Arguments to find a Offer
     * @example
     * // Get one Offer
     * const offer = await prisma.offer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OfferFindFirstOrThrowArgs>(args?: SelectSubset<T, OfferFindFirstOrThrowArgs<ExtArgs>>): Prisma__OfferClient<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Offers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Offers
     * const offers = await prisma.offer.findMany()
     * 
     * // Get first 10 Offers
     * const offers = await prisma.offer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const offerWithIdOnly = await prisma.offer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OfferFindManyArgs>(args?: SelectSubset<T, OfferFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Offer.
     * @param {OfferCreateArgs} args - Arguments to create a Offer.
     * @example
     * // Create one Offer
     * const Offer = await prisma.offer.create({
     *   data: {
     *     // ... data to create a Offer
     *   }
     * })
     * 
     */
    create<T extends OfferCreateArgs>(args: SelectSubset<T, OfferCreateArgs<ExtArgs>>): Prisma__OfferClient<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Offers.
     * @param {OfferCreateManyArgs} args - Arguments to create many Offers.
     * @example
     * // Create many Offers
     * const offer = await prisma.offer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OfferCreateManyArgs>(args?: SelectSubset<T, OfferCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Offers and returns the data saved in the database.
     * @param {OfferCreateManyAndReturnArgs} args - Arguments to create many Offers.
     * @example
     * // Create many Offers
     * const offer = await prisma.offer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Offers and only return the `id`
     * const offerWithIdOnly = await prisma.offer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OfferCreateManyAndReturnArgs>(args?: SelectSubset<T, OfferCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Offer.
     * @param {OfferDeleteArgs} args - Arguments to delete one Offer.
     * @example
     * // Delete one Offer
     * const Offer = await prisma.offer.delete({
     *   where: {
     *     // ... filter to delete one Offer
     *   }
     * })
     * 
     */
    delete<T extends OfferDeleteArgs>(args: SelectSubset<T, OfferDeleteArgs<ExtArgs>>): Prisma__OfferClient<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Offer.
     * @param {OfferUpdateArgs} args - Arguments to update one Offer.
     * @example
     * // Update one Offer
     * const offer = await prisma.offer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OfferUpdateArgs>(args: SelectSubset<T, OfferUpdateArgs<ExtArgs>>): Prisma__OfferClient<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Offers.
     * @param {OfferDeleteManyArgs} args - Arguments to filter Offers to delete.
     * @example
     * // Delete a few Offers
     * const { count } = await prisma.offer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OfferDeleteManyArgs>(args?: SelectSubset<T, OfferDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Offers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Offers
     * const offer = await prisma.offer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OfferUpdateManyArgs>(args: SelectSubset<T, OfferUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Offers and returns the data updated in the database.
     * @param {OfferUpdateManyAndReturnArgs} args - Arguments to update many Offers.
     * @example
     * // Update many Offers
     * const offer = await prisma.offer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Offers and only return the `id`
     * const offerWithIdOnly = await prisma.offer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OfferUpdateManyAndReturnArgs>(args: SelectSubset<T, OfferUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Offer.
     * @param {OfferUpsertArgs} args - Arguments to update or create a Offer.
     * @example
     * // Update or create a Offer
     * const offer = await prisma.offer.upsert({
     *   create: {
     *     // ... data to create a Offer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Offer we want to update
     *   }
     * })
     */
    upsert<T extends OfferUpsertArgs>(args: SelectSubset<T, OfferUpsertArgs<ExtArgs>>): Prisma__OfferClient<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Offers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferCountArgs} args - Arguments to filter Offers to count.
     * @example
     * // Count the number of Offers
     * const count = await prisma.offer.count({
     *   where: {
     *     // ... the filter for the Offers we want to count
     *   }
     * })
    **/
    count<T extends OfferCountArgs>(
      args?: Subset<T, OfferCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OfferCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Offer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OfferAggregateArgs>(args: Subset<T, OfferAggregateArgs>): Prisma.PrismaPromise<GetOfferAggregateType<T>>

    /**
     * Group by Offer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OfferGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OfferGroupByArgs['orderBy'] }
        : { orderBy?: OfferGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OfferGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOfferGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Offer model
   */
  readonly fields: OfferFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Offer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OfferClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    AlertDelivery<T extends Offer$AlertDeliveryArgs<ExtArgs> = {}>(args?: Subset<T, Offer$AlertDeliveryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertDeliveryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    CatalogItem<T extends CatalogItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CatalogItemDefaultArgs<ExtArgs>>): Prisma__CatalogItemClient<$Result.GetResult<Prisma.$CatalogItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    retailer<T extends RetailerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RetailerDefaultArgs<ExtArgs>>): Prisma__RetailerClient<$Result.GetResult<Prisma.$RetailerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Offer model
   */
  interface OfferFieldRefs {
    readonly id: FieldRef<"Offer", 'Int'>
    readonly itemId: FieldRef<"Offer", 'String'>
    readonly retailerId: FieldRef<"Offer", 'Int'>
    readonly url: FieldRef<"Offer", 'String'>
    readonly inStock: FieldRef<"Offer", 'Boolean'>
    readonly price: FieldRef<"Offer", 'Float'>
    readonly currency: FieldRef<"Offer", 'String'>
    readonly shippingCost: FieldRef<"Offer", 'Float'>
    readonly total: FieldRef<"Offer", 'Float'>
    readonly freeShipping: FieldRef<"Offer", 'Boolean'>
    readonly shippingNote: FieldRef<"Offer", 'String'>
    readonly shippingUpdatedAt: FieldRef<"Offer", 'DateTime'>
    readonly unitsCount: FieldRef<"Offer", 'Int'>
    readonly unitLabel: FieldRef<"Offer", 'String'>
    readonly unitPrice: FieldRef<"Offer", 'Float'>
    readonly totalUnitPrice: FieldRef<"Offer", 'Float'>
    readonly retailerSku: FieldRef<"Offer", 'String'>
    readonly isManuallyOOS: FieldRef<"Offer", 'Boolean'>
    readonly oosReportCount: FieldRef<"Offer", 'Int'>
    readonly lastStockChange: FieldRef<"Offer", 'DateTime'>
    readonly lastSeen: FieldRef<"Offer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Offer findUnique
   */
  export type OfferFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Offer
     */
    omit?: OfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    /**
     * Filter, which Offer to fetch.
     */
    where: OfferWhereUniqueInput
  }

  /**
   * Offer findUniqueOrThrow
   */
  export type OfferFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Offer
     */
    omit?: OfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    /**
     * Filter, which Offer to fetch.
     */
    where: OfferWhereUniqueInput
  }

  /**
   * Offer findFirst
   */
  export type OfferFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Offer
     */
    omit?: OfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    /**
     * Filter, which Offer to fetch.
     */
    where?: OfferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Offers to fetch.
     */
    orderBy?: OfferOrderByWithRelationInput | OfferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Offers.
     */
    cursor?: OfferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Offers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Offers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Offers.
     */
    distinct?: OfferScalarFieldEnum | OfferScalarFieldEnum[]
  }

  /**
   * Offer findFirstOrThrow
   */
  export type OfferFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Offer
     */
    omit?: OfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    /**
     * Filter, which Offer to fetch.
     */
    where?: OfferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Offers to fetch.
     */
    orderBy?: OfferOrderByWithRelationInput | OfferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Offers.
     */
    cursor?: OfferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Offers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Offers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Offers.
     */
    distinct?: OfferScalarFieldEnum | OfferScalarFieldEnum[]
  }

  /**
   * Offer findMany
   */
  export type OfferFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Offer
     */
    omit?: OfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    /**
     * Filter, which Offers to fetch.
     */
    where?: OfferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Offers to fetch.
     */
    orderBy?: OfferOrderByWithRelationInput | OfferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Offers.
     */
    cursor?: OfferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Offers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Offers.
     */
    skip?: number
    distinct?: OfferScalarFieldEnum | OfferScalarFieldEnum[]
  }

  /**
   * Offer create
   */
  export type OfferCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Offer
     */
    omit?: OfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    /**
     * The data needed to create a Offer.
     */
    data: XOR<OfferCreateInput, OfferUncheckedCreateInput>
  }

  /**
   * Offer createMany
   */
  export type OfferCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Offers.
     */
    data: OfferCreateManyInput | OfferCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Offer createManyAndReturn
   */
  export type OfferCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Offer
     */
    omit?: OfferOmit<ExtArgs> | null
    /**
     * The data used to create many Offers.
     */
    data: OfferCreateManyInput | OfferCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Offer update
   */
  export type OfferUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Offer
     */
    omit?: OfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    /**
     * The data needed to update a Offer.
     */
    data: XOR<OfferUpdateInput, OfferUncheckedUpdateInput>
    /**
     * Choose, which Offer to update.
     */
    where: OfferWhereUniqueInput
  }

  /**
   * Offer updateMany
   */
  export type OfferUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Offers.
     */
    data: XOR<OfferUpdateManyMutationInput, OfferUncheckedUpdateManyInput>
    /**
     * Filter which Offers to update
     */
    where?: OfferWhereInput
    /**
     * Limit how many Offers to update.
     */
    limit?: number
  }

  /**
   * Offer updateManyAndReturn
   */
  export type OfferUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Offer
     */
    omit?: OfferOmit<ExtArgs> | null
    /**
     * The data used to update Offers.
     */
    data: XOR<OfferUpdateManyMutationInput, OfferUncheckedUpdateManyInput>
    /**
     * Filter which Offers to update
     */
    where?: OfferWhereInput
    /**
     * Limit how many Offers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Offer upsert
   */
  export type OfferUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Offer
     */
    omit?: OfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    /**
     * The filter to search for the Offer to update in case it exists.
     */
    where: OfferWhereUniqueInput
    /**
     * In case the Offer found by the `where` argument doesn't exist, create a new Offer with this data.
     */
    create: XOR<OfferCreateInput, OfferUncheckedCreateInput>
    /**
     * In case the Offer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OfferUpdateInput, OfferUncheckedUpdateInput>
  }

  /**
   * Offer delete
   */
  export type OfferDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Offer
     */
    omit?: OfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    /**
     * Filter which Offer to delete.
     */
    where: OfferWhereUniqueInput
  }

  /**
   * Offer deleteMany
   */
  export type OfferDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Offers to delete
     */
    where?: OfferWhereInput
    /**
     * Limit how many Offers to delete.
     */
    limit?: number
  }

  /**
   * Offer.AlertDelivery
   */
  export type Offer$AlertDeliveryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertDelivery
     */
    select?: AlertDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlertDelivery
     */
    omit?: AlertDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertDeliveryInclude<ExtArgs> | null
    where?: AlertDeliveryWhereInput
    orderBy?: AlertDeliveryOrderByWithRelationInput | AlertDeliveryOrderByWithRelationInput[]
    cursor?: AlertDeliveryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AlertDeliveryScalarFieldEnum | AlertDeliveryScalarFieldEnum[]
  }

  /**
   * Offer without action
   */
  export type OfferDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Offer
     */
    omit?: OfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
  }


  /**
   * Model Retailer
   */

  export type AggregateRetailer = {
    _count: RetailerCountAggregateOutputType | null
    _avg: RetailerAvgAggregateOutputType | null
    _sum: RetailerSumAggregateOutputType | null
    _min: RetailerMinAggregateOutputType | null
    _max: RetailerMaxAggregateOutputType | null
  }

  export type RetailerAvgAggregateOutputType = {
    id: number | null
    rating: number | null
    shippingRating: number | null
  }

  export type RetailerSumAggregateOutputType = {
    id: number | null
    rating: number | null
    shippingRating: number | null
  }

  export type RetailerMinAggregateOutputType = {
    id: number | null
    name: string | null
    domain: string | null
    logo: string | null
    rating: number | null
    shippingRating: number | null
  }

  export type RetailerMaxAggregateOutputType = {
    id: number | null
    name: string | null
    domain: string | null
    logo: string | null
    rating: number | null
    shippingRating: number | null
  }

  export type RetailerCountAggregateOutputType = {
    id: number
    name: number
    domain: number
    logo: number
    rating: number
    shippingRating: number
    _all: number
  }


  export type RetailerAvgAggregateInputType = {
    id?: true
    rating?: true
    shippingRating?: true
  }

  export type RetailerSumAggregateInputType = {
    id?: true
    rating?: true
    shippingRating?: true
  }

  export type RetailerMinAggregateInputType = {
    id?: true
    name?: true
    domain?: true
    logo?: true
    rating?: true
    shippingRating?: true
  }

  export type RetailerMaxAggregateInputType = {
    id?: true
    name?: true
    domain?: true
    logo?: true
    rating?: true
    shippingRating?: true
  }

  export type RetailerCountAggregateInputType = {
    id?: true
    name?: true
    domain?: true
    logo?: true
    rating?: true
    shippingRating?: true
    _all?: true
  }

  export type RetailerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Retailer to aggregate.
     */
    where?: RetailerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Retailers to fetch.
     */
    orderBy?: RetailerOrderByWithRelationInput | RetailerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RetailerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Retailers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Retailers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Retailers
    **/
    _count?: true | RetailerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RetailerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RetailerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RetailerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RetailerMaxAggregateInputType
  }

  export type GetRetailerAggregateType<T extends RetailerAggregateArgs> = {
        [P in keyof T & keyof AggregateRetailer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRetailer[P]>
      : GetScalarType<T[P], AggregateRetailer[P]>
  }




  export type RetailerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RetailerWhereInput
    orderBy?: RetailerOrderByWithAggregationInput | RetailerOrderByWithAggregationInput[]
    by: RetailerScalarFieldEnum[] | RetailerScalarFieldEnum
    having?: RetailerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RetailerCountAggregateInputType | true
    _avg?: RetailerAvgAggregateInputType
    _sum?: RetailerSumAggregateInputType
    _min?: RetailerMinAggregateInputType
    _max?: RetailerMaxAggregateInputType
  }

  export type RetailerGroupByOutputType = {
    id: number
    name: string
    domain: string | null
    logo: string | null
    rating: number | null
    shippingRating: number | null
    _count: RetailerCountAggregateOutputType | null
    _avg: RetailerAvgAggregateOutputType | null
    _sum: RetailerSumAggregateOutputType | null
    _min: RetailerMinAggregateOutputType | null
    _max: RetailerMaxAggregateOutputType | null
  }

  type GetRetailerGroupByPayload<T extends RetailerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RetailerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RetailerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RetailerGroupByOutputType[P]>
            : GetScalarType<T[P], RetailerGroupByOutputType[P]>
        }
      >
    >


  export type RetailerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    domain?: boolean
    logo?: boolean
    rating?: boolean
    shippingRating?: boolean
    BlockedRetailer?: boolean | Retailer$BlockedRetailerArgs<ExtArgs>
    offers?: boolean | Retailer$offersArgs<ExtArgs>
    _count?: boolean | RetailerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["retailer"]>

  export type RetailerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    domain?: boolean
    logo?: boolean
    rating?: boolean
    shippingRating?: boolean
  }, ExtArgs["result"]["retailer"]>

  export type RetailerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    domain?: boolean
    logo?: boolean
    rating?: boolean
    shippingRating?: boolean
  }, ExtArgs["result"]["retailer"]>

  export type RetailerSelectScalar = {
    id?: boolean
    name?: boolean
    domain?: boolean
    logo?: boolean
    rating?: boolean
    shippingRating?: boolean
  }

  export type RetailerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "domain" | "logo" | "rating" | "shippingRating", ExtArgs["result"]["retailer"]>
  export type RetailerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BlockedRetailer?: boolean | Retailer$BlockedRetailerArgs<ExtArgs>
    offers?: boolean | Retailer$offersArgs<ExtArgs>
    _count?: boolean | RetailerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RetailerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type RetailerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RetailerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Retailer"
    objects: {
      BlockedRetailer: Prisma.$BlockedRetailerPayload<ExtArgs>[]
      offers: Prisma.$OfferPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      domain: string | null
      logo: string | null
      rating: number | null
      shippingRating: number | null
    }, ExtArgs["result"]["retailer"]>
    composites: {}
  }

  type RetailerGetPayload<S extends boolean | null | undefined | RetailerDefaultArgs> = $Result.GetResult<Prisma.$RetailerPayload, S>

  type RetailerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RetailerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RetailerCountAggregateInputType | true
    }

  export interface RetailerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Retailer'], meta: { name: 'Retailer' } }
    /**
     * Find zero or one Retailer that matches the filter.
     * @param {RetailerFindUniqueArgs} args - Arguments to find a Retailer
     * @example
     * // Get one Retailer
     * const retailer = await prisma.retailer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RetailerFindUniqueArgs>(args: SelectSubset<T, RetailerFindUniqueArgs<ExtArgs>>): Prisma__RetailerClient<$Result.GetResult<Prisma.$RetailerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Retailer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RetailerFindUniqueOrThrowArgs} args - Arguments to find a Retailer
     * @example
     * // Get one Retailer
     * const retailer = await prisma.retailer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RetailerFindUniqueOrThrowArgs>(args: SelectSubset<T, RetailerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RetailerClient<$Result.GetResult<Prisma.$RetailerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Retailer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RetailerFindFirstArgs} args - Arguments to find a Retailer
     * @example
     * // Get one Retailer
     * const retailer = await prisma.retailer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RetailerFindFirstArgs>(args?: SelectSubset<T, RetailerFindFirstArgs<ExtArgs>>): Prisma__RetailerClient<$Result.GetResult<Prisma.$RetailerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Retailer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RetailerFindFirstOrThrowArgs} args - Arguments to find a Retailer
     * @example
     * // Get one Retailer
     * const retailer = await prisma.retailer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RetailerFindFirstOrThrowArgs>(args?: SelectSubset<T, RetailerFindFirstOrThrowArgs<ExtArgs>>): Prisma__RetailerClient<$Result.GetResult<Prisma.$RetailerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Retailers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RetailerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Retailers
     * const retailers = await prisma.retailer.findMany()
     * 
     * // Get first 10 Retailers
     * const retailers = await prisma.retailer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const retailerWithIdOnly = await prisma.retailer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RetailerFindManyArgs>(args?: SelectSubset<T, RetailerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RetailerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Retailer.
     * @param {RetailerCreateArgs} args - Arguments to create a Retailer.
     * @example
     * // Create one Retailer
     * const Retailer = await prisma.retailer.create({
     *   data: {
     *     // ... data to create a Retailer
     *   }
     * })
     * 
     */
    create<T extends RetailerCreateArgs>(args: SelectSubset<T, RetailerCreateArgs<ExtArgs>>): Prisma__RetailerClient<$Result.GetResult<Prisma.$RetailerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Retailers.
     * @param {RetailerCreateManyArgs} args - Arguments to create many Retailers.
     * @example
     * // Create many Retailers
     * const retailer = await prisma.retailer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RetailerCreateManyArgs>(args?: SelectSubset<T, RetailerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Retailers and returns the data saved in the database.
     * @param {RetailerCreateManyAndReturnArgs} args - Arguments to create many Retailers.
     * @example
     * // Create many Retailers
     * const retailer = await prisma.retailer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Retailers and only return the `id`
     * const retailerWithIdOnly = await prisma.retailer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RetailerCreateManyAndReturnArgs>(args?: SelectSubset<T, RetailerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RetailerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Retailer.
     * @param {RetailerDeleteArgs} args - Arguments to delete one Retailer.
     * @example
     * // Delete one Retailer
     * const Retailer = await prisma.retailer.delete({
     *   where: {
     *     // ... filter to delete one Retailer
     *   }
     * })
     * 
     */
    delete<T extends RetailerDeleteArgs>(args: SelectSubset<T, RetailerDeleteArgs<ExtArgs>>): Prisma__RetailerClient<$Result.GetResult<Prisma.$RetailerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Retailer.
     * @param {RetailerUpdateArgs} args - Arguments to update one Retailer.
     * @example
     * // Update one Retailer
     * const retailer = await prisma.retailer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RetailerUpdateArgs>(args: SelectSubset<T, RetailerUpdateArgs<ExtArgs>>): Prisma__RetailerClient<$Result.GetResult<Prisma.$RetailerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Retailers.
     * @param {RetailerDeleteManyArgs} args - Arguments to filter Retailers to delete.
     * @example
     * // Delete a few Retailers
     * const { count } = await prisma.retailer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RetailerDeleteManyArgs>(args?: SelectSubset<T, RetailerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Retailers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RetailerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Retailers
     * const retailer = await prisma.retailer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RetailerUpdateManyArgs>(args: SelectSubset<T, RetailerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Retailers and returns the data updated in the database.
     * @param {RetailerUpdateManyAndReturnArgs} args - Arguments to update many Retailers.
     * @example
     * // Update many Retailers
     * const retailer = await prisma.retailer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Retailers and only return the `id`
     * const retailerWithIdOnly = await prisma.retailer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RetailerUpdateManyAndReturnArgs>(args: SelectSubset<T, RetailerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RetailerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Retailer.
     * @param {RetailerUpsertArgs} args - Arguments to update or create a Retailer.
     * @example
     * // Update or create a Retailer
     * const retailer = await prisma.retailer.upsert({
     *   create: {
     *     // ... data to create a Retailer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Retailer we want to update
     *   }
     * })
     */
    upsert<T extends RetailerUpsertArgs>(args: SelectSubset<T, RetailerUpsertArgs<ExtArgs>>): Prisma__RetailerClient<$Result.GetResult<Prisma.$RetailerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Retailers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RetailerCountArgs} args - Arguments to filter Retailers to count.
     * @example
     * // Count the number of Retailers
     * const count = await prisma.retailer.count({
     *   where: {
     *     // ... the filter for the Retailers we want to count
     *   }
     * })
    **/
    count<T extends RetailerCountArgs>(
      args?: Subset<T, RetailerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RetailerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Retailer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RetailerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RetailerAggregateArgs>(args: Subset<T, RetailerAggregateArgs>): Prisma.PrismaPromise<GetRetailerAggregateType<T>>

    /**
     * Group by Retailer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RetailerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RetailerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RetailerGroupByArgs['orderBy'] }
        : { orderBy?: RetailerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RetailerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRetailerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Retailer model
   */
  readonly fields: RetailerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Retailer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RetailerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    BlockedRetailer<T extends Retailer$BlockedRetailerArgs<ExtArgs> = {}>(args?: Subset<T, Retailer$BlockedRetailerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockedRetailerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    offers<T extends Retailer$offersArgs<ExtArgs> = {}>(args?: Subset<T, Retailer$offersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Retailer model
   */
  interface RetailerFieldRefs {
    readonly id: FieldRef<"Retailer", 'Int'>
    readonly name: FieldRef<"Retailer", 'String'>
    readonly domain: FieldRef<"Retailer", 'String'>
    readonly logo: FieldRef<"Retailer", 'String'>
    readonly rating: FieldRef<"Retailer", 'Float'>
    readonly shippingRating: FieldRef<"Retailer", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Retailer findUnique
   */
  export type RetailerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Retailer
     */
    select?: RetailerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Retailer
     */
    omit?: RetailerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RetailerInclude<ExtArgs> | null
    /**
     * Filter, which Retailer to fetch.
     */
    where: RetailerWhereUniqueInput
  }

  /**
   * Retailer findUniqueOrThrow
   */
  export type RetailerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Retailer
     */
    select?: RetailerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Retailer
     */
    omit?: RetailerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RetailerInclude<ExtArgs> | null
    /**
     * Filter, which Retailer to fetch.
     */
    where: RetailerWhereUniqueInput
  }

  /**
   * Retailer findFirst
   */
  export type RetailerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Retailer
     */
    select?: RetailerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Retailer
     */
    omit?: RetailerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RetailerInclude<ExtArgs> | null
    /**
     * Filter, which Retailer to fetch.
     */
    where?: RetailerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Retailers to fetch.
     */
    orderBy?: RetailerOrderByWithRelationInput | RetailerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Retailers.
     */
    cursor?: RetailerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Retailers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Retailers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Retailers.
     */
    distinct?: RetailerScalarFieldEnum | RetailerScalarFieldEnum[]
  }

  /**
   * Retailer findFirstOrThrow
   */
  export type RetailerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Retailer
     */
    select?: RetailerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Retailer
     */
    omit?: RetailerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RetailerInclude<ExtArgs> | null
    /**
     * Filter, which Retailer to fetch.
     */
    where?: RetailerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Retailers to fetch.
     */
    orderBy?: RetailerOrderByWithRelationInput | RetailerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Retailers.
     */
    cursor?: RetailerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Retailers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Retailers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Retailers.
     */
    distinct?: RetailerScalarFieldEnum | RetailerScalarFieldEnum[]
  }

  /**
   * Retailer findMany
   */
  export type RetailerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Retailer
     */
    select?: RetailerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Retailer
     */
    omit?: RetailerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RetailerInclude<ExtArgs> | null
    /**
     * Filter, which Retailers to fetch.
     */
    where?: RetailerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Retailers to fetch.
     */
    orderBy?: RetailerOrderByWithRelationInput | RetailerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Retailers.
     */
    cursor?: RetailerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Retailers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Retailers.
     */
    skip?: number
    distinct?: RetailerScalarFieldEnum | RetailerScalarFieldEnum[]
  }

  /**
   * Retailer create
   */
  export type RetailerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Retailer
     */
    select?: RetailerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Retailer
     */
    omit?: RetailerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RetailerInclude<ExtArgs> | null
    /**
     * The data needed to create a Retailer.
     */
    data: XOR<RetailerCreateInput, RetailerUncheckedCreateInput>
  }

  /**
   * Retailer createMany
   */
  export type RetailerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Retailers.
     */
    data: RetailerCreateManyInput | RetailerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Retailer createManyAndReturn
   */
  export type RetailerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Retailer
     */
    select?: RetailerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Retailer
     */
    omit?: RetailerOmit<ExtArgs> | null
    /**
     * The data used to create many Retailers.
     */
    data: RetailerCreateManyInput | RetailerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Retailer update
   */
  export type RetailerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Retailer
     */
    select?: RetailerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Retailer
     */
    omit?: RetailerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RetailerInclude<ExtArgs> | null
    /**
     * The data needed to update a Retailer.
     */
    data: XOR<RetailerUpdateInput, RetailerUncheckedUpdateInput>
    /**
     * Choose, which Retailer to update.
     */
    where: RetailerWhereUniqueInput
  }

  /**
   * Retailer updateMany
   */
  export type RetailerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Retailers.
     */
    data: XOR<RetailerUpdateManyMutationInput, RetailerUncheckedUpdateManyInput>
    /**
     * Filter which Retailers to update
     */
    where?: RetailerWhereInput
    /**
     * Limit how many Retailers to update.
     */
    limit?: number
  }

  /**
   * Retailer updateManyAndReturn
   */
  export type RetailerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Retailer
     */
    select?: RetailerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Retailer
     */
    omit?: RetailerOmit<ExtArgs> | null
    /**
     * The data used to update Retailers.
     */
    data: XOR<RetailerUpdateManyMutationInput, RetailerUncheckedUpdateManyInput>
    /**
     * Filter which Retailers to update
     */
    where?: RetailerWhereInput
    /**
     * Limit how many Retailers to update.
     */
    limit?: number
  }

  /**
   * Retailer upsert
   */
  export type RetailerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Retailer
     */
    select?: RetailerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Retailer
     */
    omit?: RetailerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RetailerInclude<ExtArgs> | null
    /**
     * The filter to search for the Retailer to update in case it exists.
     */
    where: RetailerWhereUniqueInput
    /**
     * In case the Retailer found by the `where` argument doesn't exist, create a new Retailer with this data.
     */
    create: XOR<RetailerCreateInput, RetailerUncheckedCreateInput>
    /**
     * In case the Retailer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RetailerUpdateInput, RetailerUncheckedUpdateInput>
  }

  /**
   * Retailer delete
   */
  export type RetailerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Retailer
     */
    select?: RetailerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Retailer
     */
    omit?: RetailerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RetailerInclude<ExtArgs> | null
    /**
     * Filter which Retailer to delete.
     */
    where: RetailerWhereUniqueInput
  }

  /**
   * Retailer deleteMany
   */
  export type RetailerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Retailers to delete
     */
    where?: RetailerWhereInput
    /**
     * Limit how many Retailers to delete.
     */
    limit?: number
  }

  /**
   * Retailer.BlockedRetailer
   */
  export type Retailer$BlockedRetailerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedRetailer
     */
    select?: BlockedRetailerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlockedRetailer
     */
    omit?: BlockedRetailerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockedRetailerInclude<ExtArgs> | null
    where?: BlockedRetailerWhereInput
    orderBy?: BlockedRetailerOrderByWithRelationInput | BlockedRetailerOrderByWithRelationInput[]
    cursor?: BlockedRetailerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlockedRetailerScalarFieldEnum | BlockedRetailerScalarFieldEnum[]
  }

  /**
   * Retailer.offers
   */
  export type Retailer$offersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Offer
     */
    omit?: OfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    where?: OfferWhereInput
    orderBy?: OfferOrderByWithRelationInput | OfferOrderByWithRelationInput[]
    cursor?: OfferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OfferScalarFieldEnum | OfferScalarFieldEnum[]
  }

  /**
   * Retailer without action
   */
  export type RetailerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Retailer
     */
    select?: RetailerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Retailer
     */
    omit?: RetailerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RetailerInclude<ExtArgs> | null
  }


  /**
   * Model AccessoryFitment
   */

  export type AggregateAccessoryFitment = {
    _count: AccessoryFitmentCountAggregateOutputType | null
    _avg: AccessoryFitmentAvgAggregateOutputType | null
    _sum: AccessoryFitmentSumAggregateOutputType | null
    _min: AccessoryFitmentMinAggregateOutputType | null
    _max: AccessoryFitmentMaxAggregateOutputType | null
  }

  export type AccessoryFitmentAvgAggregateOutputType = {
    id: number | null
    accessorySpecsId: number | null
  }

  export type AccessoryFitmentSumAggregateOutputType = {
    id: number | null
    accessorySpecsId: number | null
  }

  export type AccessoryFitmentMinAggregateOutputType = {
    id: number | null
    accessorySpecsId: number | null
    fitmentType: $Enums.FitmentType | null
    firearmItemId: string | null
    platform: string | null
    note: string | null
  }

  export type AccessoryFitmentMaxAggregateOutputType = {
    id: number | null
    accessorySpecsId: number | null
    fitmentType: $Enums.FitmentType | null
    firearmItemId: string | null
    platform: string | null
    note: string | null
  }

  export type AccessoryFitmentCountAggregateOutputType = {
    id: number
    accessorySpecsId: number
    fitmentType: number
    firearmItemId: number
    platform: number
    note: number
    _all: number
  }


  export type AccessoryFitmentAvgAggregateInputType = {
    id?: true
    accessorySpecsId?: true
  }

  export type AccessoryFitmentSumAggregateInputType = {
    id?: true
    accessorySpecsId?: true
  }

  export type AccessoryFitmentMinAggregateInputType = {
    id?: true
    accessorySpecsId?: true
    fitmentType?: true
    firearmItemId?: true
    platform?: true
    note?: true
  }

  export type AccessoryFitmentMaxAggregateInputType = {
    id?: true
    accessorySpecsId?: true
    fitmentType?: true
    firearmItemId?: true
    platform?: true
    note?: true
  }

  export type AccessoryFitmentCountAggregateInputType = {
    id?: true
    accessorySpecsId?: true
    fitmentType?: true
    firearmItemId?: true
    platform?: true
    note?: true
    _all?: true
  }

  export type AccessoryFitmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccessoryFitment to aggregate.
     */
    where?: AccessoryFitmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccessoryFitments to fetch.
     */
    orderBy?: AccessoryFitmentOrderByWithRelationInput | AccessoryFitmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccessoryFitmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccessoryFitments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccessoryFitments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AccessoryFitments
    **/
    _count?: true | AccessoryFitmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccessoryFitmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccessoryFitmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccessoryFitmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccessoryFitmentMaxAggregateInputType
  }

  export type GetAccessoryFitmentAggregateType<T extends AccessoryFitmentAggregateArgs> = {
        [P in keyof T & keyof AggregateAccessoryFitment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccessoryFitment[P]>
      : GetScalarType<T[P], AggregateAccessoryFitment[P]>
  }




  export type AccessoryFitmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccessoryFitmentWhereInput
    orderBy?: AccessoryFitmentOrderByWithAggregationInput | AccessoryFitmentOrderByWithAggregationInput[]
    by: AccessoryFitmentScalarFieldEnum[] | AccessoryFitmentScalarFieldEnum
    having?: AccessoryFitmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccessoryFitmentCountAggregateInputType | true
    _avg?: AccessoryFitmentAvgAggregateInputType
    _sum?: AccessoryFitmentSumAggregateInputType
    _min?: AccessoryFitmentMinAggregateInputType
    _max?: AccessoryFitmentMaxAggregateInputType
  }

  export type AccessoryFitmentGroupByOutputType = {
    id: number
    accessorySpecsId: number
    fitmentType: $Enums.FitmentType
    firearmItemId: string | null
    platform: string | null
    note: string | null
    _count: AccessoryFitmentCountAggregateOutputType | null
    _avg: AccessoryFitmentAvgAggregateOutputType | null
    _sum: AccessoryFitmentSumAggregateOutputType | null
    _min: AccessoryFitmentMinAggregateOutputType | null
    _max: AccessoryFitmentMaxAggregateOutputType | null
  }

  type GetAccessoryFitmentGroupByPayload<T extends AccessoryFitmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccessoryFitmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccessoryFitmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccessoryFitmentGroupByOutputType[P]>
            : GetScalarType<T[P], AccessoryFitmentGroupByOutputType[P]>
        }
      >
    >


  export type AccessoryFitmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accessorySpecsId?: boolean
    fitmentType?: boolean
    firearmItemId?: boolean
    platform?: boolean
    note?: boolean
    AccessorySpecs?: boolean | AccessorySpecsDefaultArgs<ExtArgs>
    CatalogItem?: boolean | AccessoryFitment$CatalogItemArgs<ExtArgs>
  }, ExtArgs["result"]["accessoryFitment"]>

  export type AccessoryFitmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accessorySpecsId?: boolean
    fitmentType?: boolean
    firearmItemId?: boolean
    platform?: boolean
    note?: boolean
    AccessorySpecs?: boolean | AccessorySpecsDefaultArgs<ExtArgs>
    CatalogItem?: boolean | AccessoryFitment$CatalogItemArgs<ExtArgs>
  }, ExtArgs["result"]["accessoryFitment"]>

  export type AccessoryFitmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accessorySpecsId?: boolean
    fitmentType?: boolean
    firearmItemId?: boolean
    platform?: boolean
    note?: boolean
    AccessorySpecs?: boolean | AccessorySpecsDefaultArgs<ExtArgs>
    CatalogItem?: boolean | AccessoryFitment$CatalogItemArgs<ExtArgs>
  }, ExtArgs["result"]["accessoryFitment"]>

  export type AccessoryFitmentSelectScalar = {
    id?: boolean
    accessorySpecsId?: boolean
    fitmentType?: boolean
    firearmItemId?: boolean
    platform?: boolean
    note?: boolean
  }

  export type AccessoryFitmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "accessorySpecsId" | "fitmentType" | "firearmItemId" | "platform" | "note", ExtArgs["result"]["accessoryFitment"]>
  export type AccessoryFitmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AccessorySpecs?: boolean | AccessorySpecsDefaultArgs<ExtArgs>
    CatalogItem?: boolean | AccessoryFitment$CatalogItemArgs<ExtArgs>
  }
  export type AccessoryFitmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AccessorySpecs?: boolean | AccessorySpecsDefaultArgs<ExtArgs>
    CatalogItem?: boolean | AccessoryFitment$CatalogItemArgs<ExtArgs>
  }
  export type AccessoryFitmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AccessorySpecs?: boolean | AccessorySpecsDefaultArgs<ExtArgs>
    CatalogItem?: boolean | AccessoryFitment$CatalogItemArgs<ExtArgs>
  }

  export type $AccessoryFitmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AccessoryFitment"
    objects: {
      AccessorySpecs: Prisma.$AccessorySpecsPayload<ExtArgs>
      CatalogItem: Prisma.$CatalogItemPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      accessorySpecsId: number
      fitmentType: $Enums.FitmentType
      firearmItemId: string | null
      platform: string | null
      note: string | null
    }, ExtArgs["result"]["accessoryFitment"]>
    composites: {}
  }

  type AccessoryFitmentGetPayload<S extends boolean | null | undefined | AccessoryFitmentDefaultArgs> = $Result.GetResult<Prisma.$AccessoryFitmentPayload, S>

  type AccessoryFitmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccessoryFitmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccessoryFitmentCountAggregateInputType | true
    }

  export interface AccessoryFitmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AccessoryFitment'], meta: { name: 'AccessoryFitment' } }
    /**
     * Find zero or one AccessoryFitment that matches the filter.
     * @param {AccessoryFitmentFindUniqueArgs} args - Arguments to find a AccessoryFitment
     * @example
     * // Get one AccessoryFitment
     * const accessoryFitment = await prisma.accessoryFitment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccessoryFitmentFindUniqueArgs>(args: SelectSubset<T, AccessoryFitmentFindUniqueArgs<ExtArgs>>): Prisma__AccessoryFitmentClient<$Result.GetResult<Prisma.$AccessoryFitmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AccessoryFitment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccessoryFitmentFindUniqueOrThrowArgs} args - Arguments to find a AccessoryFitment
     * @example
     * // Get one AccessoryFitment
     * const accessoryFitment = await prisma.accessoryFitment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccessoryFitmentFindUniqueOrThrowArgs>(args: SelectSubset<T, AccessoryFitmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccessoryFitmentClient<$Result.GetResult<Prisma.$AccessoryFitmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AccessoryFitment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessoryFitmentFindFirstArgs} args - Arguments to find a AccessoryFitment
     * @example
     * // Get one AccessoryFitment
     * const accessoryFitment = await prisma.accessoryFitment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccessoryFitmentFindFirstArgs>(args?: SelectSubset<T, AccessoryFitmentFindFirstArgs<ExtArgs>>): Prisma__AccessoryFitmentClient<$Result.GetResult<Prisma.$AccessoryFitmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AccessoryFitment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessoryFitmentFindFirstOrThrowArgs} args - Arguments to find a AccessoryFitment
     * @example
     * // Get one AccessoryFitment
     * const accessoryFitment = await prisma.accessoryFitment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccessoryFitmentFindFirstOrThrowArgs>(args?: SelectSubset<T, AccessoryFitmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccessoryFitmentClient<$Result.GetResult<Prisma.$AccessoryFitmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AccessoryFitments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessoryFitmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AccessoryFitments
     * const accessoryFitments = await prisma.accessoryFitment.findMany()
     * 
     * // Get first 10 AccessoryFitments
     * const accessoryFitments = await prisma.accessoryFitment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accessoryFitmentWithIdOnly = await prisma.accessoryFitment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccessoryFitmentFindManyArgs>(args?: SelectSubset<T, AccessoryFitmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccessoryFitmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AccessoryFitment.
     * @param {AccessoryFitmentCreateArgs} args - Arguments to create a AccessoryFitment.
     * @example
     * // Create one AccessoryFitment
     * const AccessoryFitment = await prisma.accessoryFitment.create({
     *   data: {
     *     // ... data to create a AccessoryFitment
     *   }
     * })
     * 
     */
    create<T extends AccessoryFitmentCreateArgs>(args: SelectSubset<T, AccessoryFitmentCreateArgs<ExtArgs>>): Prisma__AccessoryFitmentClient<$Result.GetResult<Prisma.$AccessoryFitmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AccessoryFitments.
     * @param {AccessoryFitmentCreateManyArgs} args - Arguments to create many AccessoryFitments.
     * @example
     * // Create many AccessoryFitments
     * const accessoryFitment = await prisma.accessoryFitment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccessoryFitmentCreateManyArgs>(args?: SelectSubset<T, AccessoryFitmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AccessoryFitments and returns the data saved in the database.
     * @param {AccessoryFitmentCreateManyAndReturnArgs} args - Arguments to create many AccessoryFitments.
     * @example
     * // Create many AccessoryFitments
     * const accessoryFitment = await prisma.accessoryFitment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AccessoryFitments and only return the `id`
     * const accessoryFitmentWithIdOnly = await prisma.accessoryFitment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccessoryFitmentCreateManyAndReturnArgs>(args?: SelectSubset<T, AccessoryFitmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccessoryFitmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AccessoryFitment.
     * @param {AccessoryFitmentDeleteArgs} args - Arguments to delete one AccessoryFitment.
     * @example
     * // Delete one AccessoryFitment
     * const AccessoryFitment = await prisma.accessoryFitment.delete({
     *   where: {
     *     // ... filter to delete one AccessoryFitment
     *   }
     * })
     * 
     */
    delete<T extends AccessoryFitmentDeleteArgs>(args: SelectSubset<T, AccessoryFitmentDeleteArgs<ExtArgs>>): Prisma__AccessoryFitmentClient<$Result.GetResult<Prisma.$AccessoryFitmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AccessoryFitment.
     * @param {AccessoryFitmentUpdateArgs} args - Arguments to update one AccessoryFitment.
     * @example
     * // Update one AccessoryFitment
     * const accessoryFitment = await prisma.accessoryFitment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccessoryFitmentUpdateArgs>(args: SelectSubset<T, AccessoryFitmentUpdateArgs<ExtArgs>>): Prisma__AccessoryFitmentClient<$Result.GetResult<Prisma.$AccessoryFitmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AccessoryFitments.
     * @param {AccessoryFitmentDeleteManyArgs} args - Arguments to filter AccessoryFitments to delete.
     * @example
     * // Delete a few AccessoryFitments
     * const { count } = await prisma.accessoryFitment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccessoryFitmentDeleteManyArgs>(args?: SelectSubset<T, AccessoryFitmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AccessoryFitments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessoryFitmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AccessoryFitments
     * const accessoryFitment = await prisma.accessoryFitment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccessoryFitmentUpdateManyArgs>(args: SelectSubset<T, AccessoryFitmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AccessoryFitments and returns the data updated in the database.
     * @param {AccessoryFitmentUpdateManyAndReturnArgs} args - Arguments to update many AccessoryFitments.
     * @example
     * // Update many AccessoryFitments
     * const accessoryFitment = await prisma.accessoryFitment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AccessoryFitments and only return the `id`
     * const accessoryFitmentWithIdOnly = await prisma.accessoryFitment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccessoryFitmentUpdateManyAndReturnArgs>(args: SelectSubset<T, AccessoryFitmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccessoryFitmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AccessoryFitment.
     * @param {AccessoryFitmentUpsertArgs} args - Arguments to update or create a AccessoryFitment.
     * @example
     * // Update or create a AccessoryFitment
     * const accessoryFitment = await prisma.accessoryFitment.upsert({
     *   create: {
     *     // ... data to create a AccessoryFitment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AccessoryFitment we want to update
     *   }
     * })
     */
    upsert<T extends AccessoryFitmentUpsertArgs>(args: SelectSubset<T, AccessoryFitmentUpsertArgs<ExtArgs>>): Prisma__AccessoryFitmentClient<$Result.GetResult<Prisma.$AccessoryFitmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AccessoryFitments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessoryFitmentCountArgs} args - Arguments to filter AccessoryFitments to count.
     * @example
     * // Count the number of AccessoryFitments
     * const count = await prisma.accessoryFitment.count({
     *   where: {
     *     // ... the filter for the AccessoryFitments we want to count
     *   }
     * })
    **/
    count<T extends AccessoryFitmentCountArgs>(
      args?: Subset<T, AccessoryFitmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccessoryFitmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AccessoryFitment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessoryFitmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccessoryFitmentAggregateArgs>(args: Subset<T, AccessoryFitmentAggregateArgs>): Prisma.PrismaPromise<GetAccessoryFitmentAggregateType<T>>

    /**
     * Group by AccessoryFitment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessoryFitmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccessoryFitmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccessoryFitmentGroupByArgs['orderBy'] }
        : { orderBy?: AccessoryFitmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccessoryFitmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccessoryFitmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AccessoryFitment model
   */
  readonly fields: AccessoryFitmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AccessoryFitment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccessoryFitmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    AccessorySpecs<T extends AccessorySpecsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccessorySpecsDefaultArgs<ExtArgs>>): Prisma__AccessorySpecsClient<$Result.GetResult<Prisma.$AccessorySpecsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    CatalogItem<T extends AccessoryFitment$CatalogItemArgs<ExtArgs> = {}>(args?: Subset<T, AccessoryFitment$CatalogItemArgs<ExtArgs>>): Prisma__CatalogItemClient<$Result.GetResult<Prisma.$CatalogItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AccessoryFitment model
   */
  interface AccessoryFitmentFieldRefs {
    readonly id: FieldRef<"AccessoryFitment", 'Int'>
    readonly accessorySpecsId: FieldRef<"AccessoryFitment", 'Int'>
    readonly fitmentType: FieldRef<"AccessoryFitment", 'FitmentType'>
    readonly firearmItemId: FieldRef<"AccessoryFitment", 'String'>
    readonly platform: FieldRef<"AccessoryFitment", 'String'>
    readonly note: FieldRef<"AccessoryFitment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AccessoryFitment findUnique
   */
  export type AccessoryFitmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessoryFitment
     */
    select?: AccessoryFitmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessoryFitment
     */
    omit?: AccessoryFitmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessoryFitmentInclude<ExtArgs> | null
    /**
     * Filter, which AccessoryFitment to fetch.
     */
    where: AccessoryFitmentWhereUniqueInput
  }

  /**
   * AccessoryFitment findUniqueOrThrow
   */
  export type AccessoryFitmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessoryFitment
     */
    select?: AccessoryFitmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessoryFitment
     */
    omit?: AccessoryFitmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessoryFitmentInclude<ExtArgs> | null
    /**
     * Filter, which AccessoryFitment to fetch.
     */
    where: AccessoryFitmentWhereUniqueInput
  }

  /**
   * AccessoryFitment findFirst
   */
  export type AccessoryFitmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessoryFitment
     */
    select?: AccessoryFitmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessoryFitment
     */
    omit?: AccessoryFitmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessoryFitmentInclude<ExtArgs> | null
    /**
     * Filter, which AccessoryFitment to fetch.
     */
    where?: AccessoryFitmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccessoryFitments to fetch.
     */
    orderBy?: AccessoryFitmentOrderByWithRelationInput | AccessoryFitmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccessoryFitments.
     */
    cursor?: AccessoryFitmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccessoryFitments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccessoryFitments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccessoryFitments.
     */
    distinct?: AccessoryFitmentScalarFieldEnum | AccessoryFitmentScalarFieldEnum[]
  }

  /**
   * AccessoryFitment findFirstOrThrow
   */
  export type AccessoryFitmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessoryFitment
     */
    select?: AccessoryFitmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessoryFitment
     */
    omit?: AccessoryFitmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessoryFitmentInclude<ExtArgs> | null
    /**
     * Filter, which AccessoryFitment to fetch.
     */
    where?: AccessoryFitmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccessoryFitments to fetch.
     */
    orderBy?: AccessoryFitmentOrderByWithRelationInput | AccessoryFitmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccessoryFitments.
     */
    cursor?: AccessoryFitmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccessoryFitments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccessoryFitments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccessoryFitments.
     */
    distinct?: AccessoryFitmentScalarFieldEnum | AccessoryFitmentScalarFieldEnum[]
  }

  /**
   * AccessoryFitment findMany
   */
  export type AccessoryFitmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessoryFitment
     */
    select?: AccessoryFitmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessoryFitment
     */
    omit?: AccessoryFitmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessoryFitmentInclude<ExtArgs> | null
    /**
     * Filter, which AccessoryFitments to fetch.
     */
    where?: AccessoryFitmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccessoryFitments to fetch.
     */
    orderBy?: AccessoryFitmentOrderByWithRelationInput | AccessoryFitmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AccessoryFitments.
     */
    cursor?: AccessoryFitmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccessoryFitments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccessoryFitments.
     */
    skip?: number
    distinct?: AccessoryFitmentScalarFieldEnum | AccessoryFitmentScalarFieldEnum[]
  }

  /**
   * AccessoryFitment create
   */
  export type AccessoryFitmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessoryFitment
     */
    select?: AccessoryFitmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessoryFitment
     */
    omit?: AccessoryFitmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessoryFitmentInclude<ExtArgs> | null
    /**
     * The data needed to create a AccessoryFitment.
     */
    data: XOR<AccessoryFitmentCreateInput, AccessoryFitmentUncheckedCreateInput>
  }

  /**
   * AccessoryFitment createMany
   */
  export type AccessoryFitmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AccessoryFitments.
     */
    data: AccessoryFitmentCreateManyInput | AccessoryFitmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AccessoryFitment createManyAndReturn
   */
  export type AccessoryFitmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessoryFitment
     */
    select?: AccessoryFitmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AccessoryFitment
     */
    omit?: AccessoryFitmentOmit<ExtArgs> | null
    /**
     * The data used to create many AccessoryFitments.
     */
    data: AccessoryFitmentCreateManyInput | AccessoryFitmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessoryFitmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AccessoryFitment update
   */
  export type AccessoryFitmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessoryFitment
     */
    select?: AccessoryFitmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessoryFitment
     */
    omit?: AccessoryFitmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessoryFitmentInclude<ExtArgs> | null
    /**
     * The data needed to update a AccessoryFitment.
     */
    data: XOR<AccessoryFitmentUpdateInput, AccessoryFitmentUncheckedUpdateInput>
    /**
     * Choose, which AccessoryFitment to update.
     */
    where: AccessoryFitmentWhereUniqueInput
  }

  /**
   * AccessoryFitment updateMany
   */
  export type AccessoryFitmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AccessoryFitments.
     */
    data: XOR<AccessoryFitmentUpdateManyMutationInput, AccessoryFitmentUncheckedUpdateManyInput>
    /**
     * Filter which AccessoryFitments to update
     */
    where?: AccessoryFitmentWhereInput
    /**
     * Limit how many AccessoryFitments to update.
     */
    limit?: number
  }

  /**
   * AccessoryFitment updateManyAndReturn
   */
  export type AccessoryFitmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessoryFitment
     */
    select?: AccessoryFitmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AccessoryFitment
     */
    omit?: AccessoryFitmentOmit<ExtArgs> | null
    /**
     * The data used to update AccessoryFitments.
     */
    data: XOR<AccessoryFitmentUpdateManyMutationInput, AccessoryFitmentUncheckedUpdateManyInput>
    /**
     * Filter which AccessoryFitments to update
     */
    where?: AccessoryFitmentWhereInput
    /**
     * Limit how many AccessoryFitments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessoryFitmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AccessoryFitment upsert
   */
  export type AccessoryFitmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessoryFitment
     */
    select?: AccessoryFitmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessoryFitment
     */
    omit?: AccessoryFitmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessoryFitmentInclude<ExtArgs> | null
    /**
     * The filter to search for the AccessoryFitment to update in case it exists.
     */
    where: AccessoryFitmentWhereUniqueInput
    /**
     * In case the AccessoryFitment found by the `where` argument doesn't exist, create a new AccessoryFitment with this data.
     */
    create: XOR<AccessoryFitmentCreateInput, AccessoryFitmentUncheckedCreateInput>
    /**
     * In case the AccessoryFitment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccessoryFitmentUpdateInput, AccessoryFitmentUncheckedUpdateInput>
  }

  /**
   * AccessoryFitment delete
   */
  export type AccessoryFitmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessoryFitment
     */
    select?: AccessoryFitmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessoryFitment
     */
    omit?: AccessoryFitmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessoryFitmentInclude<ExtArgs> | null
    /**
     * Filter which AccessoryFitment to delete.
     */
    where: AccessoryFitmentWhereUniqueInput
  }

  /**
   * AccessoryFitment deleteMany
   */
  export type AccessoryFitmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccessoryFitments to delete
     */
    where?: AccessoryFitmentWhereInput
    /**
     * Limit how many AccessoryFitments to delete.
     */
    limit?: number
  }

  /**
   * AccessoryFitment.CatalogItem
   */
  export type AccessoryFitment$CatalogItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogItem
     */
    select?: CatalogItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CatalogItem
     */
    omit?: CatalogItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogItemInclude<ExtArgs> | null
    where?: CatalogItemWhereInput
  }

  /**
   * AccessoryFitment without action
   */
  export type AccessoryFitmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessoryFitment
     */
    select?: AccessoryFitmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessoryFitment
     */
    omit?: AccessoryFitmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessoryFitmentInclude<ExtArgs> | null
  }


  /**
   * Model AccessorySpecs
   */

  export type AggregateAccessorySpecs = {
    _count: AccessorySpecsCountAggregateOutputType | null
    _avg: AccessorySpecsAvgAggregateOutputType | null
    _sum: AccessorySpecsSumAggregateOutputType | null
    _min: AccessorySpecsMinAggregateOutputType | null
    _max: AccessorySpecsMaxAggregateOutputType | null
  }

  export type AccessorySpecsAvgAggregateOutputType = {
    id: number | null
    accessoryTypeId: number | null
  }

  export type AccessorySpecsSumAggregateOutputType = {
    id: number | null
    accessoryTypeId: number | null
  }

  export type AccessorySpecsMinAggregateOutputType = {
    id: number | null
    itemId: string | null
    accessoryTypeId: number | null
    material: string | null
    color: string | null
    notes: string | null
  }

  export type AccessorySpecsMaxAggregateOutputType = {
    id: number | null
    itemId: string | null
    accessoryTypeId: number | null
    material: string | null
    color: string | null
    notes: string | null
  }

  export type AccessorySpecsCountAggregateOutputType = {
    id: number
    itemId: number
    accessoryTypeId: number
    material: number
    color: number
    notes: number
    _all: number
  }


  export type AccessorySpecsAvgAggregateInputType = {
    id?: true
    accessoryTypeId?: true
  }

  export type AccessorySpecsSumAggregateInputType = {
    id?: true
    accessoryTypeId?: true
  }

  export type AccessorySpecsMinAggregateInputType = {
    id?: true
    itemId?: true
    accessoryTypeId?: true
    material?: true
    color?: true
    notes?: true
  }

  export type AccessorySpecsMaxAggregateInputType = {
    id?: true
    itemId?: true
    accessoryTypeId?: true
    material?: true
    color?: true
    notes?: true
  }

  export type AccessorySpecsCountAggregateInputType = {
    id?: true
    itemId?: true
    accessoryTypeId?: true
    material?: true
    color?: true
    notes?: true
    _all?: true
  }

  export type AccessorySpecsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccessorySpecs to aggregate.
     */
    where?: AccessorySpecsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccessorySpecs to fetch.
     */
    orderBy?: AccessorySpecsOrderByWithRelationInput | AccessorySpecsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccessorySpecsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccessorySpecs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccessorySpecs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AccessorySpecs
    **/
    _count?: true | AccessorySpecsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccessorySpecsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccessorySpecsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccessorySpecsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccessorySpecsMaxAggregateInputType
  }

  export type GetAccessorySpecsAggregateType<T extends AccessorySpecsAggregateArgs> = {
        [P in keyof T & keyof AggregateAccessorySpecs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccessorySpecs[P]>
      : GetScalarType<T[P], AggregateAccessorySpecs[P]>
  }




  export type AccessorySpecsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccessorySpecsWhereInput
    orderBy?: AccessorySpecsOrderByWithAggregationInput | AccessorySpecsOrderByWithAggregationInput[]
    by: AccessorySpecsScalarFieldEnum[] | AccessorySpecsScalarFieldEnum
    having?: AccessorySpecsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccessorySpecsCountAggregateInputType | true
    _avg?: AccessorySpecsAvgAggregateInputType
    _sum?: AccessorySpecsSumAggregateInputType
    _min?: AccessorySpecsMinAggregateInputType
    _max?: AccessorySpecsMaxAggregateInputType
  }

  export type AccessorySpecsGroupByOutputType = {
    id: number
    itemId: string
    accessoryTypeId: number | null
    material: string | null
    color: string | null
    notes: string | null
    _count: AccessorySpecsCountAggregateOutputType | null
    _avg: AccessorySpecsAvgAggregateOutputType | null
    _sum: AccessorySpecsSumAggregateOutputType | null
    _min: AccessorySpecsMinAggregateOutputType | null
    _max: AccessorySpecsMaxAggregateOutputType | null
  }

  type GetAccessorySpecsGroupByPayload<T extends AccessorySpecsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccessorySpecsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccessorySpecsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccessorySpecsGroupByOutputType[P]>
            : GetScalarType<T[P], AccessorySpecsGroupByOutputType[P]>
        }
      >
    >


  export type AccessorySpecsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itemId?: boolean
    accessoryTypeId?: boolean
    material?: boolean
    color?: boolean
    notes?: boolean
    AccessoryFitment?: boolean | AccessorySpecs$AccessoryFitmentArgs<ExtArgs>
    AccessoryType?: boolean | AccessorySpecs$AccessoryTypeArgs<ExtArgs>
    CatalogItem?: boolean | CatalogItemDefaultArgs<ExtArgs>
    _count?: boolean | AccessorySpecsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["accessorySpecs"]>

  export type AccessorySpecsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itemId?: boolean
    accessoryTypeId?: boolean
    material?: boolean
    color?: boolean
    notes?: boolean
    AccessoryType?: boolean | AccessorySpecs$AccessoryTypeArgs<ExtArgs>
    CatalogItem?: boolean | CatalogItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["accessorySpecs"]>

  export type AccessorySpecsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itemId?: boolean
    accessoryTypeId?: boolean
    material?: boolean
    color?: boolean
    notes?: boolean
    AccessoryType?: boolean | AccessorySpecs$AccessoryTypeArgs<ExtArgs>
    CatalogItem?: boolean | CatalogItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["accessorySpecs"]>

  export type AccessorySpecsSelectScalar = {
    id?: boolean
    itemId?: boolean
    accessoryTypeId?: boolean
    material?: boolean
    color?: boolean
    notes?: boolean
  }

  export type AccessorySpecsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "itemId" | "accessoryTypeId" | "material" | "color" | "notes", ExtArgs["result"]["accessorySpecs"]>
  export type AccessorySpecsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AccessoryFitment?: boolean | AccessorySpecs$AccessoryFitmentArgs<ExtArgs>
    AccessoryType?: boolean | AccessorySpecs$AccessoryTypeArgs<ExtArgs>
    CatalogItem?: boolean | CatalogItemDefaultArgs<ExtArgs>
    _count?: boolean | AccessorySpecsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AccessorySpecsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AccessoryType?: boolean | AccessorySpecs$AccessoryTypeArgs<ExtArgs>
    CatalogItem?: boolean | CatalogItemDefaultArgs<ExtArgs>
  }
  export type AccessorySpecsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AccessoryType?: boolean | AccessorySpecs$AccessoryTypeArgs<ExtArgs>
    CatalogItem?: boolean | CatalogItemDefaultArgs<ExtArgs>
  }

  export type $AccessorySpecsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AccessorySpecs"
    objects: {
      AccessoryFitment: Prisma.$AccessoryFitmentPayload<ExtArgs>[]
      AccessoryType: Prisma.$AccessoryTypePayload<ExtArgs> | null
      CatalogItem: Prisma.$CatalogItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      itemId: string
      accessoryTypeId: number | null
      material: string | null
      color: string | null
      notes: string | null
    }, ExtArgs["result"]["accessorySpecs"]>
    composites: {}
  }

  type AccessorySpecsGetPayload<S extends boolean | null | undefined | AccessorySpecsDefaultArgs> = $Result.GetResult<Prisma.$AccessorySpecsPayload, S>

  type AccessorySpecsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccessorySpecsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccessorySpecsCountAggregateInputType | true
    }

  export interface AccessorySpecsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AccessorySpecs'], meta: { name: 'AccessorySpecs' } }
    /**
     * Find zero or one AccessorySpecs that matches the filter.
     * @param {AccessorySpecsFindUniqueArgs} args - Arguments to find a AccessorySpecs
     * @example
     * // Get one AccessorySpecs
     * const accessorySpecs = await prisma.accessorySpecs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccessorySpecsFindUniqueArgs>(args: SelectSubset<T, AccessorySpecsFindUniqueArgs<ExtArgs>>): Prisma__AccessorySpecsClient<$Result.GetResult<Prisma.$AccessorySpecsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AccessorySpecs that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccessorySpecsFindUniqueOrThrowArgs} args - Arguments to find a AccessorySpecs
     * @example
     * // Get one AccessorySpecs
     * const accessorySpecs = await prisma.accessorySpecs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccessorySpecsFindUniqueOrThrowArgs>(args: SelectSubset<T, AccessorySpecsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccessorySpecsClient<$Result.GetResult<Prisma.$AccessorySpecsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AccessorySpecs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessorySpecsFindFirstArgs} args - Arguments to find a AccessorySpecs
     * @example
     * // Get one AccessorySpecs
     * const accessorySpecs = await prisma.accessorySpecs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccessorySpecsFindFirstArgs>(args?: SelectSubset<T, AccessorySpecsFindFirstArgs<ExtArgs>>): Prisma__AccessorySpecsClient<$Result.GetResult<Prisma.$AccessorySpecsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AccessorySpecs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessorySpecsFindFirstOrThrowArgs} args - Arguments to find a AccessorySpecs
     * @example
     * // Get one AccessorySpecs
     * const accessorySpecs = await prisma.accessorySpecs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccessorySpecsFindFirstOrThrowArgs>(args?: SelectSubset<T, AccessorySpecsFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccessorySpecsClient<$Result.GetResult<Prisma.$AccessorySpecsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AccessorySpecs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessorySpecsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AccessorySpecs
     * const accessorySpecs = await prisma.accessorySpecs.findMany()
     * 
     * // Get first 10 AccessorySpecs
     * const accessorySpecs = await prisma.accessorySpecs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accessorySpecsWithIdOnly = await prisma.accessorySpecs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccessorySpecsFindManyArgs>(args?: SelectSubset<T, AccessorySpecsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccessorySpecsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AccessorySpecs.
     * @param {AccessorySpecsCreateArgs} args - Arguments to create a AccessorySpecs.
     * @example
     * // Create one AccessorySpecs
     * const AccessorySpecs = await prisma.accessorySpecs.create({
     *   data: {
     *     // ... data to create a AccessorySpecs
     *   }
     * })
     * 
     */
    create<T extends AccessorySpecsCreateArgs>(args: SelectSubset<T, AccessorySpecsCreateArgs<ExtArgs>>): Prisma__AccessorySpecsClient<$Result.GetResult<Prisma.$AccessorySpecsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AccessorySpecs.
     * @param {AccessorySpecsCreateManyArgs} args - Arguments to create many AccessorySpecs.
     * @example
     * // Create many AccessorySpecs
     * const accessorySpecs = await prisma.accessorySpecs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccessorySpecsCreateManyArgs>(args?: SelectSubset<T, AccessorySpecsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AccessorySpecs and returns the data saved in the database.
     * @param {AccessorySpecsCreateManyAndReturnArgs} args - Arguments to create many AccessorySpecs.
     * @example
     * // Create many AccessorySpecs
     * const accessorySpecs = await prisma.accessorySpecs.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AccessorySpecs and only return the `id`
     * const accessorySpecsWithIdOnly = await prisma.accessorySpecs.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccessorySpecsCreateManyAndReturnArgs>(args?: SelectSubset<T, AccessorySpecsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccessorySpecsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AccessorySpecs.
     * @param {AccessorySpecsDeleteArgs} args - Arguments to delete one AccessorySpecs.
     * @example
     * // Delete one AccessorySpecs
     * const AccessorySpecs = await prisma.accessorySpecs.delete({
     *   where: {
     *     // ... filter to delete one AccessorySpecs
     *   }
     * })
     * 
     */
    delete<T extends AccessorySpecsDeleteArgs>(args: SelectSubset<T, AccessorySpecsDeleteArgs<ExtArgs>>): Prisma__AccessorySpecsClient<$Result.GetResult<Prisma.$AccessorySpecsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AccessorySpecs.
     * @param {AccessorySpecsUpdateArgs} args - Arguments to update one AccessorySpecs.
     * @example
     * // Update one AccessorySpecs
     * const accessorySpecs = await prisma.accessorySpecs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccessorySpecsUpdateArgs>(args: SelectSubset<T, AccessorySpecsUpdateArgs<ExtArgs>>): Prisma__AccessorySpecsClient<$Result.GetResult<Prisma.$AccessorySpecsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AccessorySpecs.
     * @param {AccessorySpecsDeleteManyArgs} args - Arguments to filter AccessorySpecs to delete.
     * @example
     * // Delete a few AccessorySpecs
     * const { count } = await prisma.accessorySpecs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccessorySpecsDeleteManyArgs>(args?: SelectSubset<T, AccessorySpecsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AccessorySpecs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessorySpecsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AccessorySpecs
     * const accessorySpecs = await prisma.accessorySpecs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccessorySpecsUpdateManyArgs>(args: SelectSubset<T, AccessorySpecsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AccessorySpecs and returns the data updated in the database.
     * @param {AccessorySpecsUpdateManyAndReturnArgs} args - Arguments to update many AccessorySpecs.
     * @example
     * // Update many AccessorySpecs
     * const accessorySpecs = await prisma.accessorySpecs.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AccessorySpecs and only return the `id`
     * const accessorySpecsWithIdOnly = await prisma.accessorySpecs.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccessorySpecsUpdateManyAndReturnArgs>(args: SelectSubset<T, AccessorySpecsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccessorySpecsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AccessorySpecs.
     * @param {AccessorySpecsUpsertArgs} args - Arguments to update or create a AccessorySpecs.
     * @example
     * // Update or create a AccessorySpecs
     * const accessorySpecs = await prisma.accessorySpecs.upsert({
     *   create: {
     *     // ... data to create a AccessorySpecs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AccessorySpecs we want to update
     *   }
     * })
     */
    upsert<T extends AccessorySpecsUpsertArgs>(args: SelectSubset<T, AccessorySpecsUpsertArgs<ExtArgs>>): Prisma__AccessorySpecsClient<$Result.GetResult<Prisma.$AccessorySpecsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AccessorySpecs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessorySpecsCountArgs} args - Arguments to filter AccessorySpecs to count.
     * @example
     * // Count the number of AccessorySpecs
     * const count = await prisma.accessorySpecs.count({
     *   where: {
     *     // ... the filter for the AccessorySpecs we want to count
     *   }
     * })
    **/
    count<T extends AccessorySpecsCountArgs>(
      args?: Subset<T, AccessorySpecsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccessorySpecsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AccessorySpecs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessorySpecsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccessorySpecsAggregateArgs>(args: Subset<T, AccessorySpecsAggregateArgs>): Prisma.PrismaPromise<GetAccessorySpecsAggregateType<T>>

    /**
     * Group by AccessorySpecs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessorySpecsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccessorySpecsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccessorySpecsGroupByArgs['orderBy'] }
        : { orderBy?: AccessorySpecsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccessorySpecsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccessorySpecsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AccessorySpecs model
   */
  readonly fields: AccessorySpecsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AccessorySpecs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccessorySpecsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    AccessoryFitment<T extends AccessorySpecs$AccessoryFitmentArgs<ExtArgs> = {}>(args?: Subset<T, AccessorySpecs$AccessoryFitmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccessoryFitmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    AccessoryType<T extends AccessorySpecs$AccessoryTypeArgs<ExtArgs> = {}>(args?: Subset<T, AccessorySpecs$AccessoryTypeArgs<ExtArgs>>): Prisma__AccessoryTypeClient<$Result.GetResult<Prisma.$AccessoryTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    CatalogItem<T extends CatalogItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CatalogItemDefaultArgs<ExtArgs>>): Prisma__CatalogItemClient<$Result.GetResult<Prisma.$CatalogItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AccessorySpecs model
   */
  interface AccessorySpecsFieldRefs {
    readonly id: FieldRef<"AccessorySpecs", 'Int'>
    readonly itemId: FieldRef<"AccessorySpecs", 'String'>
    readonly accessoryTypeId: FieldRef<"AccessorySpecs", 'Int'>
    readonly material: FieldRef<"AccessorySpecs", 'String'>
    readonly color: FieldRef<"AccessorySpecs", 'String'>
    readonly notes: FieldRef<"AccessorySpecs", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AccessorySpecs findUnique
   */
  export type AccessorySpecsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessorySpecs
     */
    select?: AccessorySpecsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessorySpecs
     */
    omit?: AccessorySpecsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessorySpecsInclude<ExtArgs> | null
    /**
     * Filter, which AccessorySpecs to fetch.
     */
    where: AccessorySpecsWhereUniqueInput
  }

  /**
   * AccessorySpecs findUniqueOrThrow
   */
  export type AccessorySpecsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessorySpecs
     */
    select?: AccessorySpecsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessorySpecs
     */
    omit?: AccessorySpecsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessorySpecsInclude<ExtArgs> | null
    /**
     * Filter, which AccessorySpecs to fetch.
     */
    where: AccessorySpecsWhereUniqueInput
  }

  /**
   * AccessorySpecs findFirst
   */
  export type AccessorySpecsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessorySpecs
     */
    select?: AccessorySpecsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessorySpecs
     */
    omit?: AccessorySpecsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessorySpecsInclude<ExtArgs> | null
    /**
     * Filter, which AccessorySpecs to fetch.
     */
    where?: AccessorySpecsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccessorySpecs to fetch.
     */
    orderBy?: AccessorySpecsOrderByWithRelationInput | AccessorySpecsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccessorySpecs.
     */
    cursor?: AccessorySpecsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccessorySpecs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccessorySpecs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccessorySpecs.
     */
    distinct?: AccessorySpecsScalarFieldEnum | AccessorySpecsScalarFieldEnum[]
  }

  /**
   * AccessorySpecs findFirstOrThrow
   */
  export type AccessorySpecsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessorySpecs
     */
    select?: AccessorySpecsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessorySpecs
     */
    omit?: AccessorySpecsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessorySpecsInclude<ExtArgs> | null
    /**
     * Filter, which AccessorySpecs to fetch.
     */
    where?: AccessorySpecsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccessorySpecs to fetch.
     */
    orderBy?: AccessorySpecsOrderByWithRelationInput | AccessorySpecsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccessorySpecs.
     */
    cursor?: AccessorySpecsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccessorySpecs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccessorySpecs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccessorySpecs.
     */
    distinct?: AccessorySpecsScalarFieldEnum | AccessorySpecsScalarFieldEnum[]
  }

  /**
   * AccessorySpecs findMany
   */
  export type AccessorySpecsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessorySpecs
     */
    select?: AccessorySpecsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessorySpecs
     */
    omit?: AccessorySpecsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessorySpecsInclude<ExtArgs> | null
    /**
     * Filter, which AccessorySpecs to fetch.
     */
    where?: AccessorySpecsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccessorySpecs to fetch.
     */
    orderBy?: AccessorySpecsOrderByWithRelationInput | AccessorySpecsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AccessorySpecs.
     */
    cursor?: AccessorySpecsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccessorySpecs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccessorySpecs.
     */
    skip?: number
    distinct?: AccessorySpecsScalarFieldEnum | AccessorySpecsScalarFieldEnum[]
  }

  /**
   * AccessorySpecs create
   */
  export type AccessorySpecsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessorySpecs
     */
    select?: AccessorySpecsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessorySpecs
     */
    omit?: AccessorySpecsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessorySpecsInclude<ExtArgs> | null
    /**
     * The data needed to create a AccessorySpecs.
     */
    data: XOR<AccessorySpecsCreateInput, AccessorySpecsUncheckedCreateInput>
  }

  /**
   * AccessorySpecs createMany
   */
  export type AccessorySpecsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AccessorySpecs.
     */
    data: AccessorySpecsCreateManyInput | AccessorySpecsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AccessorySpecs createManyAndReturn
   */
  export type AccessorySpecsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessorySpecs
     */
    select?: AccessorySpecsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AccessorySpecs
     */
    omit?: AccessorySpecsOmit<ExtArgs> | null
    /**
     * The data used to create many AccessorySpecs.
     */
    data: AccessorySpecsCreateManyInput | AccessorySpecsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessorySpecsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AccessorySpecs update
   */
  export type AccessorySpecsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessorySpecs
     */
    select?: AccessorySpecsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessorySpecs
     */
    omit?: AccessorySpecsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessorySpecsInclude<ExtArgs> | null
    /**
     * The data needed to update a AccessorySpecs.
     */
    data: XOR<AccessorySpecsUpdateInput, AccessorySpecsUncheckedUpdateInput>
    /**
     * Choose, which AccessorySpecs to update.
     */
    where: AccessorySpecsWhereUniqueInput
  }

  /**
   * AccessorySpecs updateMany
   */
  export type AccessorySpecsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AccessorySpecs.
     */
    data: XOR<AccessorySpecsUpdateManyMutationInput, AccessorySpecsUncheckedUpdateManyInput>
    /**
     * Filter which AccessorySpecs to update
     */
    where?: AccessorySpecsWhereInput
    /**
     * Limit how many AccessorySpecs to update.
     */
    limit?: number
  }

  /**
   * AccessorySpecs updateManyAndReturn
   */
  export type AccessorySpecsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessorySpecs
     */
    select?: AccessorySpecsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AccessorySpecs
     */
    omit?: AccessorySpecsOmit<ExtArgs> | null
    /**
     * The data used to update AccessorySpecs.
     */
    data: XOR<AccessorySpecsUpdateManyMutationInput, AccessorySpecsUncheckedUpdateManyInput>
    /**
     * Filter which AccessorySpecs to update
     */
    where?: AccessorySpecsWhereInput
    /**
     * Limit how many AccessorySpecs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessorySpecsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AccessorySpecs upsert
   */
  export type AccessorySpecsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessorySpecs
     */
    select?: AccessorySpecsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessorySpecs
     */
    omit?: AccessorySpecsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessorySpecsInclude<ExtArgs> | null
    /**
     * The filter to search for the AccessorySpecs to update in case it exists.
     */
    where: AccessorySpecsWhereUniqueInput
    /**
     * In case the AccessorySpecs found by the `where` argument doesn't exist, create a new AccessorySpecs with this data.
     */
    create: XOR<AccessorySpecsCreateInput, AccessorySpecsUncheckedCreateInput>
    /**
     * In case the AccessorySpecs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccessorySpecsUpdateInput, AccessorySpecsUncheckedUpdateInput>
  }

  /**
   * AccessorySpecs delete
   */
  export type AccessorySpecsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessorySpecs
     */
    select?: AccessorySpecsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessorySpecs
     */
    omit?: AccessorySpecsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessorySpecsInclude<ExtArgs> | null
    /**
     * Filter which AccessorySpecs to delete.
     */
    where: AccessorySpecsWhereUniqueInput
  }

  /**
   * AccessorySpecs deleteMany
   */
  export type AccessorySpecsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccessorySpecs to delete
     */
    where?: AccessorySpecsWhereInput
    /**
     * Limit how many AccessorySpecs to delete.
     */
    limit?: number
  }

  /**
   * AccessorySpecs.AccessoryFitment
   */
  export type AccessorySpecs$AccessoryFitmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessoryFitment
     */
    select?: AccessoryFitmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessoryFitment
     */
    omit?: AccessoryFitmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessoryFitmentInclude<ExtArgs> | null
    where?: AccessoryFitmentWhereInput
    orderBy?: AccessoryFitmentOrderByWithRelationInput | AccessoryFitmentOrderByWithRelationInput[]
    cursor?: AccessoryFitmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccessoryFitmentScalarFieldEnum | AccessoryFitmentScalarFieldEnum[]
  }

  /**
   * AccessorySpecs.AccessoryType
   */
  export type AccessorySpecs$AccessoryTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessoryType
     */
    select?: AccessoryTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessoryType
     */
    omit?: AccessoryTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessoryTypeInclude<ExtArgs> | null
    where?: AccessoryTypeWhereInput
  }

  /**
   * AccessorySpecs without action
   */
  export type AccessorySpecsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessorySpecs
     */
    select?: AccessorySpecsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessorySpecs
     */
    omit?: AccessorySpecsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessorySpecsInclude<ExtArgs> | null
  }


  /**
   * Model AccessoryType
   */

  export type AggregateAccessoryType = {
    _count: AccessoryTypeCountAggregateOutputType | null
    _avg: AccessoryTypeAvgAggregateOutputType | null
    _sum: AccessoryTypeSumAggregateOutputType | null
    _min: AccessoryTypeMinAggregateOutputType | null
    _max: AccessoryTypeMaxAggregateOutputType | null
  }

  export type AccessoryTypeAvgAggregateOutputType = {
    id: number | null
  }

  export type AccessoryTypeSumAggregateOutputType = {
    id: number | null
  }

  export type AccessoryTypeMinAggregateOutputType = {
    id: number | null
    name: string | null
    slug: string | null
  }

  export type AccessoryTypeMaxAggregateOutputType = {
    id: number | null
    name: string | null
    slug: string | null
  }

  export type AccessoryTypeCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    _all: number
  }


  export type AccessoryTypeAvgAggregateInputType = {
    id?: true
  }

  export type AccessoryTypeSumAggregateInputType = {
    id?: true
  }

  export type AccessoryTypeMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
  }

  export type AccessoryTypeMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
  }

  export type AccessoryTypeCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    _all?: true
  }

  export type AccessoryTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccessoryType to aggregate.
     */
    where?: AccessoryTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccessoryTypes to fetch.
     */
    orderBy?: AccessoryTypeOrderByWithRelationInput | AccessoryTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccessoryTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccessoryTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccessoryTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AccessoryTypes
    **/
    _count?: true | AccessoryTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccessoryTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccessoryTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccessoryTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccessoryTypeMaxAggregateInputType
  }

  export type GetAccessoryTypeAggregateType<T extends AccessoryTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateAccessoryType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccessoryType[P]>
      : GetScalarType<T[P], AggregateAccessoryType[P]>
  }




  export type AccessoryTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccessoryTypeWhereInput
    orderBy?: AccessoryTypeOrderByWithAggregationInput | AccessoryTypeOrderByWithAggregationInput[]
    by: AccessoryTypeScalarFieldEnum[] | AccessoryTypeScalarFieldEnum
    having?: AccessoryTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccessoryTypeCountAggregateInputType | true
    _avg?: AccessoryTypeAvgAggregateInputType
    _sum?: AccessoryTypeSumAggregateInputType
    _min?: AccessoryTypeMinAggregateInputType
    _max?: AccessoryTypeMaxAggregateInputType
  }

  export type AccessoryTypeGroupByOutputType = {
    id: number
    name: string
    slug: string
    _count: AccessoryTypeCountAggregateOutputType | null
    _avg: AccessoryTypeAvgAggregateOutputType | null
    _sum: AccessoryTypeSumAggregateOutputType | null
    _min: AccessoryTypeMinAggregateOutputType | null
    _max: AccessoryTypeMaxAggregateOutputType | null
  }

  type GetAccessoryTypeGroupByPayload<T extends AccessoryTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccessoryTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccessoryTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccessoryTypeGroupByOutputType[P]>
            : GetScalarType<T[P], AccessoryTypeGroupByOutputType[P]>
        }
      >
    >


  export type AccessoryTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    AccessorySpecs?: boolean | AccessoryType$AccessorySpecsArgs<ExtArgs>
    _count?: boolean | AccessoryTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["accessoryType"]>

  export type AccessoryTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
  }, ExtArgs["result"]["accessoryType"]>

  export type AccessoryTypeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
  }, ExtArgs["result"]["accessoryType"]>

  export type AccessoryTypeSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
  }

  export type AccessoryTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug", ExtArgs["result"]["accessoryType"]>
  export type AccessoryTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AccessorySpecs?: boolean | AccessoryType$AccessorySpecsArgs<ExtArgs>
    _count?: boolean | AccessoryTypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AccessoryTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AccessoryTypeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AccessoryTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AccessoryType"
    objects: {
      AccessorySpecs: Prisma.$AccessorySpecsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      slug: string
    }, ExtArgs["result"]["accessoryType"]>
    composites: {}
  }

  type AccessoryTypeGetPayload<S extends boolean | null | undefined | AccessoryTypeDefaultArgs> = $Result.GetResult<Prisma.$AccessoryTypePayload, S>

  type AccessoryTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccessoryTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccessoryTypeCountAggregateInputType | true
    }

  export interface AccessoryTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AccessoryType'], meta: { name: 'AccessoryType' } }
    /**
     * Find zero or one AccessoryType that matches the filter.
     * @param {AccessoryTypeFindUniqueArgs} args - Arguments to find a AccessoryType
     * @example
     * // Get one AccessoryType
     * const accessoryType = await prisma.accessoryType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccessoryTypeFindUniqueArgs>(args: SelectSubset<T, AccessoryTypeFindUniqueArgs<ExtArgs>>): Prisma__AccessoryTypeClient<$Result.GetResult<Prisma.$AccessoryTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AccessoryType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccessoryTypeFindUniqueOrThrowArgs} args - Arguments to find a AccessoryType
     * @example
     * // Get one AccessoryType
     * const accessoryType = await prisma.accessoryType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccessoryTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, AccessoryTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccessoryTypeClient<$Result.GetResult<Prisma.$AccessoryTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AccessoryType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessoryTypeFindFirstArgs} args - Arguments to find a AccessoryType
     * @example
     * // Get one AccessoryType
     * const accessoryType = await prisma.accessoryType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccessoryTypeFindFirstArgs>(args?: SelectSubset<T, AccessoryTypeFindFirstArgs<ExtArgs>>): Prisma__AccessoryTypeClient<$Result.GetResult<Prisma.$AccessoryTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AccessoryType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessoryTypeFindFirstOrThrowArgs} args - Arguments to find a AccessoryType
     * @example
     * // Get one AccessoryType
     * const accessoryType = await prisma.accessoryType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccessoryTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, AccessoryTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccessoryTypeClient<$Result.GetResult<Prisma.$AccessoryTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AccessoryTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessoryTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AccessoryTypes
     * const accessoryTypes = await prisma.accessoryType.findMany()
     * 
     * // Get first 10 AccessoryTypes
     * const accessoryTypes = await prisma.accessoryType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accessoryTypeWithIdOnly = await prisma.accessoryType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccessoryTypeFindManyArgs>(args?: SelectSubset<T, AccessoryTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccessoryTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AccessoryType.
     * @param {AccessoryTypeCreateArgs} args - Arguments to create a AccessoryType.
     * @example
     * // Create one AccessoryType
     * const AccessoryType = await prisma.accessoryType.create({
     *   data: {
     *     // ... data to create a AccessoryType
     *   }
     * })
     * 
     */
    create<T extends AccessoryTypeCreateArgs>(args: SelectSubset<T, AccessoryTypeCreateArgs<ExtArgs>>): Prisma__AccessoryTypeClient<$Result.GetResult<Prisma.$AccessoryTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AccessoryTypes.
     * @param {AccessoryTypeCreateManyArgs} args - Arguments to create many AccessoryTypes.
     * @example
     * // Create many AccessoryTypes
     * const accessoryType = await prisma.accessoryType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccessoryTypeCreateManyArgs>(args?: SelectSubset<T, AccessoryTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AccessoryTypes and returns the data saved in the database.
     * @param {AccessoryTypeCreateManyAndReturnArgs} args - Arguments to create many AccessoryTypes.
     * @example
     * // Create many AccessoryTypes
     * const accessoryType = await prisma.accessoryType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AccessoryTypes and only return the `id`
     * const accessoryTypeWithIdOnly = await prisma.accessoryType.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccessoryTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, AccessoryTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccessoryTypePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AccessoryType.
     * @param {AccessoryTypeDeleteArgs} args - Arguments to delete one AccessoryType.
     * @example
     * // Delete one AccessoryType
     * const AccessoryType = await prisma.accessoryType.delete({
     *   where: {
     *     // ... filter to delete one AccessoryType
     *   }
     * })
     * 
     */
    delete<T extends AccessoryTypeDeleteArgs>(args: SelectSubset<T, AccessoryTypeDeleteArgs<ExtArgs>>): Prisma__AccessoryTypeClient<$Result.GetResult<Prisma.$AccessoryTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AccessoryType.
     * @param {AccessoryTypeUpdateArgs} args - Arguments to update one AccessoryType.
     * @example
     * // Update one AccessoryType
     * const accessoryType = await prisma.accessoryType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccessoryTypeUpdateArgs>(args: SelectSubset<T, AccessoryTypeUpdateArgs<ExtArgs>>): Prisma__AccessoryTypeClient<$Result.GetResult<Prisma.$AccessoryTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AccessoryTypes.
     * @param {AccessoryTypeDeleteManyArgs} args - Arguments to filter AccessoryTypes to delete.
     * @example
     * // Delete a few AccessoryTypes
     * const { count } = await prisma.accessoryType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccessoryTypeDeleteManyArgs>(args?: SelectSubset<T, AccessoryTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AccessoryTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessoryTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AccessoryTypes
     * const accessoryType = await prisma.accessoryType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccessoryTypeUpdateManyArgs>(args: SelectSubset<T, AccessoryTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AccessoryTypes and returns the data updated in the database.
     * @param {AccessoryTypeUpdateManyAndReturnArgs} args - Arguments to update many AccessoryTypes.
     * @example
     * // Update many AccessoryTypes
     * const accessoryType = await prisma.accessoryType.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AccessoryTypes and only return the `id`
     * const accessoryTypeWithIdOnly = await prisma.accessoryType.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccessoryTypeUpdateManyAndReturnArgs>(args: SelectSubset<T, AccessoryTypeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccessoryTypePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AccessoryType.
     * @param {AccessoryTypeUpsertArgs} args - Arguments to update or create a AccessoryType.
     * @example
     * // Update or create a AccessoryType
     * const accessoryType = await prisma.accessoryType.upsert({
     *   create: {
     *     // ... data to create a AccessoryType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AccessoryType we want to update
     *   }
     * })
     */
    upsert<T extends AccessoryTypeUpsertArgs>(args: SelectSubset<T, AccessoryTypeUpsertArgs<ExtArgs>>): Prisma__AccessoryTypeClient<$Result.GetResult<Prisma.$AccessoryTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AccessoryTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessoryTypeCountArgs} args - Arguments to filter AccessoryTypes to count.
     * @example
     * // Count the number of AccessoryTypes
     * const count = await prisma.accessoryType.count({
     *   where: {
     *     // ... the filter for the AccessoryTypes we want to count
     *   }
     * })
    **/
    count<T extends AccessoryTypeCountArgs>(
      args?: Subset<T, AccessoryTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccessoryTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AccessoryType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessoryTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccessoryTypeAggregateArgs>(args: Subset<T, AccessoryTypeAggregateArgs>): Prisma.PrismaPromise<GetAccessoryTypeAggregateType<T>>

    /**
     * Group by AccessoryType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessoryTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccessoryTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccessoryTypeGroupByArgs['orderBy'] }
        : { orderBy?: AccessoryTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccessoryTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccessoryTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AccessoryType model
   */
  readonly fields: AccessoryTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AccessoryType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccessoryTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    AccessorySpecs<T extends AccessoryType$AccessorySpecsArgs<ExtArgs> = {}>(args?: Subset<T, AccessoryType$AccessorySpecsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccessorySpecsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AccessoryType model
   */
  interface AccessoryTypeFieldRefs {
    readonly id: FieldRef<"AccessoryType", 'Int'>
    readonly name: FieldRef<"AccessoryType", 'String'>
    readonly slug: FieldRef<"AccessoryType", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AccessoryType findUnique
   */
  export type AccessoryTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessoryType
     */
    select?: AccessoryTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessoryType
     */
    omit?: AccessoryTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessoryTypeInclude<ExtArgs> | null
    /**
     * Filter, which AccessoryType to fetch.
     */
    where: AccessoryTypeWhereUniqueInput
  }

  /**
   * AccessoryType findUniqueOrThrow
   */
  export type AccessoryTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessoryType
     */
    select?: AccessoryTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessoryType
     */
    omit?: AccessoryTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessoryTypeInclude<ExtArgs> | null
    /**
     * Filter, which AccessoryType to fetch.
     */
    where: AccessoryTypeWhereUniqueInput
  }

  /**
   * AccessoryType findFirst
   */
  export type AccessoryTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessoryType
     */
    select?: AccessoryTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessoryType
     */
    omit?: AccessoryTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessoryTypeInclude<ExtArgs> | null
    /**
     * Filter, which AccessoryType to fetch.
     */
    where?: AccessoryTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccessoryTypes to fetch.
     */
    orderBy?: AccessoryTypeOrderByWithRelationInput | AccessoryTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccessoryTypes.
     */
    cursor?: AccessoryTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccessoryTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccessoryTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccessoryTypes.
     */
    distinct?: AccessoryTypeScalarFieldEnum | AccessoryTypeScalarFieldEnum[]
  }

  /**
   * AccessoryType findFirstOrThrow
   */
  export type AccessoryTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessoryType
     */
    select?: AccessoryTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessoryType
     */
    omit?: AccessoryTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessoryTypeInclude<ExtArgs> | null
    /**
     * Filter, which AccessoryType to fetch.
     */
    where?: AccessoryTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccessoryTypes to fetch.
     */
    orderBy?: AccessoryTypeOrderByWithRelationInput | AccessoryTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccessoryTypes.
     */
    cursor?: AccessoryTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccessoryTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccessoryTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccessoryTypes.
     */
    distinct?: AccessoryTypeScalarFieldEnum | AccessoryTypeScalarFieldEnum[]
  }

  /**
   * AccessoryType findMany
   */
  export type AccessoryTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessoryType
     */
    select?: AccessoryTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessoryType
     */
    omit?: AccessoryTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessoryTypeInclude<ExtArgs> | null
    /**
     * Filter, which AccessoryTypes to fetch.
     */
    where?: AccessoryTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccessoryTypes to fetch.
     */
    orderBy?: AccessoryTypeOrderByWithRelationInput | AccessoryTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AccessoryTypes.
     */
    cursor?: AccessoryTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccessoryTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccessoryTypes.
     */
    skip?: number
    distinct?: AccessoryTypeScalarFieldEnum | AccessoryTypeScalarFieldEnum[]
  }

  /**
   * AccessoryType create
   */
  export type AccessoryTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessoryType
     */
    select?: AccessoryTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessoryType
     */
    omit?: AccessoryTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessoryTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a AccessoryType.
     */
    data: XOR<AccessoryTypeCreateInput, AccessoryTypeUncheckedCreateInput>
  }

  /**
   * AccessoryType createMany
   */
  export type AccessoryTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AccessoryTypes.
     */
    data: AccessoryTypeCreateManyInput | AccessoryTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AccessoryType createManyAndReturn
   */
  export type AccessoryTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessoryType
     */
    select?: AccessoryTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AccessoryType
     */
    omit?: AccessoryTypeOmit<ExtArgs> | null
    /**
     * The data used to create many AccessoryTypes.
     */
    data: AccessoryTypeCreateManyInput | AccessoryTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AccessoryType update
   */
  export type AccessoryTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessoryType
     */
    select?: AccessoryTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessoryType
     */
    omit?: AccessoryTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessoryTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a AccessoryType.
     */
    data: XOR<AccessoryTypeUpdateInput, AccessoryTypeUncheckedUpdateInput>
    /**
     * Choose, which AccessoryType to update.
     */
    where: AccessoryTypeWhereUniqueInput
  }

  /**
   * AccessoryType updateMany
   */
  export type AccessoryTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AccessoryTypes.
     */
    data: XOR<AccessoryTypeUpdateManyMutationInput, AccessoryTypeUncheckedUpdateManyInput>
    /**
     * Filter which AccessoryTypes to update
     */
    where?: AccessoryTypeWhereInput
    /**
     * Limit how many AccessoryTypes to update.
     */
    limit?: number
  }

  /**
   * AccessoryType updateManyAndReturn
   */
  export type AccessoryTypeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessoryType
     */
    select?: AccessoryTypeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AccessoryType
     */
    omit?: AccessoryTypeOmit<ExtArgs> | null
    /**
     * The data used to update AccessoryTypes.
     */
    data: XOR<AccessoryTypeUpdateManyMutationInput, AccessoryTypeUncheckedUpdateManyInput>
    /**
     * Filter which AccessoryTypes to update
     */
    where?: AccessoryTypeWhereInput
    /**
     * Limit how many AccessoryTypes to update.
     */
    limit?: number
  }

  /**
   * AccessoryType upsert
   */
  export type AccessoryTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessoryType
     */
    select?: AccessoryTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessoryType
     */
    omit?: AccessoryTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessoryTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the AccessoryType to update in case it exists.
     */
    where: AccessoryTypeWhereUniqueInput
    /**
     * In case the AccessoryType found by the `where` argument doesn't exist, create a new AccessoryType with this data.
     */
    create: XOR<AccessoryTypeCreateInput, AccessoryTypeUncheckedCreateInput>
    /**
     * In case the AccessoryType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccessoryTypeUpdateInput, AccessoryTypeUncheckedUpdateInput>
  }

  /**
   * AccessoryType delete
   */
  export type AccessoryTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessoryType
     */
    select?: AccessoryTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessoryType
     */
    omit?: AccessoryTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessoryTypeInclude<ExtArgs> | null
    /**
     * Filter which AccessoryType to delete.
     */
    where: AccessoryTypeWhereUniqueInput
  }

  /**
   * AccessoryType deleteMany
   */
  export type AccessoryTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccessoryTypes to delete
     */
    where?: AccessoryTypeWhereInput
    /**
     * Limit how many AccessoryTypes to delete.
     */
    limit?: number
  }

  /**
   * AccessoryType.AccessorySpecs
   */
  export type AccessoryType$AccessorySpecsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessorySpecs
     */
    select?: AccessorySpecsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessorySpecs
     */
    omit?: AccessorySpecsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessorySpecsInclude<ExtArgs> | null
    where?: AccessorySpecsWhereInput
    orderBy?: AccessorySpecsOrderByWithRelationInput | AccessorySpecsOrderByWithRelationInput[]
    cursor?: AccessorySpecsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccessorySpecsScalarFieldEnum | AccessorySpecsScalarFieldEnum[]
  }

  /**
   * AccessoryType without action
   */
  export type AccessoryTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessoryType
     */
    select?: AccessoryTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessoryType
     */
    omit?: AccessoryTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessoryTypeInclude<ExtArgs> | null
  }


  /**
   * Model Alert
   */

  export type AggregateAlert = {
    _count: AlertCountAggregateOutputType | null
    _avg: AlertAvgAggregateOutputType | null
    _sum: AlertSumAggregateOutputType | null
    _min: AlertMinAggregateOutputType | null
    _max: AlertMaxAggregateOutputType | null
  }

  export type AlertAvgAggregateOutputType = {
    calId: number | null
    targetCpr: number | null
  }

  export type AlertSumAggregateOutputType = {
    calId: number | null
    targetCpr: number | null
  }

  export type AlertMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.AlertType | null
    calId: number | null
    itemId: string | null
    keyword: string | null
    targetCpr: number | null
    excludeSteel: boolean | null
    excludeReman: boolean | null
    lastTriggered: Date | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type AlertMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.AlertType | null
    calId: number | null
    itemId: string | null
    keyword: string | null
    targetCpr: number | null
    excludeSteel: boolean | null
    excludeReman: boolean | null
    lastTriggered: Date | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type AlertCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    calId: number
    itemId: number
    keyword: number
    targetCpr: number
    excludeSteel: number
    excludeReman: number
    lastTriggered: number
    isActive: number
    createdAt: number
    _all: number
  }


  export type AlertAvgAggregateInputType = {
    calId?: true
    targetCpr?: true
  }

  export type AlertSumAggregateInputType = {
    calId?: true
    targetCpr?: true
  }

  export type AlertMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    calId?: true
    itemId?: true
    keyword?: true
    targetCpr?: true
    excludeSteel?: true
    excludeReman?: true
    lastTriggered?: true
    isActive?: true
    createdAt?: true
  }

  export type AlertMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    calId?: true
    itemId?: true
    keyword?: true
    targetCpr?: true
    excludeSteel?: true
    excludeReman?: true
    lastTriggered?: true
    isActive?: true
    createdAt?: true
  }

  export type AlertCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    calId?: true
    itemId?: true
    keyword?: true
    targetCpr?: true
    excludeSteel?: true
    excludeReman?: true
    lastTriggered?: true
    isActive?: true
    createdAt?: true
    _all?: true
  }

  export type AlertAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Alert to aggregate.
     */
    where?: AlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alerts to fetch.
     */
    orderBy?: AlertOrderByWithRelationInput | AlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Alerts
    **/
    _count?: true | AlertCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AlertAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AlertSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AlertMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AlertMaxAggregateInputType
  }

  export type GetAlertAggregateType<T extends AlertAggregateArgs> = {
        [P in keyof T & keyof AggregateAlert]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAlert[P]>
      : GetScalarType<T[P], AggregateAlert[P]>
  }




  export type AlertGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlertWhereInput
    orderBy?: AlertOrderByWithAggregationInput | AlertOrderByWithAggregationInput[]
    by: AlertScalarFieldEnum[] | AlertScalarFieldEnum
    having?: AlertScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AlertCountAggregateInputType | true
    _avg?: AlertAvgAggregateInputType
    _sum?: AlertSumAggregateInputType
    _min?: AlertMinAggregateInputType
    _max?: AlertMaxAggregateInputType
  }

  export type AlertGroupByOutputType = {
    id: string
    userId: string
    type: $Enums.AlertType
    calId: number | null
    itemId: string | null
    keyword: string | null
    targetCpr: number | null
    excludeSteel: boolean | null
    excludeReman: boolean | null
    lastTriggered: Date | null
    isActive: boolean | null
    createdAt: Date | null
    _count: AlertCountAggregateOutputType | null
    _avg: AlertAvgAggregateOutputType | null
    _sum: AlertSumAggregateOutputType | null
    _min: AlertMinAggregateOutputType | null
    _max: AlertMaxAggregateOutputType | null
  }

  type GetAlertGroupByPayload<T extends AlertGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AlertGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AlertGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AlertGroupByOutputType[P]>
            : GetScalarType<T[P], AlertGroupByOutputType[P]>
        }
      >
    >


  export type AlertSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    calId?: boolean
    itemId?: boolean
    keyword?: boolean
    targetCpr?: boolean
    excludeSteel?: boolean
    excludeReman?: boolean
    lastTriggered?: boolean
    isActive?: boolean
    createdAt?: boolean
    Caliber?: boolean | Alert$CaliberArgs<ExtArgs>
    CatalogItem?: boolean | Alert$CatalogItemArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
    AlertDelivery?: boolean | Alert$AlertDeliveryArgs<ExtArgs>
    _count?: boolean | AlertCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["alert"]>

  export type AlertSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    calId?: boolean
    itemId?: boolean
    keyword?: boolean
    targetCpr?: boolean
    excludeSteel?: boolean
    excludeReman?: boolean
    lastTriggered?: boolean
    isActive?: boolean
    createdAt?: boolean
    Caliber?: boolean | Alert$CaliberArgs<ExtArgs>
    CatalogItem?: boolean | Alert$CatalogItemArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["alert"]>

  export type AlertSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    calId?: boolean
    itemId?: boolean
    keyword?: boolean
    targetCpr?: boolean
    excludeSteel?: boolean
    excludeReman?: boolean
    lastTriggered?: boolean
    isActive?: boolean
    createdAt?: boolean
    Caliber?: boolean | Alert$CaliberArgs<ExtArgs>
    CatalogItem?: boolean | Alert$CatalogItemArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["alert"]>

  export type AlertSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    calId?: boolean
    itemId?: boolean
    keyword?: boolean
    targetCpr?: boolean
    excludeSteel?: boolean
    excludeReman?: boolean
    lastTriggered?: boolean
    isActive?: boolean
    createdAt?: boolean
  }

  export type AlertOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "calId" | "itemId" | "keyword" | "targetCpr" | "excludeSteel" | "excludeReman" | "lastTriggered" | "isActive" | "createdAt", ExtArgs["result"]["alert"]>
  export type AlertInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Caliber?: boolean | Alert$CaliberArgs<ExtArgs>
    CatalogItem?: boolean | Alert$CatalogItemArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
    AlertDelivery?: boolean | Alert$AlertDeliveryArgs<ExtArgs>
    _count?: boolean | AlertCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AlertIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Caliber?: boolean | Alert$CaliberArgs<ExtArgs>
    CatalogItem?: boolean | Alert$CatalogItemArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AlertIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Caliber?: boolean | Alert$CaliberArgs<ExtArgs>
    CatalogItem?: boolean | Alert$CatalogItemArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AlertPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Alert"
    objects: {
      Caliber: Prisma.$CaliberPayload<ExtArgs> | null
      CatalogItem: Prisma.$CatalogItemPayload<ExtArgs> | null
      User: Prisma.$UserPayload<ExtArgs>
      AlertDelivery: Prisma.$AlertDeliveryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: $Enums.AlertType
      calId: number | null
      itemId: string | null
      keyword: string | null
      targetCpr: number | null
      excludeSteel: boolean | null
      excludeReman: boolean | null
      lastTriggered: Date | null
      isActive: boolean | null
      createdAt: Date | null
    }, ExtArgs["result"]["alert"]>
    composites: {}
  }

  type AlertGetPayload<S extends boolean | null | undefined | AlertDefaultArgs> = $Result.GetResult<Prisma.$AlertPayload, S>

  type AlertCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AlertFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AlertCountAggregateInputType | true
    }

  export interface AlertDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Alert'], meta: { name: 'Alert' } }
    /**
     * Find zero or one Alert that matches the filter.
     * @param {AlertFindUniqueArgs} args - Arguments to find a Alert
     * @example
     * // Get one Alert
     * const alert = await prisma.alert.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AlertFindUniqueArgs>(args: SelectSubset<T, AlertFindUniqueArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Alert that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AlertFindUniqueOrThrowArgs} args - Arguments to find a Alert
     * @example
     * // Get one Alert
     * const alert = await prisma.alert.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AlertFindUniqueOrThrowArgs>(args: SelectSubset<T, AlertFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Alert that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertFindFirstArgs} args - Arguments to find a Alert
     * @example
     * // Get one Alert
     * const alert = await prisma.alert.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AlertFindFirstArgs>(args?: SelectSubset<T, AlertFindFirstArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Alert that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertFindFirstOrThrowArgs} args - Arguments to find a Alert
     * @example
     * // Get one Alert
     * const alert = await prisma.alert.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AlertFindFirstOrThrowArgs>(args?: SelectSubset<T, AlertFindFirstOrThrowArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Alerts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Alerts
     * const alerts = await prisma.alert.findMany()
     * 
     * // Get first 10 Alerts
     * const alerts = await prisma.alert.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const alertWithIdOnly = await prisma.alert.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AlertFindManyArgs>(args?: SelectSubset<T, AlertFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Alert.
     * @param {AlertCreateArgs} args - Arguments to create a Alert.
     * @example
     * // Create one Alert
     * const Alert = await prisma.alert.create({
     *   data: {
     *     // ... data to create a Alert
     *   }
     * })
     * 
     */
    create<T extends AlertCreateArgs>(args: SelectSubset<T, AlertCreateArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Alerts.
     * @param {AlertCreateManyArgs} args - Arguments to create many Alerts.
     * @example
     * // Create many Alerts
     * const alert = await prisma.alert.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AlertCreateManyArgs>(args?: SelectSubset<T, AlertCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Alerts and returns the data saved in the database.
     * @param {AlertCreateManyAndReturnArgs} args - Arguments to create many Alerts.
     * @example
     * // Create many Alerts
     * const alert = await prisma.alert.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Alerts and only return the `id`
     * const alertWithIdOnly = await prisma.alert.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AlertCreateManyAndReturnArgs>(args?: SelectSubset<T, AlertCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Alert.
     * @param {AlertDeleteArgs} args - Arguments to delete one Alert.
     * @example
     * // Delete one Alert
     * const Alert = await prisma.alert.delete({
     *   where: {
     *     // ... filter to delete one Alert
     *   }
     * })
     * 
     */
    delete<T extends AlertDeleteArgs>(args: SelectSubset<T, AlertDeleteArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Alert.
     * @param {AlertUpdateArgs} args - Arguments to update one Alert.
     * @example
     * // Update one Alert
     * const alert = await prisma.alert.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AlertUpdateArgs>(args: SelectSubset<T, AlertUpdateArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Alerts.
     * @param {AlertDeleteManyArgs} args - Arguments to filter Alerts to delete.
     * @example
     * // Delete a few Alerts
     * const { count } = await prisma.alert.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AlertDeleteManyArgs>(args?: SelectSubset<T, AlertDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Alerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Alerts
     * const alert = await prisma.alert.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AlertUpdateManyArgs>(args: SelectSubset<T, AlertUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Alerts and returns the data updated in the database.
     * @param {AlertUpdateManyAndReturnArgs} args - Arguments to update many Alerts.
     * @example
     * // Update many Alerts
     * const alert = await prisma.alert.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Alerts and only return the `id`
     * const alertWithIdOnly = await prisma.alert.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AlertUpdateManyAndReturnArgs>(args: SelectSubset<T, AlertUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Alert.
     * @param {AlertUpsertArgs} args - Arguments to update or create a Alert.
     * @example
     * // Update or create a Alert
     * const alert = await prisma.alert.upsert({
     *   create: {
     *     // ... data to create a Alert
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Alert we want to update
     *   }
     * })
     */
    upsert<T extends AlertUpsertArgs>(args: SelectSubset<T, AlertUpsertArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Alerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertCountArgs} args - Arguments to filter Alerts to count.
     * @example
     * // Count the number of Alerts
     * const count = await prisma.alert.count({
     *   where: {
     *     // ... the filter for the Alerts we want to count
     *   }
     * })
    **/
    count<T extends AlertCountArgs>(
      args?: Subset<T, AlertCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AlertCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Alert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AlertAggregateArgs>(args: Subset<T, AlertAggregateArgs>): Prisma.PrismaPromise<GetAlertAggregateType<T>>

    /**
     * Group by Alert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AlertGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AlertGroupByArgs['orderBy'] }
        : { orderBy?: AlertGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AlertGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAlertGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Alert model
   */
  readonly fields: AlertFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Alert.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AlertClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Caliber<T extends Alert$CaliberArgs<ExtArgs> = {}>(args?: Subset<T, Alert$CaliberArgs<ExtArgs>>): Prisma__CaliberClient<$Result.GetResult<Prisma.$CaliberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    CatalogItem<T extends Alert$CatalogItemArgs<ExtArgs> = {}>(args?: Subset<T, Alert$CatalogItemArgs<ExtArgs>>): Prisma__CatalogItemClient<$Result.GetResult<Prisma.$CatalogItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    AlertDelivery<T extends Alert$AlertDeliveryArgs<ExtArgs> = {}>(args?: Subset<T, Alert$AlertDeliveryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertDeliveryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Alert model
   */
  interface AlertFieldRefs {
    readonly id: FieldRef<"Alert", 'String'>
    readonly userId: FieldRef<"Alert", 'String'>
    readonly type: FieldRef<"Alert", 'AlertType'>
    readonly calId: FieldRef<"Alert", 'Int'>
    readonly itemId: FieldRef<"Alert", 'String'>
    readonly keyword: FieldRef<"Alert", 'String'>
    readonly targetCpr: FieldRef<"Alert", 'Float'>
    readonly excludeSteel: FieldRef<"Alert", 'Boolean'>
    readonly excludeReman: FieldRef<"Alert", 'Boolean'>
    readonly lastTriggered: FieldRef<"Alert", 'DateTime'>
    readonly isActive: FieldRef<"Alert", 'Boolean'>
    readonly createdAt: FieldRef<"Alert", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Alert findUnique
   */
  export type AlertFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter, which Alert to fetch.
     */
    where: AlertWhereUniqueInput
  }

  /**
   * Alert findUniqueOrThrow
   */
  export type AlertFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter, which Alert to fetch.
     */
    where: AlertWhereUniqueInput
  }

  /**
   * Alert findFirst
   */
  export type AlertFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter, which Alert to fetch.
     */
    where?: AlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alerts to fetch.
     */
    orderBy?: AlertOrderByWithRelationInput | AlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Alerts.
     */
    cursor?: AlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Alerts.
     */
    distinct?: AlertScalarFieldEnum | AlertScalarFieldEnum[]
  }

  /**
   * Alert findFirstOrThrow
   */
  export type AlertFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter, which Alert to fetch.
     */
    where?: AlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alerts to fetch.
     */
    orderBy?: AlertOrderByWithRelationInput | AlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Alerts.
     */
    cursor?: AlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Alerts.
     */
    distinct?: AlertScalarFieldEnum | AlertScalarFieldEnum[]
  }

  /**
   * Alert findMany
   */
  export type AlertFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter, which Alerts to fetch.
     */
    where?: AlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alerts to fetch.
     */
    orderBy?: AlertOrderByWithRelationInput | AlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Alerts.
     */
    cursor?: AlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alerts.
     */
    skip?: number
    distinct?: AlertScalarFieldEnum | AlertScalarFieldEnum[]
  }

  /**
   * Alert create
   */
  export type AlertCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * The data needed to create a Alert.
     */
    data: XOR<AlertCreateInput, AlertUncheckedCreateInput>
  }

  /**
   * Alert createMany
   */
  export type AlertCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Alerts.
     */
    data: AlertCreateManyInput | AlertCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Alert createManyAndReturn
   */
  export type AlertCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * The data used to create many Alerts.
     */
    data: AlertCreateManyInput | AlertCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Alert update
   */
  export type AlertUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * The data needed to update a Alert.
     */
    data: XOR<AlertUpdateInput, AlertUncheckedUpdateInput>
    /**
     * Choose, which Alert to update.
     */
    where: AlertWhereUniqueInput
  }

  /**
   * Alert updateMany
   */
  export type AlertUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Alerts.
     */
    data: XOR<AlertUpdateManyMutationInput, AlertUncheckedUpdateManyInput>
    /**
     * Filter which Alerts to update
     */
    where?: AlertWhereInput
    /**
     * Limit how many Alerts to update.
     */
    limit?: number
  }

  /**
   * Alert updateManyAndReturn
   */
  export type AlertUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * The data used to update Alerts.
     */
    data: XOR<AlertUpdateManyMutationInput, AlertUncheckedUpdateManyInput>
    /**
     * Filter which Alerts to update
     */
    where?: AlertWhereInput
    /**
     * Limit how many Alerts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Alert upsert
   */
  export type AlertUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * The filter to search for the Alert to update in case it exists.
     */
    where: AlertWhereUniqueInput
    /**
     * In case the Alert found by the `where` argument doesn't exist, create a new Alert with this data.
     */
    create: XOR<AlertCreateInput, AlertUncheckedCreateInput>
    /**
     * In case the Alert was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AlertUpdateInput, AlertUncheckedUpdateInput>
  }

  /**
   * Alert delete
   */
  export type AlertDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter which Alert to delete.
     */
    where: AlertWhereUniqueInput
  }

  /**
   * Alert deleteMany
   */
  export type AlertDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Alerts to delete
     */
    where?: AlertWhereInput
    /**
     * Limit how many Alerts to delete.
     */
    limit?: number
  }

  /**
   * Alert.Caliber
   */
  export type Alert$CaliberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Caliber
     */
    select?: CaliberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Caliber
     */
    omit?: CaliberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaliberInclude<ExtArgs> | null
    where?: CaliberWhereInput
  }

  /**
   * Alert.CatalogItem
   */
  export type Alert$CatalogItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogItem
     */
    select?: CatalogItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CatalogItem
     */
    omit?: CatalogItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogItemInclude<ExtArgs> | null
    where?: CatalogItemWhereInput
  }

  /**
   * Alert.AlertDelivery
   */
  export type Alert$AlertDeliveryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertDelivery
     */
    select?: AlertDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlertDelivery
     */
    omit?: AlertDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertDeliveryInclude<ExtArgs> | null
    where?: AlertDeliveryWhereInput
    orderBy?: AlertDeliveryOrderByWithRelationInput | AlertDeliveryOrderByWithRelationInput[]
    cursor?: AlertDeliveryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AlertDeliveryScalarFieldEnum | AlertDeliveryScalarFieldEnum[]
  }

  /**
   * Alert without action
   */
  export type AlertDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
  }


  /**
   * Model AlertDelivery
   */

  export type AggregateAlertDelivery = {
    _count: AlertDeliveryCountAggregateOutputType | null
    _avg: AlertDeliveryAvgAggregateOutputType | null
    _sum: AlertDeliverySumAggregateOutputType | null
    _min: AlertDeliveryMinAggregateOutputType | null
    _max: AlertDeliveryMaxAggregateOutputType | null
  }

  export type AlertDeliveryAvgAggregateOutputType = {
    offerId: number | null
  }

  export type AlertDeliverySumAggregateOutputType = {
    offerId: number | null
  }

  export type AlertDeliveryMinAggregateOutputType = {
    id: string | null
    alertId: string | null
    offerId: number | null
    sentAt: Date | null
    fingerprint: string | null
    userId: string | null
  }

  export type AlertDeliveryMaxAggregateOutputType = {
    id: string | null
    alertId: string | null
    offerId: number | null
    sentAt: Date | null
    fingerprint: string | null
    userId: string | null
  }

  export type AlertDeliveryCountAggregateOutputType = {
    id: number
    alertId: number
    offerId: number
    sentAt: number
    fingerprint: number
    userId: number
    _all: number
  }


  export type AlertDeliveryAvgAggregateInputType = {
    offerId?: true
  }

  export type AlertDeliverySumAggregateInputType = {
    offerId?: true
  }

  export type AlertDeliveryMinAggregateInputType = {
    id?: true
    alertId?: true
    offerId?: true
    sentAt?: true
    fingerprint?: true
    userId?: true
  }

  export type AlertDeliveryMaxAggregateInputType = {
    id?: true
    alertId?: true
    offerId?: true
    sentAt?: true
    fingerprint?: true
    userId?: true
  }

  export type AlertDeliveryCountAggregateInputType = {
    id?: true
    alertId?: true
    offerId?: true
    sentAt?: true
    fingerprint?: true
    userId?: true
    _all?: true
  }

  export type AlertDeliveryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AlertDelivery to aggregate.
     */
    where?: AlertDeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlertDeliveries to fetch.
     */
    orderBy?: AlertDeliveryOrderByWithRelationInput | AlertDeliveryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AlertDeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlertDeliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlertDeliveries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AlertDeliveries
    **/
    _count?: true | AlertDeliveryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AlertDeliveryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AlertDeliverySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AlertDeliveryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AlertDeliveryMaxAggregateInputType
  }

  export type GetAlertDeliveryAggregateType<T extends AlertDeliveryAggregateArgs> = {
        [P in keyof T & keyof AggregateAlertDelivery]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAlertDelivery[P]>
      : GetScalarType<T[P], AggregateAlertDelivery[P]>
  }




  export type AlertDeliveryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlertDeliveryWhereInput
    orderBy?: AlertDeliveryOrderByWithAggregationInput | AlertDeliveryOrderByWithAggregationInput[]
    by: AlertDeliveryScalarFieldEnum[] | AlertDeliveryScalarFieldEnum
    having?: AlertDeliveryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AlertDeliveryCountAggregateInputType | true
    _avg?: AlertDeliveryAvgAggregateInputType
    _sum?: AlertDeliverySumAggregateInputType
    _min?: AlertDeliveryMinAggregateInputType
    _max?: AlertDeliveryMaxAggregateInputType
  }

  export type AlertDeliveryGroupByOutputType = {
    id: string
    alertId: string
    offerId: number | null
    sentAt: Date | null
    fingerprint: string
    userId: string
    _count: AlertDeliveryCountAggregateOutputType | null
    _avg: AlertDeliveryAvgAggregateOutputType | null
    _sum: AlertDeliverySumAggregateOutputType | null
    _min: AlertDeliveryMinAggregateOutputType | null
    _max: AlertDeliveryMaxAggregateOutputType | null
  }

  type GetAlertDeliveryGroupByPayload<T extends AlertDeliveryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AlertDeliveryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AlertDeliveryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AlertDeliveryGroupByOutputType[P]>
            : GetScalarType<T[P], AlertDeliveryGroupByOutputType[P]>
        }
      >
    >


  export type AlertDeliverySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    alertId?: boolean
    offerId?: boolean
    sentAt?: boolean
    fingerprint?: boolean
    userId?: boolean
    Alert?: boolean | AlertDefaultArgs<ExtArgs>
    Offer?: boolean | AlertDelivery$OfferArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["alertDelivery"]>

  export type AlertDeliverySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    alertId?: boolean
    offerId?: boolean
    sentAt?: boolean
    fingerprint?: boolean
    userId?: boolean
    Alert?: boolean | AlertDefaultArgs<ExtArgs>
    Offer?: boolean | AlertDelivery$OfferArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["alertDelivery"]>

  export type AlertDeliverySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    alertId?: boolean
    offerId?: boolean
    sentAt?: boolean
    fingerprint?: boolean
    userId?: boolean
    Alert?: boolean | AlertDefaultArgs<ExtArgs>
    Offer?: boolean | AlertDelivery$OfferArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["alertDelivery"]>

  export type AlertDeliverySelectScalar = {
    id?: boolean
    alertId?: boolean
    offerId?: boolean
    sentAt?: boolean
    fingerprint?: boolean
    userId?: boolean
  }

  export type AlertDeliveryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "alertId" | "offerId" | "sentAt" | "fingerprint" | "userId", ExtArgs["result"]["alertDelivery"]>
  export type AlertDeliveryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Alert?: boolean | AlertDefaultArgs<ExtArgs>
    Offer?: boolean | AlertDelivery$OfferArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AlertDeliveryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Alert?: boolean | AlertDefaultArgs<ExtArgs>
    Offer?: boolean | AlertDelivery$OfferArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AlertDeliveryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Alert?: boolean | AlertDefaultArgs<ExtArgs>
    Offer?: boolean | AlertDelivery$OfferArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AlertDeliveryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AlertDelivery"
    objects: {
      Alert: Prisma.$AlertPayload<ExtArgs>
      Offer: Prisma.$OfferPayload<ExtArgs> | null
      User: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      alertId: string
      offerId: number | null
      sentAt: Date | null
      fingerprint: string
      userId: string
    }, ExtArgs["result"]["alertDelivery"]>
    composites: {}
  }

  type AlertDeliveryGetPayload<S extends boolean | null | undefined | AlertDeliveryDefaultArgs> = $Result.GetResult<Prisma.$AlertDeliveryPayload, S>

  type AlertDeliveryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AlertDeliveryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AlertDeliveryCountAggregateInputType | true
    }

  export interface AlertDeliveryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AlertDelivery'], meta: { name: 'AlertDelivery' } }
    /**
     * Find zero or one AlertDelivery that matches the filter.
     * @param {AlertDeliveryFindUniqueArgs} args - Arguments to find a AlertDelivery
     * @example
     * // Get one AlertDelivery
     * const alertDelivery = await prisma.alertDelivery.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AlertDeliveryFindUniqueArgs>(args: SelectSubset<T, AlertDeliveryFindUniqueArgs<ExtArgs>>): Prisma__AlertDeliveryClient<$Result.GetResult<Prisma.$AlertDeliveryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AlertDelivery that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AlertDeliveryFindUniqueOrThrowArgs} args - Arguments to find a AlertDelivery
     * @example
     * // Get one AlertDelivery
     * const alertDelivery = await prisma.alertDelivery.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AlertDeliveryFindUniqueOrThrowArgs>(args: SelectSubset<T, AlertDeliveryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AlertDeliveryClient<$Result.GetResult<Prisma.$AlertDeliveryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AlertDelivery that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertDeliveryFindFirstArgs} args - Arguments to find a AlertDelivery
     * @example
     * // Get one AlertDelivery
     * const alertDelivery = await prisma.alertDelivery.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AlertDeliveryFindFirstArgs>(args?: SelectSubset<T, AlertDeliveryFindFirstArgs<ExtArgs>>): Prisma__AlertDeliveryClient<$Result.GetResult<Prisma.$AlertDeliveryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AlertDelivery that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertDeliveryFindFirstOrThrowArgs} args - Arguments to find a AlertDelivery
     * @example
     * // Get one AlertDelivery
     * const alertDelivery = await prisma.alertDelivery.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AlertDeliveryFindFirstOrThrowArgs>(args?: SelectSubset<T, AlertDeliveryFindFirstOrThrowArgs<ExtArgs>>): Prisma__AlertDeliveryClient<$Result.GetResult<Prisma.$AlertDeliveryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AlertDeliveries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertDeliveryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AlertDeliveries
     * const alertDeliveries = await prisma.alertDelivery.findMany()
     * 
     * // Get first 10 AlertDeliveries
     * const alertDeliveries = await prisma.alertDelivery.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const alertDeliveryWithIdOnly = await prisma.alertDelivery.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AlertDeliveryFindManyArgs>(args?: SelectSubset<T, AlertDeliveryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertDeliveryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AlertDelivery.
     * @param {AlertDeliveryCreateArgs} args - Arguments to create a AlertDelivery.
     * @example
     * // Create one AlertDelivery
     * const AlertDelivery = await prisma.alertDelivery.create({
     *   data: {
     *     // ... data to create a AlertDelivery
     *   }
     * })
     * 
     */
    create<T extends AlertDeliveryCreateArgs>(args: SelectSubset<T, AlertDeliveryCreateArgs<ExtArgs>>): Prisma__AlertDeliveryClient<$Result.GetResult<Prisma.$AlertDeliveryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AlertDeliveries.
     * @param {AlertDeliveryCreateManyArgs} args - Arguments to create many AlertDeliveries.
     * @example
     * // Create many AlertDeliveries
     * const alertDelivery = await prisma.alertDelivery.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AlertDeliveryCreateManyArgs>(args?: SelectSubset<T, AlertDeliveryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AlertDeliveries and returns the data saved in the database.
     * @param {AlertDeliveryCreateManyAndReturnArgs} args - Arguments to create many AlertDeliveries.
     * @example
     * // Create many AlertDeliveries
     * const alertDelivery = await prisma.alertDelivery.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AlertDeliveries and only return the `id`
     * const alertDeliveryWithIdOnly = await prisma.alertDelivery.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AlertDeliveryCreateManyAndReturnArgs>(args?: SelectSubset<T, AlertDeliveryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertDeliveryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AlertDelivery.
     * @param {AlertDeliveryDeleteArgs} args - Arguments to delete one AlertDelivery.
     * @example
     * // Delete one AlertDelivery
     * const AlertDelivery = await prisma.alertDelivery.delete({
     *   where: {
     *     // ... filter to delete one AlertDelivery
     *   }
     * })
     * 
     */
    delete<T extends AlertDeliveryDeleteArgs>(args: SelectSubset<T, AlertDeliveryDeleteArgs<ExtArgs>>): Prisma__AlertDeliveryClient<$Result.GetResult<Prisma.$AlertDeliveryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AlertDelivery.
     * @param {AlertDeliveryUpdateArgs} args - Arguments to update one AlertDelivery.
     * @example
     * // Update one AlertDelivery
     * const alertDelivery = await prisma.alertDelivery.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AlertDeliveryUpdateArgs>(args: SelectSubset<T, AlertDeliveryUpdateArgs<ExtArgs>>): Prisma__AlertDeliveryClient<$Result.GetResult<Prisma.$AlertDeliveryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AlertDeliveries.
     * @param {AlertDeliveryDeleteManyArgs} args - Arguments to filter AlertDeliveries to delete.
     * @example
     * // Delete a few AlertDeliveries
     * const { count } = await prisma.alertDelivery.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AlertDeliveryDeleteManyArgs>(args?: SelectSubset<T, AlertDeliveryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AlertDeliveries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertDeliveryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AlertDeliveries
     * const alertDelivery = await prisma.alertDelivery.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AlertDeliveryUpdateManyArgs>(args: SelectSubset<T, AlertDeliveryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AlertDeliveries and returns the data updated in the database.
     * @param {AlertDeliveryUpdateManyAndReturnArgs} args - Arguments to update many AlertDeliveries.
     * @example
     * // Update many AlertDeliveries
     * const alertDelivery = await prisma.alertDelivery.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AlertDeliveries and only return the `id`
     * const alertDeliveryWithIdOnly = await prisma.alertDelivery.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AlertDeliveryUpdateManyAndReturnArgs>(args: SelectSubset<T, AlertDeliveryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertDeliveryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AlertDelivery.
     * @param {AlertDeliveryUpsertArgs} args - Arguments to update or create a AlertDelivery.
     * @example
     * // Update or create a AlertDelivery
     * const alertDelivery = await prisma.alertDelivery.upsert({
     *   create: {
     *     // ... data to create a AlertDelivery
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AlertDelivery we want to update
     *   }
     * })
     */
    upsert<T extends AlertDeliveryUpsertArgs>(args: SelectSubset<T, AlertDeliveryUpsertArgs<ExtArgs>>): Prisma__AlertDeliveryClient<$Result.GetResult<Prisma.$AlertDeliveryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AlertDeliveries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertDeliveryCountArgs} args - Arguments to filter AlertDeliveries to count.
     * @example
     * // Count the number of AlertDeliveries
     * const count = await prisma.alertDelivery.count({
     *   where: {
     *     // ... the filter for the AlertDeliveries we want to count
     *   }
     * })
    **/
    count<T extends AlertDeliveryCountArgs>(
      args?: Subset<T, AlertDeliveryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AlertDeliveryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AlertDelivery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertDeliveryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AlertDeliveryAggregateArgs>(args: Subset<T, AlertDeliveryAggregateArgs>): Prisma.PrismaPromise<GetAlertDeliveryAggregateType<T>>

    /**
     * Group by AlertDelivery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertDeliveryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AlertDeliveryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AlertDeliveryGroupByArgs['orderBy'] }
        : { orderBy?: AlertDeliveryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AlertDeliveryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAlertDeliveryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AlertDelivery model
   */
  readonly fields: AlertDeliveryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AlertDelivery.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AlertDeliveryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Alert<T extends AlertDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AlertDefaultArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Offer<T extends AlertDelivery$OfferArgs<ExtArgs> = {}>(args?: Subset<T, AlertDelivery$OfferArgs<ExtArgs>>): Prisma__OfferClient<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AlertDelivery model
   */
  interface AlertDeliveryFieldRefs {
    readonly id: FieldRef<"AlertDelivery", 'String'>
    readonly alertId: FieldRef<"AlertDelivery", 'String'>
    readonly offerId: FieldRef<"AlertDelivery", 'Int'>
    readonly sentAt: FieldRef<"AlertDelivery", 'DateTime'>
    readonly fingerprint: FieldRef<"AlertDelivery", 'String'>
    readonly userId: FieldRef<"AlertDelivery", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AlertDelivery findUnique
   */
  export type AlertDeliveryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertDelivery
     */
    select?: AlertDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlertDelivery
     */
    omit?: AlertDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertDeliveryInclude<ExtArgs> | null
    /**
     * Filter, which AlertDelivery to fetch.
     */
    where: AlertDeliveryWhereUniqueInput
  }

  /**
   * AlertDelivery findUniqueOrThrow
   */
  export type AlertDeliveryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertDelivery
     */
    select?: AlertDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlertDelivery
     */
    omit?: AlertDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertDeliveryInclude<ExtArgs> | null
    /**
     * Filter, which AlertDelivery to fetch.
     */
    where: AlertDeliveryWhereUniqueInput
  }

  /**
   * AlertDelivery findFirst
   */
  export type AlertDeliveryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertDelivery
     */
    select?: AlertDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlertDelivery
     */
    omit?: AlertDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertDeliveryInclude<ExtArgs> | null
    /**
     * Filter, which AlertDelivery to fetch.
     */
    where?: AlertDeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlertDeliveries to fetch.
     */
    orderBy?: AlertDeliveryOrderByWithRelationInput | AlertDeliveryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AlertDeliveries.
     */
    cursor?: AlertDeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlertDeliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlertDeliveries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AlertDeliveries.
     */
    distinct?: AlertDeliveryScalarFieldEnum | AlertDeliveryScalarFieldEnum[]
  }

  /**
   * AlertDelivery findFirstOrThrow
   */
  export type AlertDeliveryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertDelivery
     */
    select?: AlertDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlertDelivery
     */
    omit?: AlertDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertDeliveryInclude<ExtArgs> | null
    /**
     * Filter, which AlertDelivery to fetch.
     */
    where?: AlertDeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlertDeliveries to fetch.
     */
    orderBy?: AlertDeliveryOrderByWithRelationInput | AlertDeliveryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AlertDeliveries.
     */
    cursor?: AlertDeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlertDeliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlertDeliveries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AlertDeliveries.
     */
    distinct?: AlertDeliveryScalarFieldEnum | AlertDeliveryScalarFieldEnum[]
  }

  /**
   * AlertDelivery findMany
   */
  export type AlertDeliveryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertDelivery
     */
    select?: AlertDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlertDelivery
     */
    omit?: AlertDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertDeliveryInclude<ExtArgs> | null
    /**
     * Filter, which AlertDeliveries to fetch.
     */
    where?: AlertDeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlertDeliveries to fetch.
     */
    orderBy?: AlertDeliveryOrderByWithRelationInput | AlertDeliveryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AlertDeliveries.
     */
    cursor?: AlertDeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlertDeliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlertDeliveries.
     */
    skip?: number
    distinct?: AlertDeliveryScalarFieldEnum | AlertDeliveryScalarFieldEnum[]
  }

  /**
   * AlertDelivery create
   */
  export type AlertDeliveryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertDelivery
     */
    select?: AlertDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlertDelivery
     */
    omit?: AlertDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertDeliveryInclude<ExtArgs> | null
    /**
     * The data needed to create a AlertDelivery.
     */
    data: XOR<AlertDeliveryCreateInput, AlertDeliveryUncheckedCreateInput>
  }

  /**
   * AlertDelivery createMany
   */
  export type AlertDeliveryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AlertDeliveries.
     */
    data: AlertDeliveryCreateManyInput | AlertDeliveryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AlertDelivery createManyAndReturn
   */
  export type AlertDeliveryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertDelivery
     */
    select?: AlertDeliverySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AlertDelivery
     */
    omit?: AlertDeliveryOmit<ExtArgs> | null
    /**
     * The data used to create many AlertDeliveries.
     */
    data: AlertDeliveryCreateManyInput | AlertDeliveryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertDeliveryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AlertDelivery update
   */
  export type AlertDeliveryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertDelivery
     */
    select?: AlertDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlertDelivery
     */
    omit?: AlertDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertDeliveryInclude<ExtArgs> | null
    /**
     * The data needed to update a AlertDelivery.
     */
    data: XOR<AlertDeliveryUpdateInput, AlertDeliveryUncheckedUpdateInput>
    /**
     * Choose, which AlertDelivery to update.
     */
    where: AlertDeliveryWhereUniqueInput
  }

  /**
   * AlertDelivery updateMany
   */
  export type AlertDeliveryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AlertDeliveries.
     */
    data: XOR<AlertDeliveryUpdateManyMutationInput, AlertDeliveryUncheckedUpdateManyInput>
    /**
     * Filter which AlertDeliveries to update
     */
    where?: AlertDeliveryWhereInput
    /**
     * Limit how many AlertDeliveries to update.
     */
    limit?: number
  }

  /**
   * AlertDelivery updateManyAndReturn
   */
  export type AlertDeliveryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertDelivery
     */
    select?: AlertDeliverySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AlertDelivery
     */
    omit?: AlertDeliveryOmit<ExtArgs> | null
    /**
     * The data used to update AlertDeliveries.
     */
    data: XOR<AlertDeliveryUpdateManyMutationInput, AlertDeliveryUncheckedUpdateManyInput>
    /**
     * Filter which AlertDeliveries to update
     */
    where?: AlertDeliveryWhereInput
    /**
     * Limit how many AlertDeliveries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertDeliveryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AlertDelivery upsert
   */
  export type AlertDeliveryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertDelivery
     */
    select?: AlertDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlertDelivery
     */
    omit?: AlertDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertDeliveryInclude<ExtArgs> | null
    /**
     * The filter to search for the AlertDelivery to update in case it exists.
     */
    where: AlertDeliveryWhereUniqueInput
    /**
     * In case the AlertDelivery found by the `where` argument doesn't exist, create a new AlertDelivery with this data.
     */
    create: XOR<AlertDeliveryCreateInput, AlertDeliveryUncheckedCreateInput>
    /**
     * In case the AlertDelivery was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AlertDeliveryUpdateInput, AlertDeliveryUncheckedUpdateInput>
  }

  /**
   * AlertDelivery delete
   */
  export type AlertDeliveryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertDelivery
     */
    select?: AlertDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlertDelivery
     */
    omit?: AlertDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertDeliveryInclude<ExtArgs> | null
    /**
     * Filter which AlertDelivery to delete.
     */
    where: AlertDeliveryWhereUniqueInput
  }

  /**
   * AlertDelivery deleteMany
   */
  export type AlertDeliveryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AlertDeliveries to delete
     */
    where?: AlertDeliveryWhereInput
    /**
     * Limit how many AlertDeliveries to delete.
     */
    limit?: number
  }

  /**
   * AlertDelivery.Offer
   */
  export type AlertDelivery$OfferArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Offer
     */
    omit?: OfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    where?: OfferWhereInput
  }

  /**
   * AlertDelivery without action
   */
  export type AlertDeliveryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertDelivery
     */
    select?: AlertDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlertDelivery
     */
    omit?: AlertDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertDeliveryInclude<ExtArgs> | null
  }


  /**
   * Model AmmoSpecs
   */

  export type AggregateAmmoSpecs = {
    _count: AmmoSpecsCountAggregateOutputType | null
    _avg: AmmoSpecsAvgAggregateOutputType | null
    _sum: AmmoSpecsSumAggregateOutputType | null
    _min: AmmoSpecsMinAggregateOutputType | null
    _max: AmmoSpecsMaxAggregateOutputType | null
  }

  export type AmmoSpecsAvgAggregateOutputType = {
    id: number | null
    caliberId: number | null
    grain: number | null
    velocity: number | null
    energy: number | null
  }

  export type AmmoSpecsSumAggregateOutputType = {
    id: number | null
    caliberId: number | null
    grain: number | null
    velocity: number | null
    energy: number | null
  }

  export type AmmoSpecsMinAggregateOutputType = {
    id: number | null
    itemId: string | null
    caliberId: number | null
    grain: number | null
    gauge: string | null
    velocity: number | null
    energy: number | null
    casing: string | null
    bulletType: string | null
    pressure: $Enums.AmmoPressure | null
    isSteelCase: boolean | null
    isRemanufactured: boolean | null
    isSubsonic: boolean | null
  }

  export type AmmoSpecsMaxAggregateOutputType = {
    id: number | null
    itemId: string | null
    caliberId: number | null
    grain: number | null
    gauge: string | null
    velocity: number | null
    energy: number | null
    casing: string | null
    bulletType: string | null
    pressure: $Enums.AmmoPressure | null
    isSteelCase: boolean | null
    isRemanufactured: boolean | null
    isSubsonic: boolean | null
  }

  export type AmmoSpecsCountAggregateOutputType = {
    id: number
    itemId: number
    caliberId: number
    grain: number
    gauge: number
    velocity: number
    energy: number
    casing: number
    bulletType: number
    restrictions: number
    pressure: number
    isSteelCase: number
    isRemanufactured: number
    isSubsonic: number
    _all: number
  }


  export type AmmoSpecsAvgAggregateInputType = {
    id?: true
    caliberId?: true
    grain?: true
    velocity?: true
    energy?: true
  }

  export type AmmoSpecsSumAggregateInputType = {
    id?: true
    caliberId?: true
    grain?: true
    velocity?: true
    energy?: true
  }

  export type AmmoSpecsMinAggregateInputType = {
    id?: true
    itemId?: true
    caliberId?: true
    grain?: true
    gauge?: true
    velocity?: true
    energy?: true
    casing?: true
    bulletType?: true
    pressure?: true
    isSteelCase?: true
    isRemanufactured?: true
    isSubsonic?: true
  }

  export type AmmoSpecsMaxAggregateInputType = {
    id?: true
    itemId?: true
    caliberId?: true
    grain?: true
    gauge?: true
    velocity?: true
    energy?: true
    casing?: true
    bulletType?: true
    pressure?: true
    isSteelCase?: true
    isRemanufactured?: true
    isSubsonic?: true
  }

  export type AmmoSpecsCountAggregateInputType = {
    id?: true
    itemId?: true
    caliberId?: true
    grain?: true
    gauge?: true
    velocity?: true
    energy?: true
    casing?: true
    bulletType?: true
    restrictions?: true
    pressure?: true
    isSteelCase?: true
    isRemanufactured?: true
    isSubsonic?: true
    _all?: true
  }

  export type AmmoSpecsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AmmoSpecs to aggregate.
     */
    where?: AmmoSpecsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AmmoSpecs to fetch.
     */
    orderBy?: AmmoSpecsOrderByWithRelationInput | AmmoSpecsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AmmoSpecsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AmmoSpecs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AmmoSpecs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AmmoSpecs
    **/
    _count?: true | AmmoSpecsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AmmoSpecsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AmmoSpecsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AmmoSpecsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AmmoSpecsMaxAggregateInputType
  }

  export type GetAmmoSpecsAggregateType<T extends AmmoSpecsAggregateArgs> = {
        [P in keyof T & keyof AggregateAmmoSpecs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAmmoSpecs[P]>
      : GetScalarType<T[P], AggregateAmmoSpecs[P]>
  }




  export type AmmoSpecsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AmmoSpecsWhereInput
    orderBy?: AmmoSpecsOrderByWithAggregationInput | AmmoSpecsOrderByWithAggregationInput[]
    by: AmmoSpecsScalarFieldEnum[] | AmmoSpecsScalarFieldEnum
    having?: AmmoSpecsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AmmoSpecsCountAggregateInputType | true
    _avg?: AmmoSpecsAvgAggregateInputType
    _sum?: AmmoSpecsSumAggregateInputType
    _min?: AmmoSpecsMinAggregateInputType
    _max?: AmmoSpecsMaxAggregateInputType
  }

  export type AmmoSpecsGroupByOutputType = {
    id: number
    itemId: string
    caliberId: number
    grain: number | null
    gauge: string | null
    velocity: number | null
    energy: number | null
    casing: string | null
    bulletType: string | null
    restrictions: string[]
    pressure: $Enums.AmmoPressure | null
    isSteelCase: boolean | null
    isRemanufactured: boolean | null
    isSubsonic: boolean | null
    _count: AmmoSpecsCountAggregateOutputType | null
    _avg: AmmoSpecsAvgAggregateOutputType | null
    _sum: AmmoSpecsSumAggregateOutputType | null
    _min: AmmoSpecsMinAggregateOutputType | null
    _max: AmmoSpecsMaxAggregateOutputType | null
  }

  type GetAmmoSpecsGroupByPayload<T extends AmmoSpecsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AmmoSpecsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AmmoSpecsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AmmoSpecsGroupByOutputType[P]>
            : GetScalarType<T[P], AmmoSpecsGroupByOutputType[P]>
        }
      >
    >


  export type AmmoSpecsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itemId?: boolean
    caliberId?: boolean
    grain?: boolean
    gauge?: boolean
    velocity?: boolean
    energy?: boolean
    casing?: boolean
    bulletType?: boolean
    restrictions?: boolean
    pressure?: boolean
    isSteelCase?: boolean
    isRemanufactured?: boolean
    isSubsonic?: boolean
    Caliber?: boolean | CaliberDefaultArgs<ExtArgs>
    CatalogItem?: boolean | CatalogItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ammoSpecs"]>

  export type AmmoSpecsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itemId?: boolean
    caliberId?: boolean
    grain?: boolean
    gauge?: boolean
    velocity?: boolean
    energy?: boolean
    casing?: boolean
    bulletType?: boolean
    restrictions?: boolean
    pressure?: boolean
    isSteelCase?: boolean
    isRemanufactured?: boolean
    isSubsonic?: boolean
    Caliber?: boolean | CaliberDefaultArgs<ExtArgs>
    CatalogItem?: boolean | CatalogItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ammoSpecs"]>

  export type AmmoSpecsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itemId?: boolean
    caliberId?: boolean
    grain?: boolean
    gauge?: boolean
    velocity?: boolean
    energy?: boolean
    casing?: boolean
    bulletType?: boolean
    restrictions?: boolean
    pressure?: boolean
    isSteelCase?: boolean
    isRemanufactured?: boolean
    isSubsonic?: boolean
    Caliber?: boolean | CaliberDefaultArgs<ExtArgs>
    CatalogItem?: boolean | CatalogItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ammoSpecs"]>

  export type AmmoSpecsSelectScalar = {
    id?: boolean
    itemId?: boolean
    caliberId?: boolean
    grain?: boolean
    gauge?: boolean
    velocity?: boolean
    energy?: boolean
    casing?: boolean
    bulletType?: boolean
    restrictions?: boolean
    pressure?: boolean
    isSteelCase?: boolean
    isRemanufactured?: boolean
    isSubsonic?: boolean
  }

  export type AmmoSpecsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "itemId" | "caliberId" | "grain" | "gauge" | "velocity" | "energy" | "casing" | "bulletType" | "restrictions" | "pressure" | "isSteelCase" | "isRemanufactured" | "isSubsonic", ExtArgs["result"]["ammoSpecs"]>
  export type AmmoSpecsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Caliber?: boolean | CaliberDefaultArgs<ExtArgs>
    CatalogItem?: boolean | CatalogItemDefaultArgs<ExtArgs>
  }
  export type AmmoSpecsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Caliber?: boolean | CaliberDefaultArgs<ExtArgs>
    CatalogItem?: boolean | CatalogItemDefaultArgs<ExtArgs>
  }
  export type AmmoSpecsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Caliber?: boolean | CaliberDefaultArgs<ExtArgs>
    CatalogItem?: boolean | CatalogItemDefaultArgs<ExtArgs>
  }

  export type $AmmoSpecsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AmmoSpecs"
    objects: {
      Caliber: Prisma.$CaliberPayload<ExtArgs>
      CatalogItem: Prisma.$CatalogItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      itemId: string
      caliberId: number
      grain: number | null
      gauge: string | null
      velocity: number | null
      energy: number | null
      casing: string | null
      bulletType: string | null
      restrictions: string[]
      pressure: $Enums.AmmoPressure | null
      isSteelCase: boolean | null
      isRemanufactured: boolean | null
      isSubsonic: boolean | null
    }, ExtArgs["result"]["ammoSpecs"]>
    composites: {}
  }

  type AmmoSpecsGetPayload<S extends boolean | null | undefined | AmmoSpecsDefaultArgs> = $Result.GetResult<Prisma.$AmmoSpecsPayload, S>

  type AmmoSpecsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AmmoSpecsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AmmoSpecsCountAggregateInputType | true
    }

  export interface AmmoSpecsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AmmoSpecs'], meta: { name: 'AmmoSpecs' } }
    /**
     * Find zero or one AmmoSpecs that matches the filter.
     * @param {AmmoSpecsFindUniqueArgs} args - Arguments to find a AmmoSpecs
     * @example
     * // Get one AmmoSpecs
     * const ammoSpecs = await prisma.ammoSpecs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AmmoSpecsFindUniqueArgs>(args: SelectSubset<T, AmmoSpecsFindUniqueArgs<ExtArgs>>): Prisma__AmmoSpecsClient<$Result.GetResult<Prisma.$AmmoSpecsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AmmoSpecs that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AmmoSpecsFindUniqueOrThrowArgs} args - Arguments to find a AmmoSpecs
     * @example
     * // Get one AmmoSpecs
     * const ammoSpecs = await prisma.ammoSpecs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AmmoSpecsFindUniqueOrThrowArgs>(args: SelectSubset<T, AmmoSpecsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AmmoSpecsClient<$Result.GetResult<Prisma.$AmmoSpecsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AmmoSpecs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmmoSpecsFindFirstArgs} args - Arguments to find a AmmoSpecs
     * @example
     * // Get one AmmoSpecs
     * const ammoSpecs = await prisma.ammoSpecs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AmmoSpecsFindFirstArgs>(args?: SelectSubset<T, AmmoSpecsFindFirstArgs<ExtArgs>>): Prisma__AmmoSpecsClient<$Result.GetResult<Prisma.$AmmoSpecsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AmmoSpecs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmmoSpecsFindFirstOrThrowArgs} args - Arguments to find a AmmoSpecs
     * @example
     * // Get one AmmoSpecs
     * const ammoSpecs = await prisma.ammoSpecs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AmmoSpecsFindFirstOrThrowArgs>(args?: SelectSubset<T, AmmoSpecsFindFirstOrThrowArgs<ExtArgs>>): Prisma__AmmoSpecsClient<$Result.GetResult<Prisma.$AmmoSpecsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AmmoSpecs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmmoSpecsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AmmoSpecs
     * const ammoSpecs = await prisma.ammoSpecs.findMany()
     * 
     * // Get first 10 AmmoSpecs
     * const ammoSpecs = await prisma.ammoSpecs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ammoSpecsWithIdOnly = await prisma.ammoSpecs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AmmoSpecsFindManyArgs>(args?: SelectSubset<T, AmmoSpecsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AmmoSpecsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AmmoSpecs.
     * @param {AmmoSpecsCreateArgs} args - Arguments to create a AmmoSpecs.
     * @example
     * // Create one AmmoSpecs
     * const AmmoSpecs = await prisma.ammoSpecs.create({
     *   data: {
     *     // ... data to create a AmmoSpecs
     *   }
     * })
     * 
     */
    create<T extends AmmoSpecsCreateArgs>(args: SelectSubset<T, AmmoSpecsCreateArgs<ExtArgs>>): Prisma__AmmoSpecsClient<$Result.GetResult<Prisma.$AmmoSpecsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AmmoSpecs.
     * @param {AmmoSpecsCreateManyArgs} args - Arguments to create many AmmoSpecs.
     * @example
     * // Create many AmmoSpecs
     * const ammoSpecs = await prisma.ammoSpecs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AmmoSpecsCreateManyArgs>(args?: SelectSubset<T, AmmoSpecsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AmmoSpecs and returns the data saved in the database.
     * @param {AmmoSpecsCreateManyAndReturnArgs} args - Arguments to create many AmmoSpecs.
     * @example
     * // Create many AmmoSpecs
     * const ammoSpecs = await prisma.ammoSpecs.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AmmoSpecs and only return the `id`
     * const ammoSpecsWithIdOnly = await prisma.ammoSpecs.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AmmoSpecsCreateManyAndReturnArgs>(args?: SelectSubset<T, AmmoSpecsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AmmoSpecsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AmmoSpecs.
     * @param {AmmoSpecsDeleteArgs} args - Arguments to delete one AmmoSpecs.
     * @example
     * // Delete one AmmoSpecs
     * const AmmoSpecs = await prisma.ammoSpecs.delete({
     *   where: {
     *     // ... filter to delete one AmmoSpecs
     *   }
     * })
     * 
     */
    delete<T extends AmmoSpecsDeleteArgs>(args: SelectSubset<T, AmmoSpecsDeleteArgs<ExtArgs>>): Prisma__AmmoSpecsClient<$Result.GetResult<Prisma.$AmmoSpecsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AmmoSpecs.
     * @param {AmmoSpecsUpdateArgs} args - Arguments to update one AmmoSpecs.
     * @example
     * // Update one AmmoSpecs
     * const ammoSpecs = await prisma.ammoSpecs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AmmoSpecsUpdateArgs>(args: SelectSubset<T, AmmoSpecsUpdateArgs<ExtArgs>>): Prisma__AmmoSpecsClient<$Result.GetResult<Prisma.$AmmoSpecsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AmmoSpecs.
     * @param {AmmoSpecsDeleteManyArgs} args - Arguments to filter AmmoSpecs to delete.
     * @example
     * // Delete a few AmmoSpecs
     * const { count } = await prisma.ammoSpecs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AmmoSpecsDeleteManyArgs>(args?: SelectSubset<T, AmmoSpecsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AmmoSpecs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmmoSpecsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AmmoSpecs
     * const ammoSpecs = await prisma.ammoSpecs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AmmoSpecsUpdateManyArgs>(args: SelectSubset<T, AmmoSpecsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AmmoSpecs and returns the data updated in the database.
     * @param {AmmoSpecsUpdateManyAndReturnArgs} args - Arguments to update many AmmoSpecs.
     * @example
     * // Update many AmmoSpecs
     * const ammoSpecs = await prisma.ammoSpecs.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AmmoSpecs and only return the `id`
     * const ammoSpecsWithIdOnly = await prisma.ammoSpecs.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AmmoSpecsUpdateManyAndReturnArgs>(args: SelectSubset<T, AmmoSpecsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AmmoSpecsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AmmoSpecs.
     * @param {AmmoSpecsUpsertArgs} args - Arguments to update or create a AmmoSpecs.
     * @example
     * // Update or create a AmmoSpecs
     * const ammoSpecs = await prisma.ammoSpecs.upsert({
     *   create: {
     *     // ... data to create a AmmoSpecs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AmmoSpecs we want to update
     *   }
     * })
     */
    upsert<T extends AmmoSpecsUpsertArgs>(args: SelectSubset<T, AmmoSpecsUpsertArgs<ExtArgs>>): Prisma__AmmoSpecsClient<$Result.GetResult<Prisma.$AmmoSpecsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AmmoSpecs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmmoSpecsCountArgs} args - Arguments to filter AmmoSpecs to count.
     * @example
     * // Count the number of AmmoSpecs
     * const count = await prisma.ammoSpecs.count({
     *   where: {
     *     // ... the filter for the AmmoSpecs we want to count
     *   }
     * })
    **/
    count<T extends AmmoSpecsCountArgs>(
      args?: Subset<T, AmmoSpecsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AmmoSpecsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AmmoSpecs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmmoSpecsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AmmoSpecsAggregateArgs>(args: Subset<T, AmmoSpecsAggregateArgs>): Prisma.PrismaPromise<GetAmmoSpecsAggregateType<T>>

    /**
     * Group by AmmoSpecs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmmoSpecsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AmmoSpecsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AmmoSpecsGroupByArgs['orderBy'] }
        : { orderBy?: AmmoSpecsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AmmoSpecsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAmmoSpecsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AmmoSpecs model
   */
  readonly fields: AmmoSpecsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AmmoSpecs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AmmoSpecsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Caliber<T extends CaliberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CaliberDefaultArgs<ExtArgs>>): Prisma__CaliberClient<$Result.GetResult<Prisma.$CaliberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    CatalogItem<T extends CatalogItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CatalogItemDefaultArgs<ExtArgs>>): Prisma__CatalogItemClient<$Result.GetResult<Prisma.$CatalogItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AmmoSpecs model
   */
  interface AmmoSpecsFieldRefs {
    readonly id: FieldRef<"AmmoSpecs", 'Int'>
    readonly itemId: FieldRef<"AmmoSpecs", 'String'>
    readonly caliberId: FieldRef<"AmmoSpecs", 'Int'>
    readonly grain: FieldRef<"AmmoSpecs", 'Int'>
    readonly gauge: FieldRef<"AmmoSpecs", 'String'>
    readonly velocity: FieldRef<"AmmoSpecs", 'Int'>
    readonly energy: FieldRef<"AmmoSpecs", 'Int'>
    readonly casing: FieldRef<"AmmoSpecs", 'String'>
    readonly bulletType: FieldRef<"AmmoSpecs", 'String'>
    readonly restrictions: FieldRef<"AmmoSpecs", 'String[]'>
    readonly pressure: FieldRef<"AmmoSpecs", 'AmmoPressure'>
    readonly isSteelCase: FieldRef<"AmmoSpecs", 'Boolean'>
    readonly isRemanufactured: FieldRef<"AmmoSpecs", 'Boolean'>
    readonly isSubsonic: FieldRef<"AmmoSpecs", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * AmmoSpecs findUnique
   */
  export type AmmoSpecsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmmoSpecs
     */
    select?: AmmoSpecsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmmoSpecs
     */
    omit?: AmmoSpecsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmmoSpecsInclude<ExtArgs> | null
    /**
     * Filter, which AmmoSpecs to fetch.
     */
    where: AmmoSpecsWhereUniqueInput
  }

  /**
   * AmmoSpecs findUniqueOrThrow
   */
  export type AmmoSpecsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmmoSpecs
     */
    select?: AmmoSpecsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmmoSpecs
     */
    omit?: AmmoSpecsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmmoSpecsInclude<ExtArgs> | null
    /**
     * Filter, which AmmoSpecs to fetch.
     */
    where: AmmoSpecsWhereUniqueInput
  }

  /**
   * AmmoSpecs findFirst
   */
  export type AmmoSpecsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmmoSpecs
     */
    select?: AmmoSpecsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmmoSpecs
     */
    omit?: AmmoSpecsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmmoSpecsInclude<ExtArgs> | null
    /**
     * Filter, which AmmoSpecs to fetch.
     */
    where?: AmmoSpecsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AmmoSpecs to fetch.
     */
    orderBy?: AmmoSpecsOrderByWithRelationInput | AmmoSpecsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AmmoSpecs.
     */
    cursor?: AmmoSpecsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AmmoSpecs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AmmoSpecs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AmmoSpecs.
     */
    distinct?: AmmoSpecsScalarFieldEnum | AmmoSpecsScalarFieldEnum[]
  }

  /**
   * AmmoSpecs findFirstOrThrow
   */
  export type AmmoSpecsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmmoSpecs
     */
    select?: AmmoSpecsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmmoSpecs
     */
    omit?: AmmoSpecsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmmoSpecsInclude<ExtArgs> | null
    /**
     * Filter, which AmmoSpecs to fetch.
     */
    where?: AmmoSpecsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AmmoSpecs to fetch.
     */
    orderBy?: AmmoSpecsOrderByWithRelationInput | AmmoSpecsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AmmoSpecs.
     */
    cursor?: AmmoSpecsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AmmoSpecs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AmmoSpecs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AmmoSpecs.
     */
    distinct?: AmmoSpecsScalarFieldEnum | AmmoSpecsScalarFieldEnum[]
  }

  /**
   * AmmoSpecs findMany
   */
  export type AmmoSpecsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmmoSpecs
     */
    select?: AmmoSpecsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmmoSpecs
     */
    omit?: AmmoSpecsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmmoSpecsInclude<ExtArgs> | null
    /**
     * Filter, which AmmoSpecs to fetch.
     */
    where?: AmmoSpecsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AmmoSpecs to fetch.
     */
    orderBy?: AmmoSpecsOrderByWithRelationInput | AmmoSpecsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AmmoSpecs.
     */
    cursor?: AmmoSpecsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AmmoSpecs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AmmoSpecs.
     */
    skip?: number
    distinct?: AmmoSpecsScalarFieldEnum | AmmoSpecsScalarFieldEnum[]
  }

  /**
   * AmmoSpecs create
   */
  export type AmmoSpecsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmmoSpecs
     */
    select?: AmmoSpecsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmmoSpecs
     */
    omit?: AmmoSpecsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmmoSpecsInclude<ExtArgs> | null
    /**
     * The data needed to create a AmmoSpecs.
     */
    data: XOR<AmmoSpecsCreateInput, AmmoSpecsUncheckedCreateInput>
  }

  /**
   * AmmoSpecs createMany
   */
  export type AmmoSpecsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AmmoSpecs.
     */
    data: AmmoSpecsCreateManyInput | AmmoSpecsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AmmoSpecs createManyAndReturn
   */
  export type AmmoSpecsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmmoSpecs
     */
    select?: AmmoSpecsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AmmoSpecs
     */
    omit?: AmmoSpecsOmit<ExtArgs> | null
    /**
     * The data used to create many AmmoSpecs.
     */
    data: AmmoSpecsCreateManyInput | AmmoSpecsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmmoSpecsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AmmoSpecs update
   */
  export type AmmoSpecsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmmoSpecs
     */
    select?: AmmoSpecsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmmoSpecs
     */
    omit?: AmmoSpecsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmmoSpecsInclude<ExtArgs> | null
    /**
     * The data needed to update a AmmoSpecs.
     */
    data: XOR<AmmoSpecsUpdateInput, AmmoSpecsUncheckedUpdateInput>
    /**
     * Choose, which AmmoSpecs to update.
     */
    where: AmmoSpecsWhereUniqueInput
  }

  /**
   * AmmoSpecs updateMany
   */
  export type AmmoSpecsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AmmoSpecs.
     */
    data: XOR<AmmoSpecsUpdateManyMutationInput, AmmoSpecsUncheckedUpdateManyInput>
    /**
     * Filter which AmmoSpecs to update
     */
    where?: AmmoSpecsWhereInput
    /**
     * Limit how many AmmoSpecs to update.
     */
    limit?: number
  }

  /**
   * AmmoSpecs updateManyAndReturn
   */
  export type AmmoSpecsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmmoSpecs
     */
    select?: AmmoSpecsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AmmoSpecs
     */
    omit?: AmmoSpecsOmit<ExtArgs> | null
    /**
     * The data used to update AmmoSpecs.
     */
    data: XOR<AmmoSpecsUpdateManyMutationInput, AmmoSpecsUncheckedUpdateManyInput>
    /**
     * Filter which AmmoSpecs to update
     */
    where?: AmmoSpecsWhereInput
    /**
     * Limit how many AmmoSpecs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmmoSpecsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AmmoSpecs upsert
   */
  export type AmmoSpecsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmmoSpecs
     */
    select?: AmmoSpecsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmmoSpecs
     */
    omit?: AmmoSpecsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmmoSpecsInclude<ExtArgs> | null
    /**
     * The filter to search for the AmmoSpecs to update in case it exists.
     */
    where: AmmoSpecsWhereUniqueInput
    /**
     * In case the AmmoSpecs found by the `where` argument doesn't exist, create a new AmmoSpecs with this data.
     */
    create: XOR<AmmoSpecsCreateInput, AmmoSpecsUncheckedCreateInput>
    /**
     * In case the AmmoSpecs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AmmoSpecsUpdateInput, AmmoSpecsUncheckedUpdateInput>
  }

  /**
   * AmmoSpecs delete
   */
  export type AmmoSpecsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmmoSpecs
     */
    select?: AmmoSpecsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmmoSpecs
     */
    omit?: AmmoSpecsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmmoSpecsInclude<ExtArgs> | null
    /**
     * Filter which AmmoSpecs to delete.
     */
    where: AmmoSpecsWhereUniqueInput
  }

  /**
   * AmmoSpecs deleteMany
   */
  export type AmmoSpecsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AmmoSpecs to delete
     */
    where?: AmmoSpecsWhereInput
    /**
     * Limit how many AmmoSpecs to delete.
     */
    limit?: number
  }

  /**
   * AmmoSpecs without action
   */
  export type AmmoSpecsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmmoSpecs
     */
    select?: AmmoSpecsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmmoSpecs
     */
    omit?: AmmoSpecsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmmoSpecsInclude<ExtArgs> | null
  }


  /**
   * Model BlockedRetailer
   */

  export type AggregateBlockedRetailer = {
    _count: BlockedRetailerCountAggregateOutputType | null
    _avg: BlockedRetailerAvgAggregateOutputType | null
    _sum: BlockedRetailerSumAggregateOutputType | null
    _min: BlockedRetailerMinAggregateOutputType | null
    _max: BlockedRetailerMaxAggregateOutputType | null
  }

  export type BlockedRetailerAvgAggregateOutputType = {
    retailerId: number | null
  }

  export type BlockedRetailerSumAggregateOutputType = {
    retailerId: number | null
  }

  export type BlockedRetailerMinAggregateOutputType = {
    id: string | null
    userId: string | null
    retailerId: number | null
    createdAt: Date | null
  }

  export type BlockedRetailerMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    retailerId: number | null
    createdAt: Date | null
  }

  export type BlockedRetailerCountAggregateOutputType = {
    id: number
    userId: number
    retailerId: number
    createdAt: number
    _all: number
  }


  export type BlockedRetailerAvgAggregateInputType = {
    retailerId?: true
  }

  export type BlockedRetailerSumAggregateInputType = {
    retailerId?: true
  }

  export type BlockedRetailerMinAggregateInputType = {
    id?: true
    userId?: true
    retailerId?: true
    createdAt?: true
  }

  export type BlockedRetailerMaxAggregateInputType = {
    id?: true
    userId?: true
    retailerId?: true
    createdAt?: true
  }

  export type BlockedRetailerCountAggregateInputType = {
    id?: true
    userId?: true
    retailerId?: true
    createdAt?: true
    _all?: true
  }

  export type BlockedRetailerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlockedRetailer to aggregate.
     */
    where?: BlockedRetailerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlockedRetailers to fetch.
     */
    orderBy?: BlockedRetailerOrderByWithRelationInput | BlockedRetailerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BlockedRetailerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlockedRetailers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlockedRetailers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BlockedRetailers
    **/
    _count?: true | BlockedRetailerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BlockedRetailerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BlockedRetailerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlockedRetailerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlockedRetailerMaxAggregateInputType
  }

  export type GetBlockedRetailerAggregateType<T extends BlockedRetailerAggregateArgs> = {
        [P in keyof T & keyof AggregateBlockedRetailer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlockedRetailer[P]>
      : GetScalarType<T[P], AggregateBlockedRetailer[P]>
  }




  export type BlockedRetailerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlockedRetailerWhereInput
    orderBy?: BlockedRetailerOrderByWithAggregationInput | BlockedRetailerOrderByWithAggregationInput[]
    by: BlockedRetailerScalarFieldEnum[] | BlockedRetailerScalarFieldEnum
    having?: BlockedRetailerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlockedRetailerCountAggregateInputType | true
    _avg?: BlockedRetailerAvgAggregateInputType
    _sum?: BlockedRetailerSumAggregateInputType
    _min?: BlockedRetailerMinAggregateInputType
    _max?: BlockedRetailerMaxAggregateInputType
  }

  export type BlockedRetailerGroupByOutputType = {
    id: string
    userId: string
    retailerId: number
    createdAt: Date | null
    _count: BlockedRetailerCountAggregateOutputType | null
    _avg: BlockedRetailerAvgAggregateOutputType | null
    _sum: BlockedRetailerSumAggregateOutputType | null
    _min: BlockedRetailerMinAggregateOutputType | null
    _max: BlockedRetailerMaxAggregateOutputType | null
  }

  type GetBlockedRetailerGroupByPayload<T extends BlockedRetailerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlockedRetailerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlockedRetailerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlockedRetailerGroupByOutputType[P]>
            : GetScalarType<T[P], BlockedRetailerGroupByOutputType[P]>
        }
      >
    >


  export type BlockedRetailerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    retailerId?: boolean
    createdAt?: boolean
    Retailer?: boolean | RetailerDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blockedRetailer"]>

  export type BlockedRetailerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    retailerId?: boolean
    createdAt?: boolean
    Retailer?: boolean | RetailerDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blockedRetailer"]>

  export type BlockedRetailerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    retailerId?: boolean
    createdAt?: boolean
    Retailer?: boolean | RetailerDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blockedRetailer"]>

  export type BlockedRetailerSelectScalar = {
    id?: boolean
    userId?: boolean
    retailerId?: boolean
    createdAt?: boolean
  }

  export type BlockedRetailerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "retailerId" | "createdAt", ExtArgs["result"]["blockedRetailer"]>
  export type BlockedRetailerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Retailer?: boolean | RetailerDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BlockedRetailerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Retailer?: boolean | RetailerDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BlockedRetailerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Retailer?: boolean | RetailerDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $BlockedRetailerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BlockedRetailer"
    objects: {
      Retailer: Prisma.$RetailerPayload<ExtArgs>
      User: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      retailerId: number
      createdAt: Date | null
    }, ExtArgs["result"]["blockedRetailer"]>
    composites: {}
  }

  type BlockedRetailerGetPayload<S extends boolean | null | undefined | BlockedRetailerDefaultArgs> = $Result.GetResult<Prisma.$BlockedRetailerPayload, S>

  type BlockedRetailerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BlockedRetailerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BlockedRetailerCountAggregateInputType | true
    }

  export interface BlockedRetailerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BlockedRetailer'], meta: { name: 'BlockedRetailer' } }
    /**
     * Find zero or one BlockedRetailer that matches the filter.
     * @param {BlockedRetailerFindUniqueArgs} args - Arguments to find a BlockedRetailer
     * @example
     * // Get one BlockedRetailer
     * const blockedRetailer = await prisma.blockedRetailer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BlockedRetailerFindUniqueArgs>(args: SelectSubset<T, BlockedRetailerFindUniqueArgs<ExtArgs>>): Prisma__BlockedRetailerClient<$Result.GetResult<Prisma.$BlockedRetailerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BlockedRetailer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BlockedRetailerFindUniqueOrThrowArgs} args - Arguments to find a BlockedRetailer
     * @example
     * // Get one BlockedRetailer
     * const blockedRetailer = await prisma.blockedRetailer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BlockedRetailerFindUniqueOrThrowArgs>(args: SelectSubset<T, BlockedRetailerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BlockedRetailerClient<$Result.GetResult<Prisma.$BlockedRetailerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BlockedRetailer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockedRetailerFindFirstArgs} args - Arguments to find a BlockedRetailer
     * @example
     * // Get one BlockedRetailer
     * const blockedRetailer = await prisma.blockedRetailer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BlockedRetailerFindFirstArgs>(args?: SelectSubset<T, BlockedRetailerFindFirstArgs<ExtArgs>>): Prisma__BlockedRetailerClient<$Result.GetResult<Prisma.$BlockedRetailerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BlockedRetailer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockedRetailerFindFirstOrThrowArgs} args - Arguments to find a BlockedRetailer
     * @example
     * // Get one BlockedRetailer
     * const blockedRetailer = await prisma.blockedRetailer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BlockedRetailerFindFirstOrThrowArgs>(args?: SelectSubset<T, BlockedRetailerFindFirstOrThrowArgs<ExtArgs>>): Prisma__BlockedRetailerClient<$Result.GetResult<Prisma.$BlockedRetailerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BlockedRetailers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockedRetailerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BlockedRetailers
     * const blockedRetailers = await prisma.blockedRetailer.findMany()
     * 
     * // Get first 10 BlockedRetailers
     * const blockedRetailers = await prisma.blockedRetailer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blockedRetailerWithIdOnly = await prisma.blockedRetailer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BlockedRetailerFindManyArgs>(args?: SelectSubset<T, BlockedRetailerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockedRetailerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BlockedRetailer.
     * @param {BlockedRetailerCreateArgs} args - Arguments to create a BlockedRetailer.
     * @example
     * // Create one BlockedRetailer
     * const BlockedRetailer = await prisma.blockedRetailer.create({
     *   data: {
     *     // ... data to create a BlockedRetailer
     *   }
     * })
     * 
     */
    create<T extends BlockedRetailerCreateArgs>(args: SelectSubset<T, BlockedRetailerCreateArgs<ExtArgs>>): Prisma__BlockedRetailerClient<$Result.GetResult<Prisma.$BlockedRetailerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BlockedRetailers.
     * @param {BlockedRetailerCreateManyArgs} args - Arguments to create many BlockedRetailers.
     * @example
     * // Create many BlockedRetailers
     * const blockedRetailer = await prisma.blockedRetailer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BlockedRetailerCreateManyArgs>(args?: SelectSubset<T, BlockedRetailerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BlockedRetailers and returns the data saved in the database.
     * @param {BlockedRetailerCreateManyAndReturnArgs} args - Arguments to create many BlockedRetailers.
     * @example
     * // Create many BlockedRetailers
     * const blockedRetailer = await prisma.blockedRetailer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BlockedRetailers and only return the `id`
     * const blockedRetailerWithIdOnly = await prisma.blockedRetailer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BlockedRetailerCreateManyAndReturnArgs>(args?: SelectSubset<T, BlockedRetailerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockedRetailerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BlockedRetailer.
     * @param {BlockedRetailerDeleteArgs} args - Arguments to delete one BlockedRetailer.
     * @example
     * // Delete one BlockedRetailer
     * const BlockedRetailer = await prisma.blockedRetailer.delete({
     *   where: {
     *     // ... filter to delete one BlockedRetailer
     *   }
     * })
     * 
     */
    delete<T extends BlockedRetailerDeleteArgs>(args: SelectSubset<T, BlockedRetailerDeleteArgs<ExtArgs>>): Prisma__BlockedRetailerClient<$Result.GetResult<Prisma.$BlockedRetailerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BlockedRetailer.
     * @param {BlockedRetailerUpdateArgs} args - Arguments to update one BlockedRetailer.
     * @example
     * // Update one BlockedRetailer
     * const blockedRetailer = await prisma.blockedRetailer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BlockedRetailerUpdateArgs>(args: SelectSubset<T, BlockedRetailerUpdateArgs<ExtArgs>>): Prisma__BlockedRetailerClient<$Result.GetResult<Prisma.$BlockedRetailerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BlockedRetailers.
     * @param {BlockedRetailerDeleteManyArgs} args - Arguments to filter BlockedRetailers to delete.
     * @example
     * // Delete a few BlockedRetailers
     * const { count } = await prisma.blockedRetailer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BlockedRetailerDeleteManyArgs>(args?: SelectSubset<T, BlockedRetailerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlockedRetailers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockedRetailerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BlockedRetailers
     * const blockedRetailer = await prisma.blockedRetailer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BlockedRetailerUpdateManyArgs>(args: SelectSubset<T, BlockedRetailerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlockedRetailers and returns the data updated in the database.
     * @param {BlockedRetailerUpdateManyAndReturnArgs} args - Arguments to update many BlockedRetailers.
     * @example
     * // Update many BlockedRetailers
     * const blockedRetailer = await prisma.blockedRetailer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BlockedRetailers and only return the `id`
     * const blockedRetailerWithIdOnly = await prisma.blockedRetailer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BlockedRetailerUpdateManyAndReturnArgs>(args: SelectSubset<T, BlockedRetailerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockedRetailerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BlockedRetailer.
     * @param {BlockedRetailerUpsertArgs} args - Arguments to update or create a BlockedRetailer.
     * @example
     * // Update or create a BlockedRetailer
     * const blockedRetailer = await prisma.blockedRetailer.upsert({
     *   create: {
     *     // ... data to create a BlockedRetailer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BlockedRetailer we want to update
     *   }
     * })
     */
    upsert<T extends BlockedRetailerUpsertArgs>(args: SelectSubset<T, BlockedRetailerUpsertArgs<ExtArgs>>): Prisma__BlockedRetailerClient<$Result.GetResult<Prisma.$BlockedRetailerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BlockedRetailers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockedRetailerCountArgs} args - Arguments to filter BlockedRetailers to count.
     * @example
     * // Count the number of BlockedRetailers
     * const count = await prisma.blockedRetailer.count({
     *   where: {
     *     // ... the filter for the BlockedRetailers we want to count
     *   }
     * })
    **/
    count<T extends BlockedRetailerCountArgs>(
      args?: Subset<T, BlockedRetailerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlockedRetailerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BlockedRetailer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockedRetailerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlockedRetailerAggregateArgs>(args: Subset<T, BlockedRetailerAggregateArgs>): Prisma.PrismaPromise<GetBlockedRetailerAggregateType<T>>

    /**
     * Group by BlockedRetailer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockedRetailerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlockedRetailerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlockedRetailerGroupByArgs['orderBy'] }
        : { orderBy?: BlockedRetailerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlockedRetailerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlockedRetailerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BlockedRetailer model
   */
  readonly fields: BlockedRetailerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BlockedRetailer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BlockedRetailerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Retailer<T extends RetailerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RetailerDefaultArgs<ExtArgs>>): Prisma__RetailerClient<$Result.GetResult<Prisma.$RetailerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BlockedRetailer model
   */
  interface BlockedRetailerFieldRefs {
    readonly id: FieldRef<"BlockedRetailer", 'String'>
    readonly userId: FieldRef<"BlockedRetailer", 'String'>
    readonly retailerId: FieldRef<"BlockedRetailer", 'Int'>
    readonly createdAt: FieldRef<"BlockedRetailer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BlockedRetailer findUnique
   */
  export type BlockedRetailerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedRetailer
     */
    select?: BlockedRetailerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlockedRetailer
     */
    omit?: BlockedRetailerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockedRetailerInclude<ExtArgs> | null
    /**
     * Filter, which BlockedRetailer to fetch.
     */
    where: BlockedRetailerWhereUniqueInput
  }

  /**
   * BlockedRetailer findUniqueOrThrow
   */
  export type BlockedRetailerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedRetailer
     */
    select?: BlockedRetailerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlockedRetailer
     */
    omit?: BlockedRetailerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockedRetailerInclude<ExtArgs> | null
    /**
     * Filter, which BlockedRetailer to fetch.
     */
    where: BlockedRetailerWhereUniqueInput
  }

  /**
   * BlockedRetailer findFirst
   */
  export type BlockedRetailerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedRetailer
     */
    select?: BlockedRetailerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlockedRetailer
     */
    omit?: BlockedRetailerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockedRetailerInclude<ExtArgs> | null
    /**
     * Filter, which BlockedRetailer to fetch.
     */
    where?: BlockedRetailerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlockedRetailers to fetch.
     */
    orderBy?: BlockedRetailerOrderByWithRelationInput | BlockedRetailerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlockedRetailers.
     */
    cursor?: BlockedRetailerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlockedRetailers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlockedRetailers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlockedRetailers.
     */
    distinct?: BlockedRetailerScalarFieldEnum | BlockedRetailerScalarFieldEnum[]
  }

  /**
   * BlockedRetailer findFirstOrThrow
   */
  export type BlockedRetailerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedRetailer
     */
    select?: BlockedRetailerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlockedRetailer
     */
    omit?: BlockedRetailerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockedRetailerInclude<ExtArgs> | null
    /**
     * Filter, which BlockedRetailer to fetch.
     */
    where?: BlockedRetailerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlockedRetailers to fetch.
     */
    orderBy?: BlockedRetailerOrderByWithRelationInput | BlockedRetailerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlockedRetailers.
     */
    cursor?: BlockedRetailerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlockedRetailers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlockedRetailers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlockedRetailers.
     */
    distinct?: BlockedRetailerScalarFieldEnum | BlockedRetailerScalarFieldEnum[]
  }

  /**
   * BlockedRetailer findMany
   */
  export type BlockedRetailerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedRetailer
     */
    select?: BlockedRetailerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlockedRetailer
     */
    omit?: BlockedRetailerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockedRetailerInclude<ExtArgs> | null
    /**
     * Filter, which BlockedRetailers to fetch.
     */
    where?: BlockedRetailerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlockedRetailers to fetch.
     */
    orderBy?: BlockedRetailerOrderByWithRelationInput | BlockedRetailerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BlockedRetailers.
     */
    cursor?: BlockedRetailerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlockedRetailers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlockedRetailers.
     */
    skip?: number
    distinct?: BlockedRetailerScalarFieldEnum | BlockedRetailerScalarFieldEnum[]
  }

  /**
   * BlockedRetailer create
   */
  export type BlockedRetailerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedRetailer
     */
    select?: BlockedRetailerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlockedRetailer
     */
    omit?: BlockedRetailerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockedRetailerInclude<ExtArgs> | null
    /**
     * The data needed to create a BlockedRetailer.
     */
    data: XOR<BlockedRetailerCreateInput, BlockedRetailerUncheckedCreateInput>
  }

  /**
   * BlockedRetailer createMany
   */
  export type BlockedRetailerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BlockedRetailers.
     */
    data: BlockedRetailerCreateManyInput | BlockedRetailerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BlockedRetailer createManyAndReturn
   */
  export type BlockedRetailerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedRetailer
     */
    select?: BlockedRetailerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BlockedRetailer
     */
    omit?: BlockedRetailerOmit<ExtArgs> | null
    /**
     * The data used to create many BlockedRetailers.
     */
    data: BlockedRetailerCreateManyInput | BlockedRetailerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockedRetailerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BlockedRetailer update
   */
  export type BlockedRetailerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedRetailer
     */
    select?: BlockedRetailerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlockedRetailer
     */
    omit?: BlockedRetailerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockedRetailerInclude<ExtArgs> | null
    /**
     * The data needed to update a BlockedRetailer.
     */
    data: XOR<BlockedRetailerUpdateInput, BlockedRetailerUncheckedUpdateInput>
    /**
     * Choose, which BlockedRetailer to update.
     */
    where: BlockedRetailerWhereUniqueInput
  }

  /**
   * BlockedRetailer updateMany
   */
  export type BlockedRetailerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BlockedRetailers.
     */
    data: XOR<BlockedRetailerUpdateManyMutationInput, BlockedRetailerUncheckedUpdateManyInput>
    /**
     * Filter which BlockedRetailers to update
     */
    where?: BlockedRetailerWhereInput
    /**
     * Limit how many BlockedRetailers to update.
     */
    limit?: number
  }

  /**
   * BlockedRetailer updateManyAndReturn
   */
  export type BlockedRetailerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedRetailer
     */
    select?: BlockedRetailerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BlockedRetailer
     */
    omit?: BlockedRetailerOmit<ExtArgs> | null
    /**
     * The data used to update BlockedRetailers.
     */
    data: XOR<BlockedRetailerUpdateManyMutationInput, BlockedRetailerUncheckedUpdateManyInput>
    /**
     * Filter which BlockedRetailers to update
     */
    where?: BlockedRetailerWhereInput
    /**
     * Limit how many BlockedRetailers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockedRetailerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BlockedRetailer upsert
   */
  export type BlockedRetailerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedRetailer
     */
    select?: BlockedRetailerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlockedRetailer
     */
    omit?: BlockedRetailerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockedRetailerInclude<ExtArgs> | null
    /**
     * The filter to search for the BlockedRetailer to update in case it exists.
     */
    where: BlockedRetailerWhereUniqueInput
    /**
     * In case the BlockedRetailer found by the `where` argument doesn't exist, create a new BlockedRetailer with this data.
     */
    create: XOR<BlockedRetailerCreateInput, BlockedRetailerUncheckedCreateInput>
    /**
     * In case the BlockedRetailer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BlockedRetailerUpdateInput, BlockedRetailerUncheckedUpdateInput>
  }

  /**
   * BlockedRetailer delete
   */
  export type BlockedRetailerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedRetailer
     */
    select?: BlockedRetailerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlockedRetailer
     */
    omit?: BlockedRetailerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockedRetailerInclude<ExtArgs> | null
    /**
     * Filter which BlockedRetailer to delete.
     */
    where: BlockedRetailerWhereUniqueInput
  }

  /**
   * BlockedRetailer deleteMany
   */
  export type BlockedRetailerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlockedRetailers to delete
     */
    where?: BlockedRetailerWhereInput
    /**
     * Limit how many BlockedRetailers to delete.
     */
    limit?: number
  }

  /**
   * BlockedRetailer without action
   */
  export type BlockedRetailerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedRetailer
     */
    select?: BlockedRetailerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlockedRetailer
     */
    omit?: BlockedRetailerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockedRetailerInclude<ExtArgs> | null
  }


  /**
   * Model CaliberAlias
   */

  export type AggregateCaliberAlias = {
    _count: CaliberAliasCountAggregateOutputType | null
    _avg: CaliberAliasAvgAggregateOutputType | null
    _sum: CaliberAliasSumAggregateOutputType | null
    _min: CaliberAliasMinAggregateOutputType | null
    _max: CaliberAliasMaxAggregateOutputType | null
  }

  export type CaliberAliasAvgAggregateOutputType = {
    id: number | null
    caliberId: number | null
  }

  export type CaliberAliasSumAggregateOutputType = {
    id: number | null
    caliberId: number | null
  }

  export type CaliberAliasMinAggregateOutputType = {
    id: number | null
    caliberId: number | null
    alias: string | null
  }

  export type CaliberAliasMaxAggregateOutputType = {
    id: number | null
    caliberId: number | null
    alias: string | null
  }

  export type CaliberAliasCountAggregateOutputType = {
    id: number
    caliberId: number
    alias: number
    _all: number
  }


  export type CaliberAliasAvgAggregateInputType = {
    id?: true
    caliberId?: true
  }

  export type CaliberAliasSumAggregateInputType = {
    id?: true
    caliberId?: true
  }

  export type CaliberAliasMinAggregateInputType = {
    id?: true
    caliberId?: true
    alias?: true
  }

  export type CaliberAliasMaxAggregateInputType = {
    id?: true
    caliberId?: true
    alias?: true
  }

  export type CaliberAliasCountAggregateInputType = {
    id?: true
    caliberId?: true
    alias?: true
    _all?: true
  }

  export type CaliberAliasAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CaliberAlias to aggregate.
     */
    where?: CaliberAliasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CaliberAliases to fetch.
     */
    orderBy?: CaliberAliasOrderByWithRelationInput | CaliberAliasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CaliberAliasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CaliberAliases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CaliberAliases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CaliberAliases
    **/
    _count?: true | CaliberAliasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CaliberAliasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CaliberAliasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CaliberAliasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CaliberAliasMaxAggregateInputType
  }

  export type GetCaliberAliasAggregateType<T extends CaliberAliasAggregateArgs> = {
        [P in keyof T & keyof AggregateCaliberAlias]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCaliberAlias[P]>
      : GetScalarType<T[P], AggregateCaliberAlias[P]>
  }




  export type CaliberAliasGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CaliberAliasWhereInput
    orderBy?: CaliberAliasOrderByWithAggregationInput | CaliberAliasOrderByWithAggregationInput[]
    by: CaliberAliasScalarFieldEnum[] | CaliberAliasScalarFieldEnum
    having?: CaliberAliasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CaliberAliasCountAggregateInputType | true
    _avg?: CaliberAliasAvgAggregateInputType
    _sum?: CaliberAliasSumAggregateInputType
    _min?: CaliberAliasMinAggregateInputType
    _max?: CaliberAliasMaxAggregateInputType
  }

  export type CaliberAliasGroupByOutputType = {
    id: number
    caliberId: number
    alias: string
    _count: CaliberAliasCountAggregateOutputType | null
    _avg: CaliberAliasAvgAggregateOutputType | null
    _sum: CaliberAliasSumAggregateOutputType | null
    _min: CaliberAliasMinAggregateOutputType | null
    _max: CaliberAliasMaxAggregateOutputType | null
  }

  type GetCaliberAliasGroupByPayload<T extends CaliberAliasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CaliberAliasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CaliberAliasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CaliberAliasGroupByOutputType[P]>
            : GetScalarType<T[P], CaliberAliasGroupByOutputType[P]>
        }
      >
    >


  export type CaliberAliasSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    caliberId?: boolean
    alias?: boolean
    Caliber?: boolean | CaliberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["caliberAlias"]>

  export type CaliberAliasSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    caliberId?: boolean
    alias?: boolean
    Caliber?: boolean | CaliberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["caliberAlias"]>

  export type CaliberAliasSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    caliberId?: boolean
    alias?: boolean
    Caliber?: boolean | CaliberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["caliberAlias"]>

  export type CaliberAliasSelectScalar = {
    id?: boolean
    caliberId?: boolean
    alias?: boolean
  }

  export type CaliberAliasOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "caliberId" | "alias", ExtArgs["result"]["caliberAlias"]>
  export type CaliberAliasInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Caliber?: boolean | CaliberDefaultArgs<ExtArgs>
  }
  export type CaliberAliasIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Caliber?: boolean | CaliberDefaultArgs<ExtArgs>
  }
  export type CaliberAliasIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Caliber?: boolean | CaliberDefaultArgs<ExtArgs>
  }

  export type $CaliberAliasPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CaliberAlias"
    objects: {
      Caliber: Prisma.$CaliberPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      caliberId: number
      alias: string
    }, ExtArgs["result"]["caliberAlias"]>
    composites: {}
  }

  type CaliberAliasGetPayload<S extends boolean | null | undefined | CaliberAliasDefaultArgs> = $Result.GetResult<Prisma.$CaliberAliasPayload, S>

  type CaliberAliasCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CaliberAliasFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CaliberAliasCountAggregateInputType | true
    }

  export interface CaliberAliasDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CaliberAlias'], meta: { name: 'CaliberAlias' } }
    /**
     * Find zero or one CaliberAlias that matches the filter.
     * @param {CaliberAliasFindUniqueArgs} args - Arguments to find a CaliberAlias
     * @example
     * // Get one CaliberAlias
     * const caliberAlias = await prisma.caliberAlias.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CaliberAliasFindUniqueArgs>(args: SelectSubset<T, CaliberAliasFindUniqueArgs<ExtArgs>>): Prisma__CaliberAliasClient<$Result.GetResult<Prisma.$CaliberAliasPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CaliberAlias that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CaliberAliasFindUniqueOrThrowArgs} args - Arguments to find a CaliberAlias
     * @example
     * // Get one CaliberAlias
     * const caliberAlias = await prisma.caliberAlias.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CaliberAliasFindUniqueOrThrowArgs>(args: SelectSubset<T, CaliberAliasFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CaliberAliasClient<$Result.GetResult<Prisma.$CaliberAliasPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CaliberAlias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaliberAliasFindFirstArgs} args - Arguments to find a CaliberAlias
     * @example
     * // Get one CaliberAlias
     * const caliberAlias = await prisma.caliberAlias.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CaliberAliasFindFirstArgs>(args?: SelectSubset<T, CaliberAliasFindFirstArgs<ExtArgs>>): Prisma__CaliberAliasClient<$Result.GetResult<Prisma.$CaliberAliasPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CaliberAlias that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaliberAliasFindFirstOrThrowArgs} args - Arguments to find a CaliberAlias
     * @example
     * // Get one CaliberAlias
     * const caliberAlias = await prisma.caliberAlias.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CaliberAliasFindFirstOrThrowArgs>(args?: SelectSubset<T, CaliberAliasFindFirstOrThrowArgs<ExtArgs>>): Prisma__CaliberAliasClient<$Result.GetResult<Prisma.$CaliberAliasPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CaliberAliases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaliberAliasFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CaliberAliases
     * const caliberAliases = await prisma.caliberAlias.findMany()
     * 
     * // Get first 10 CaliberAliases
     * const caliberAliases = await prisma.caliberAlias.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const caliberAliasWithIdOnly = await prisma.caliberAlias.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CaliberAliasFindManyArgs>(args?: SelectSubset<T, CaliberAliasFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CaliberAliasPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CaliberAlias.
     * @param {CaliberAliasCreateArgs} args - Arguments to create a CaliberAlias.
     * @example
     * // Create one CaliberAlias
     * const CaliberAlias = await prisma.caliberAlias.create({
     *   data: {
     *     // ... data to create a CaliberAlias
     *   }
     * })
     * 
     */
    create<T extends CaliberAliasCreateArgs>(args: SelectSubset<T, CaliberAliasCreateArgs<ExtArgs>>): Prisma__CaliberAliasClient<$Result.GetResult<Prisma.$CaliberAliasPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CaliberAliases.
     * @param {CaliberAliasCreateManyArgs} args - Arguments to create many CaliberAliases.
     * @example
     * // Create many CaliberAliases
     * const caliberAlias = await prisma.caliberAlias.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CaliberAliasCreateManyArgs>(args?: SelectSubset<T, CaliberAliasCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CaliberAliases and returns the data saved in the database.
     * @param {CaliberAliasCreateManyAndReturnArgs} args - Arguments to create many CaliberAliases.
     * @example
     * // Create many CaliberAliases
     * const caliberAlias = await prisma.caliberAlias.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CaliberAliases and only return the `id`
     * const caliberAliasWithIdOnly = await prisma.caliberAlias.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CaliberAliasCreateManyAndReturnArgs>(args?: SelectSubset<T, CaliberAliasCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CaliberAliasPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CaliberAlias.
     * @param {CaliberAliasDeleteArgs} args - Arguments to delete one CaliberAlias.
     * @example
     * // Delete one CaliberAlias
     * const CaliberAlias = await prisma.caliberAlias.delete({
     *   where: {
     *     // ... filter to delete one CaliberAlias
     *   }
     * })
     * 
     */
    delete<T extends CaliberAliasDeleteArgs>(args: SelectSubset<T, CaliberAliasDeleteArgs<ExtArgs>>): Prisma__CaliberAliasClient<$Result.GetResult<Prisma.$CaliberAliasPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CaliberAlias.
     * @param {CaliberAliasUpdateArgs} args - Arguments to update one CaliberAlias.
     * @example
     * // Update one CaliberAlias
     * const caliberAlias = await prisma.caliberAlias.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CaliberAliasUpdateArgs>(args: SelectSubset<T, CaliberAliasUpdateArgs<ExtArgs>>): Prisma__CaliberAliasClient<$Result.GetResult<Prisma.$CaliberAliasPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CaliberAliases.
     * @param {CaliberAliasDeleteManyArgs} args - Arguments to filter CaliberAliases to delete.
     * @example
     * // Delete a few CaliberAliases
     * const { count } = await prisma.caliberAlias.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CaliberAliasDeleteManyArgs>(args?: SelectSubset<T, CaliberAliasDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CaliberAliases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaliberAliasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CaliberAliases
     * const caliberAlias = await prisma.caliberAlias.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CaliberAliasUpdateManyArgs>(args: SelectSubset<T, CaliberAliasUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CaliberAliases and returns the data updated in the database.
     * @param {CaliberAliasUpdateManyAndReturnArgs} args - Arguments to update many CaliberAliases.
     * @example
     * // Update many CaliberAliases
     * const caliberAlias = await prisma.caliberAlias.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CaliberAliases and only return the `id`
     * const caliberAliasWithIdOnly = await prisma.caliberAlias.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CaliberAliasUpdateManyAndReturnArgs>(args: SelectSubset<T, CaliberAliasUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CaliberAliasPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CaliberAlias.
     * @param {CaliberAliasUpsertArgs} args - Arguments to update or create a CaliberAlias.
     * @example
     * // Update or create a CaliberAlias
     * const caliberAlias = await prisma.caliberAlias.upsert({
     *   create: {
     *     // ... data to create a CaliberAlias
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CaliberAlias we want to update
     *   }
     * })
     */
    upsert<T extends CaliberAliasUpsertArgs>(args: SelectSubset<T, CaliberAliasUpsertArgs<ExtArgs>>): Prisma__CaliberAliasClient<$Result.GetResult<Prisma.$CaliberAliasPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CaliberAliases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaliberAliasCountArgs} args - Arguments to filter CaliberAliases to count.
     * @example
     * // Count the number of CaliberAliases
     * const count = await prisma.caliberAlias.count({
     *   where: {
     *     // ... the filter for the CaliberAliases we want to count
     *   }
     * })
    **/
    count<T extends CaliberAliasCountArgs>(
      args?: Subset<T, CaliberAliasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CaliberAliasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CaliberAlias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaliberAliasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CaliberAliasAggregateArgs>(args: Subset<T, CaliberAliasAggregateArgs>): Prisma.PrismaPromise<GetCaliberAliasAggregateType<T>>

    /**
     * Group by CaliberAlias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaliberAliasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CaliberAliasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CaliberAliasGroupByArgs['orderBy'] }
        : { orderBy?: CaliberAliasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CaliberAliasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCaliberAliasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CaliberAlias model
   */
  readonly fields: CaliberAliasFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CaliberAlias.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CaliberAliasClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Caliber<T extends CaliberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CaliberDefaultArgs<ExtArgs>>): Prisma__CaliberClient<$Result.GetResult<Prisma.$CaliberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CaliberAlias model
   */
  interface CaliberAliasFieldRefs {
    readonly id: FieldRef<"CaliberAlias", 'Int'>
    readonly caliberId: FieldRef<"CaliberAlias", 'Int'>
    readonly alias: FieldRef<"CaliberAlias", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CaliberAlias findUnique
   */
  export type CaliberAliasFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaliberAlias
     */
    select?: CaliberAliasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaliberAlias
     */
    omit?: CaliberAliasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaliberAliasInclude<ExtArgs> | null
    /**
     * Filter, which CaliberAlias to fetch.
     */
    where: CaliberAliasWhereUniqueInput
  }

  /**
   * CaliberAlias findUniqueOrThrow
   */
  export type CaliberAliasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaliberAlias
     */
    select?: CaliberAliasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaliberAlias
     */
    omit?: CaliberAliasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaliberAliasInclude<ExtArgs> | null
    /**
     * Filter, which CaliberAlias to fetch.
     */
    where: CaliberAliasWhereUniqueInput
  }

  /**
   * CaliberAlias findFirst
   */
  export type CaliberAliasFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaliberAlias
     */
    select?: CaliberAliasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaliberAlias
     */
    omit?: CaliberAliasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaliberAliasInclude<ExtArgs> | null
    /**
     * Filter, which CaliberAlias to fetch.
     */
    where?: CaliberAliasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CaliberAliases to fetch.
     */
    orderBy?: CaliberAliasOrderByWithRelationInput | CaliberAliasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CaliberAliases.
     */
    cursor?: CaliberAliasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CaliberAliases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CaliberAliases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CaliberAliases.
     */
    distinct?: CaliberAliasScalarFieldEnum | CaliberAliasScalarFieldEnum[]
  }

  /**
   * CaliberAlias findFirstOrThrow
   */
  export type CaliberAliasFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaliberAlias
     */
    select?: CaliberAliasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaliberAlias
     */
    omit?: CaliberAliasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaliberAliasInclude<ExtArgs> | null
    /**
     * Filter, which CaliberAlias to fetch.
     */
    where?: CaliberAliasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CaliberAliases to fetch.
     */
    orderBy?: CaliberAliasOrderByWithRelationInput | CaliberAliasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CaliberAliases.
     */
    cursor?: CaliberAliasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CaliberAliases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CaliberAliases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CaliberAliases.
     */
    distinct?: CaliberAliasScalarFieldEnum | CaliberAliasScalarFieldEnum[]
  }

  /**
   * CaliberAlias findMany
   */
  export type CaliberAliasFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaliberAlias
     */
    select?: CaliberAliasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaliberAlias
     */
    omit?: CaliberAliasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaliberAliasInclude<ExtArgs> | null
    /**
     * Filter, which CaliberAliases to fetch.
     */
    where?: CaliberAliasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CaliberAliases to fetch.
     */
    orderBy?: CaliberAliasOrderByWithRelationInput | CaliberAliasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CaliberAliases.
     */
    cursor?: CaliberAliasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CaliberAliases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CaliberAliases.
     */
    skip?: number
    distinct?: CaliberAliasScalarFieldEnum | CaliberAliasScalarFieldEnum[]
  }

  /**
   * CaliberAlias create
   */
  export type CaliberAliasCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaliberAlias
     */
    select?: CaliberAliasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaliberAlias
     */
    omit?: CaliberAliasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaliberAliasInclude<ExtArgs> | null
    /**
     * The data needed to create a CaliberAlias.
     */
    data: XOR<CaliberAliasCreateInput, CaliberAliasUncheckedCreateInput>
  }

  /**
   * CaliberAlias createMany
   */
  export type CaliberAliasCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CaliberAliases.
     */
    data: CaliberAliasCreateManyInput | CaliberAliasCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CaliberAlias createManyAndReturn
   */
  export type CaliberAliasCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaliberAlias
     */
    select?: CaliberAliasSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CaliberAlias
     */
    omit?: CaliberAliasOmit<ExtArgs> | null
    /**
     * The data used to create many CaliberAliases.
     */
    data: CaliberAliasCreateManyInput | CaliberAliasCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaliberAliasIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CaliberAlias update
   */
  export type CaliberAliasUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaliberAlias
     */
    select?: CaliberAliasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaliberAlias
     */
    omit?: CaliberAliasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaliberAliasInclude<ExtArgs> | null
    /**
     * The data needed to update a CaliberAlias.
     */
    data: XOR<CaliberAliasUpdateInput, CaliberAliasUncheckedUpdateInput>
    /**
     * Choose, which CaliberAlias to update.
     */
    where: CaliberAliasWhereUniqueInput
  }

  /**
   * CaliberAlias updateMany
   */
  export type CaliberAliasUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CaliberAliases.
     */
    data: XOR<CaliberAliasUpdateManyMutationInput, CaliberAliasUncheckedUpdateManyInput>
    /**
     * Filter which CaliberAliases to update
     */
    where?: CaliberAliasWhereInput
    /**
     * Limit how many CaliberAliases to update.
     */
    limit?: number
  }

  /**
   * CaliberAlias updateManyAndReturn
   */
  export type CaliberAliasUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaliberAlias
     */
    select?: CaliberAliasSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CaliberAlias
     */
    omit?: CaliberAliasOmit<ExtArgs> | null
    /**
     * The data used to update CaliberAliases.
     */
    data: XOR<CaliberAliasUpdateManyMutationInput, CaliberAliasUncheckedUpdateManyInput>
    /**
     * Filter which CaliberAliases to update
     */
    where?: CaliberAliasWhereInput
    /**
     * Limit how many CaliberAliases to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaliberAliasIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CaliberAlias upsert
   */
  export type CaliberAliasUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaliberAlias
     */
    select?: CaliberAliasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaliberAlias
     */
    omit?: CaliberAliasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaliberAliasInclude<ExtArgs> | null
    /**
     * The filter to search for the CaliberAlias to update in case it exists.
     */
    where: CaliberAliasWhereUniqueInput
    /**
     * In case the CaliberAlias found by the `where` argument doesn't exist, create a new CaliberAlias with this data.
     */
    create: XOR<CaliberAliasCreateInput, CaliberAliasUncheckedCreateInput>
    /**
     * In case the CaliberAlias was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CaliberAliasUpdateInput, CaliberAliasUncheckedUpdateInput>
  }

  /**
   * CaliberAlias delete
   */
  export type CaliberAliasDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaliberAlias
     */
    select?: CaliberAliasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaliberAlias
     */
    omit?: CaliberAliasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaliberAliasInclude<ExtArgs> | null
    /**
     * Filter which CaliberAlias to delete.
     */
    where: CaliberAliasWhereUniqueInput
  }

  /**
   * CaliberAlias deleteMany
   */
  export type CaliberAliasDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CaliberAliases to delete
     */
    where?: CaliberAliasWhereInput
    /**
     * Limit how many CaliberAliases to delete.
     */
    limit?: number
  }

  /**
   * CaliberAlias without action
   */
  export type CaliberAliasDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaliberAlias
     */
    select?: CaliberAliasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaliberAlias
     */
    omit?: CaliberAliasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaliberAliasInclude<ExtArgs> | null
  }


  /**
   * Model CatalogItem
   */

  export type AggregateCatalogItem = {
    _count: CatalogItemCountAggregateOutputType | null
    _avg: CatalogItemAvgAggregateOutputType | null
    _sum: CatalogItemSumAggregateOutputType | null
    _min: CatalogItemMinAggregateOutputType | null
    _max: CatalogItemMaxAggregateOutputType | null
  }

  export type CatalogItemAvgAggregateOutputType = {
    brandId: number | null
    bestPrice: number | null
    bestRetailerId: number | null
    offerCount: number | null
    bestCpr: number | null
    bestCprShipped: number | null
    upvotes: number | null
    downvotes: number | null
  }

  export type CatalogItemSumAggregateOutputType = {
    brandId: number | null
    bestPrice: number | null
    bestRetailerId: number | null
    offerCount: number | null
    bestCpr: number | null
    bestCprShipped: number | null
    upvotes: number | null
    downvotes: number | null
  }

  export type CatalogItemMinAggregateOutputType = {
    id: string | null
    kind: $Enums.CatalogKind | null
    slug: string | null
    upc: string | null
    mpn: string | null
    title: string | null
    image: string | null
    description: string | null
    brandId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    bestPrice: number | null
    bestRetailerId: number | null
    bestRetailerName: string | null
    offerCount: number | null
    bestCpr: number | null
    bestCprShipped: number | null
    upvotes: number | null
    downvotes: number | null
  }

  export type CatalogItemMaxAggregateOutputType = {
    id: string | null
    kind: $Enums.CatalogKind | null
    slug: string | null
    upc: string | null
    mpn: string | null
    title: string | null
    image: string | null
    description: string | null
    brandId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    bestPrice: number | null
    bestRetailerId: number | null
    bestRetailerName: string | null
    offerCount: number | null
    bestCpr: number | null
    bestCprShipped: number | null
    upvotes: number | null
    downvotes: number | null
  }

  export type CatalogItemCountAggregateOutputType = {
    id: number
    kind: number
    slug: number
    upc: number
    mpn: number
    title: number
    image: number
    description: number
    brandId: number
    createdAt: number
    updatedAt: number
    bestPrice: number
    bestRetailerId: number
    bestRetailerName: number
    offerCount: number
    bestCpr: number
    bestCprShipped: number
    upvotes: number
    downvotes: number
    _all: number
  }


  export type CatalogItemAvgAggregateInputType = {
    brandId?: true
    bestPrice?: true
    bestRetailerId?: true
    offerCount?: true
    bestCpr?: true
    bestCprShipped?: true
    upvotes?: true
    downvotes?: true
  }

  export type CatalogItemSumAggregateInputType = {
    brandId?: true
    bestPrice?: true
    bestRetailerId?: true
    offerCount?: true
    bestCpr?: true
    bestCprShipped?: true
    upvotes?: true
    downvotes?: true
  }

  export type CatalogItemMinAggregateInputType = {
    id?: true
    kind?: true
    slug?: true
    upc?: true
    mpn?: true
    title?: true
    image?: true
    description?: true
    brandId?: true
    createdAt?: true
    updatedAt?: true
    bestPrice?: true
    bestRetailerId?: true
    bestRetailerName?: true
    offerCount?: true
    bestCpr?: true
    bestCprShipped?: true
    upvotes?: true
    downvotes?: true
  }

  export type CatalogItemMaxAggregateInputType = {
    id?: true
    kind?: true
    slug?: true
    upc?: true
    mpn?: true
    title?: true
    image?: true
    description?: true
    brandId?: true
    createdAt?: true
    updatedAt?: true
    bestPrice?: true
    bestRetailerId?: true
    bestRetailerName?: true
    offerCount?: true
    bestCpr?: true
    bestCprShipped?: true
    upvotes?: true
    downvotes?: true
  }

  export type CatalogItemCountAggregateInputType = {
    id?: true
    kind?: true
    slug?: true
    upc?: true
    mpn?: true
    title?: true
    image?: true
    description?: true
    brandId?: true
    createdAt?: true
    updatedAt?: true
    bestPrice?: true
    bestRetailerId?: true
    bestRetailerName?: true
    offerCount?: true
    bestCpr?: true
    bestCprShipped?: true
    upvotes?: true
    downvotes?: true
    _all?: true
  }

  export type CatalogItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CatalogItem to aggregate.
     */
    where?: CatalogItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogItems to fetch.
     */
    orderBy?: CatalogItemOrderByWithRelationInput | CatalogItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CatalogItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CatalogItems
    **/
    _count?: true | CatalogItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CatalogItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CatalogItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CatalogItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CatalogItemMaxAggregateInputType
  }

  export type GetCatalogItemAggregateType<T extends CatalogItemAggregateArgs> = {
        [P in keyof T & keyof AggregateCatalogItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCatalogItem[P]>
      : GetScalarType<T[P], AggregateCatalogItem[P]>
  }




  export type CatalogItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CatalogItemWhereInput
    orderBy?: CatalogItemOrderByWithAggregationInput | CatalogItemOrderByWithAggregationInput[]
    by: CatalogItemScalarFieldEnum[] | CatalogItemScalarFieldEnum
    having?: CatalogItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CatalogItemCountAggregateInputType | true
    _avg?: CatalogItemAvgAggregateInputType
    _sum?: CatalogItemSumAggregateInputType
    _min?: CatalogItemMinAggregateInputType
    _max?: CatalogItemMaxAggregateInputType
  }

  export type CatalogItemGroupByOutputType = {
    id: string
    kind: $Enums.CatalogKind
    slug: string
    upc: string | null
    mpn: string | null
    title: string
    image: string | null
    description: string | null
    brandId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    bestPrice: number | null
    bestRetailerId: number | null
    bestRetailerName: string | null
    offerCount: number | null
    bestCpr: number | null
    bestCprShipped: number | null
    upvotes: number | null
    downvotes: number | null
    _count: CatalogItemCountAggregateOutputType | null
    _avg: CatalogItemAvgAggregateOutputType | null
    _sum: CatalogItemSumAggregateOutputType | null
    _min: CatalogItemMinAggregateOutputType | null
    _max: CatalogItemMaxAggregateOutputType | null
  }

  type GetCatalogItemGroupByPayload<T extends CatalogItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CatalogItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CatalogItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CatalogItemGroupByOutputType[P]>
            : GetScalarType<T[P], CatalogItemGroupByOutputType[P]>
        }
      >
    >


  export type CatalogItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    kind?: boolean
    slug?: boolean
    upc?: boolean
    mpn?: boolean
    title?: boolean
    image?: boolean
    description?: boolean
    brandId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bestPrice?: boolean
    bestRetailerId?: boolean
    bestRetailerName?: boolean
    offerCount?: boolean
    bestCpr?: boolean
    bestCprShipped?: boolean
    upvotes?: boolean
    downvotes?: boolean
    AccessoryFitment?: boolean | CatalogItem$AccessoryFitmentArgs<ExtArgs>
    AccessorySpecs?: boolean | CatalogItem$AccessorySpecsArgs<ExtArgs>
    Alert?: boolean | CatalogItem$AlertArgs<ExtArgs>
    AmmoSpecs?: boolean | CatalogItem$AmmoSpecsArgs<ExtArgs>
    Brand?: boolean | CatalogItem$BrandArgs<ExtArgs>
    FirearmSpecs?: boolean | CatalogItem$FirearmSpecsArgs<ExtArgs>
    Offer?: boolean | CatalogItem$OfferArgs<ExtArgs>
    OwnedFirearm?: boolean | CatalogItem$OwnedFirearmArgs<ExtArgs>
    _count?: boolean | CatalogItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["catalogItem"]>

  export type CatalogItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    kind?: boolean
    slug?: boolean
    upc?: boolean
    mpn?: boolean
    title?: boolean
    image?: boolean
    description?: boolean
    brandId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bestPrice?: boolean
    bestRetailerId?: boolean
    bestRetailerName?: boolean
    offerCount?: boolean
    bestCpr?: boolean
    bestCprShipped?: boolean
    upvotes?: boolean
    downvotes?: boolean
    Brand?: boolean | CatalogItem$BrandArgs<ExtArgs>
  }, ExtArgs["result"]["catalogItem"]>

  export type CatalogItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    kind?: boolean
    slug?: boolean
    upc?: boolean
    mpn?: boolean
    title?: boolean
    image?: boolean
    description?: boolean
    brandId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bestPrice?: boolean
    bestRetailerId?: boolean
    bestRetailerName?: boolean
    offerCount?: boolean
    bestCpr?: boolean
    bestCprShipped?: boolean
    upvotes?: boolean
    downvotes?: boolean
    Brand?: boolean | CatalogItem$BrandArgs<ExtArgs>
  }, ExtArgs["result"]["catalogItem"]>

  export type CatalogItemSelectScalar = {
    id?: boolean
    kind?: boolean
    slug?: boolean
    upc?: boolean
    mpn?: boolean
    title?: boolean
    image?: boolean
    description?: boolean
    brandId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bestPrice?: boolean
    bestRetailerId?: boolean
    bestRetailerName?: boolean
    offerCount?: boolean
    bestCpr?: boolean
    bestCprShipped?: boolean
    upvotes?: boolean
    downvotes?: boolean
  }

  export type CatalogItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "kind" | "slug" | "upc" | "mpn" | "title" | "image" | "description" | "brandId" | "createdAt" | "updatedAt" | "bestPrice" | "bestRetailerId" | "bestRetailerName" | "offerCount" | "bestCpr" | "bestCprShipped" | "upvotes" | "downvotes", ExtArgs["result"]["catalogItem"]>
  export type CatalogItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AccessoryFitment?: boolean | CatalogItem$AccessoryFitmentArgs<ExtArgs>
    AccessorySpecs?: boolean | CatalogItem$AccessorySpecsArgs<ExtArgs>
    Alert?: boolean | CatalogItem$AlertArgs<ExtArgs>
    AmmoSpecs?: boolean | CatalogItem$AmmoSpecsArgs<ExtArgs>
    Brand?: boolean | CatalogItem$BrandArgs<ExtArgs>
    FirearmSpecs?: boolean | CatalogItem$FirearmSpecsArgs<ExtArgs>
    Offer?: boolean | CatalogItem$OfferArgs<ExtArgs>
    OwnedFirearm?: boolean | CatalogItem$OwnedFirearmArgs<ExtArgs>
    _count?: boolean | CatalogItemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CatalogItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Brand?: boolean | CatalogItem$BrandArgs<ExtArgs>
  }
  export type CatalogItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Brand?: boolean | CatalogItem$BrandArgs<ExtArgs>
  }

  export type $CatalogItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CatalogItem"
    objects: {
      AccessoryFitment: Prisma.$AccessoryFitmentPayload<ExtArgs>[]
      AccessorySpecs: Prisma.$AccessorySpecsPayload<ExtArgs> | null
      Alert: Prisma.$AlertPayload<ExtArgs>[]
      AmmoSpecs: Prisma.$AmmoSpecsPayload<ExtArgs> | null
      Brand: Prisma.$BrandPayload<ExtArgs> | null
      FirearmSpecs: Prisma.$FirearmSpecsPayload<ExtArgs> | null
      Offer: Prisma.$OfferPayload<ExtArgs>[]
      OwnedFirearm: Prisma.$OwnedFirearmPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      kind: $Enums.CatalogKind
      slug: string
      upc: string | null
      mpn: string | null
      title: string
      image: string | null
      description: string | null
      brandId: number | null
      createdAt: Date | null
      updatedAt: Date | null
      bestPrice: number | null
      bestRetailerId: number | null
      bestRetailerName: string | null
      offerCount: number | null
      bestCpr: number | null
      bestCprShipped: number | null
      upvotes: number | null
      downvotes: number | null
    }, ExtArgs["result"]["catalogItem"]>
    composites: {}
  }

  type CatalogItemGetPayload<S extends boolean | null | undefined | CatalogItemDefaultArgs> = $Result.GetResult<Prisma.$CatalogItemPayload, S>

  type CatalogItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CatalogItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CatalogItemCountAggregateInputType | true
    }

  export interface CatalogItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CatalogItem'], meta: { name: 'CatalogItem' } }
    /**
     * Find zero or one CatalogItem that matches the filter.
     * @param {CatalogItemFindUniqueArgs} args - Arguments to find a CatalogItem
     * @example
     * // Get one CatalogItem
     * const catalogItem = await prisma.catalogItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CatalogItemFindUniqueArgs>(args: SelectSubset<T, CatalogItemFindUniqueArgs<ExtArgs>>): Prisma__CatalogItemClient<$Result.GetResult<Prisma.$CatalogItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CatalogItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CatalogItemFindUniqueOrThrowArgs} args - Arguments to find a CatalogItem
     * @example
     * // Get one CatalogItem
     * const catalogItem = await prisma.catalogItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CatalogItemFindUniqueOrThrowArgs>(args: SelectSubset<T, CatalogItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CatalogItemClient<$Result.GetResult<Prisma.$CatalogItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CatalogItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogItemFindFirstArgs} args - Arguments to find a CatalogItem
     * @example
     * // Get one CatalogItem
     * const catalogItem = await prisma.catalogItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CatalogItemFindFirstArgs>(args?: SelectSubset<T, CatalogItemFindFirstArgs<ExtArgs>>): Prisma__CatalogItemClient<$Result.GetResult<Prisma.$CatalogItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CatalogItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogItemFindFirstOrThrowArgs} args - Arguments to find a CatalogItem
     * @example
     * // Get one CatalogItem
     * const catalogItem = await prisma.catalogItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CatalogItemFindFirstOrThrowArgs>(args?: SelectSubset<T, CatalogItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__CatalogItemClient<$Result.GetResult<Prisma.$CatalogItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CatalogItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CatalogItems
     * const catalogItems = await prisma.catalogItem.findMany()
     * 
     * // Get first 10 CatalogItems
     * const catalogItems = await prisma.catalogItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const catalogItemWithIdOnly = await prisma.catalogItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CatalogItemFindManyArgs>(args?: SelectSubset<T, CatalogItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatalogItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CatalogItem.
     * @param {CatalogItemCreateArgs} args - Arguments to create a CatalogItem.
     * @example
     * // Create one CatalogItem
     * const CatalogItem = await prisma.catalogItem.create({
     *   data: {
     *     // ... data to create a CatalogItem
     *   }
     * })
     * 
     */
    create<T extends CatalogItemCreateArgs>(args: SelectSubset<T, CatalogItemCreateArgs<ExtArgs>>): Prisma__CatalogItemClient<$Result.GetResult<Prisma.$CatalogItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CatalogItems.
     * @param {CatalogItemCreateManyArgs} args - Arguments to create many CatalogItems.
     * @example
     * // Create many CatalogItems
     * const catalogItem = await prisma.catalogItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CatalogItemCreateManyArgs>(args?: SelectSubset<T, CatalogItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CatalogItems and returns the data saved in the database.
     * @param {CatalogItemCreateManyAndReturnArgs} args - Arguments to create many CatalogItems.
     * @example
     * // Create many CatalogItems
     * const catalogItem = await prisma.catalogItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CatalogItems and only return the `id`
     * const catalogItemWithIdOnly = await prisma.catalogItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CatalogItemCreateManyAndReturnArgs>(args?: SelectSubset<T, CatalogItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatalogItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CatalogItem.
     * @param {CatalogItemDeleteArgs} args - Arguments to delete one CatalogItem.
     * @example
     * // Delete one CatalogItem
     * const CatalogItem = await prisma.catalogItem.delete({
     *   where: {
     *     // ... filter to delete one CatalogItem
     *   }
     * })
     * 
     */
    delete<T extends CatalogItemDeleteArgs>(args: SelectSubset<T, CatalogItemDeleteArgs<ExtArgs>>): Prisma__CatalogItemClient<$Result.GetResult<Prisma.$CatalogItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CatalogItem.
     * @param {CatalogItemUpdateArgs} args - Arguments to update one CatalogItem.
     * @example
     * // Update one CatalogItem
     * const catalogItem = await prisma.catalogItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CatalogItemUpdateArgs>(args: SelectSubset<T, CatalogItemUpdateArgs<ExtArgs>>): Prisma__CatalogItemClient<$Result.GetResult<Prisma.$CatalogItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CatalogItems.
     * @param {CatalogItemDeleteManyArgs} args - Arguments to filter CatalogItems to delete.
     * @example
     * // Delete a few CatalogItems
     * const { count } = await prisma.catalogItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CatalogItemDeleteManyArgs>(args?: SelectSubset<T, CatalogItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CatalogItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CatalogItems
     * const catalogItem = await prisma.catalogItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CatalogItemUpdateManyArgs>(args: SelectSubset<T, CatalogItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CatalogItems and returns the data updated in the database.
     * @param {CatalogItemUpdateManyAndReturnArgs} args - Arguments to update many CatalogItems.
     * @example
     * // Update many CatalogItems
     * const catalogItem = await prisma.catalogItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CatalogItems and only return the `id`
     * const catalogItemWithIdOnly = await prisma.catalogItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CatalogItemUpdateManyAndReturnArgs>(args: SelectSubset<T, CatalogItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatalogItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CatalogItem.
     * @param {CatalogItemUpsertArgs} args - Arguments to update or create a CatalogItem.
     * @example
     * // Update or create a CatalogItem
     * const catalogItem = await prisma.catalogItem.upsert({
     *   create: {
     *     // ... data to create a CatalogItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CatalogItem we want to update
     *   }
     * })
     */
    upsert<T extends CatalogItemUpsertArgs>(args: SelectSubset<T, CatalogItemUpsertArgs<ExtArgs>>): Prisma__CatalogItemClient<$Result.GetResult<Prisma.$CatalogItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CatalogItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogItemCountArgs} args - Arguments to filter CatalogItems to count.
     * @example
     * // Count the number of CatalogItems
     * const count = await prisma.catalogItem.count({
     *   where: {
     *     // ... the filter for the CatalogItems we want to count
     *   }
     * })
    **/
    count<T extends CatalogItemCountArgs>(
      args?: Subset<T, CatalogItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CatalogItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CatalogItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CatalogItemAggregateArgs>(args: Subset<T, CatalogItemAggregateArgs>): Prisma.PrismaPromise<GetCatalogItemAggregateType<T>>

    /**
     * Group by CatalogItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CatalogItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CatalogItemGroupByArgs['orderBy'] }
        : { orderBy?: CatalogItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CatalogItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCatalogItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CatalogItem model
   */
  readonly fields: CatalogItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CatalogItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CatalogItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    AccessoryFitment<T extends CatalogItem$AccessoryFitmentArgs<ExtArgs> = {}>(args?: Subset<T, CatalogItem$AccessoryFitmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccessoryFitmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    AccessorySpecs<T extends CatalogItem$AccessorySpecsArgs<ExtArgs> = {}>(args?: Subset<T, CatalogItem$AccessorySpecsArgs<ExtArgs>>): Prisma__AccessorySpecsClient<$Result.GetResult<Prisma.$AccessorySpecsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Alert<T extends CatalogItem$AlertArgs<ExtArgs> = {}>(args?: Subset<T, CatalogItem$AlertArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    AmmoSpecs<T extends CatalogItem$AmmoSpecsArgs<ExtArgs> = {}>(args?: Subset<T, CatalogItem$AmmoSpecsArgs<ExtArgs>>): Prisma__AmmoSpecsClient<$Result.GetResult<Prisma.$AmmoSpecsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Brand<T extends CatalogItem$BrandArgs<ExtArgs> = {}>(args?: Subset<T, CatalogItem$BrandArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    FirearmSpecs<T extends CatalogItem$FirearmSpecsArgs<ExtArgs> = {}>(args?: Subset<T, CatalogItem$FirearmSpecsArgs<ExtArgs>>): Prisma__FirearmSpecsClient<$Result.GetResult<Prisma.$FirearmSpecsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Offer<T extends CatalogItem$OfferArgs<ExtArgs> = {}>(args?: Subset<T, CatalogItem$OfferArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    OwnedFirearm<T extends CatalogItem$OwnedFirearmArgs<ExtArgs> = {}>(args?: Subset<T, CatalogItem$OwnedFirearmArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OwnedFirearmPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CatalogItem model
   */
  interface CatalogItemFieldRefs {
    readonly id: FieldRef<"CatalogItem", 'String'>
    readonly kind: FieldRef<"CatalogItem", 'CatalogKind'>
    readonly slug: FieldRef<"CatalogItem", 'String'>
    readonly upc: FieldRef<"CatalogItem", 'String'>
    readonly mpn: FieldRef<"CatalogItem", 'String'>
    readonly title: FieldRef<"CatalogItem", 'String'>
    readonly image: FieldRef<"CatalogItem", 'String'>
    readonly description: FieldRef<"CatalogItem", 'String'>
    readonly brandId: FieldRef<"CatalogItem", 'Int'>
    readonly createdAt: FieldRef<"CatalogItem", 'DateTime'>
    readonly updatedAt: FieldRef<"CatalogItem", 'DateTime'>
    readonly bestPrice: FieldRef<"CatalogItem", 'Float'>
    readonly bestRetailerId: FieldRef<"CatalogItem", 'Int'>
    readonly bestRetailerName: FieldRef<"CatalogItem", 'String'>
    readonly offerCount: FieldRef<"CatalogItem", 'Int'>
    readonly bestCpr: FieldRef<"CatalogItem", 'Float'>
    readonly bestCprShipped: FieldRef<"CatalogItem", 'Float'>
    readonly upvotes: FieldRef<"CatalogItem", 'Int'>
    readonly downvotes: FieldRef<"CatalogItem", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * CatalogItem findUnique
   */
  export type CatalogItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogItem
     */
    select?: CatalogItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CatalogItem
     */
    omit?: CatalogItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogItemInclude<ExtArgs> | null
    /**
     * Filter, which CatalogItem to fetch.
     */
    where: CatalogItemWhereUniqueInput
  }

  /**
   * CatalogItem findUniqueOrThrow
   */
  export type CatalogItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogItem
     */
    select?: CatalogItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CatalogItem
     */
    omit?: CatalogItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogItemInclude<ExtArgs> | null
    /**
     * Filter, which CatalogItem to fetch.
     */
    where: CatalogItemWhereUniqueInput
  }

  /**
   * CatalogItem findFirst
   */
  export type CatalogItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogItem
     */
    select?: CatalogItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CatalogItem
     */
    omit?: CatalogItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogItemInclude<ExtArgs> | null
    /**
     * Filter, which CatalogItem to fetch.
     */
    where?: CatalogItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogItems to fetch.
     */
    orderBy?: CatalogItemOrderByWithRelationInput | CatalogItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CatalogItems.
     */
    cursor?: CatalogItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CatalogItems.
     */
    distinct?: CatalogItemScalarFieldEnum | CatalogItemScalarFieldEnum[]
  }

  /**
   * CatalogItem findFirstOrThrow
   */
  export type CatalogItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogItem
     */
    select?: CatalogItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CatalogItem
     */
    omit?: CatalogItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogItemInclude<ExtArgs> | null
    /**
     * Filter, which CatalogItem to fetch.
     */
    where?: CatalogItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogItems to fetch.
     */
    orderBy?: CatalogItemOrderByWithRelationInput | CatalogItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CatalogItems.
     */
    cursor?: CatalogItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CatalogItems.
     */
    distinct?: CatalogItemScalarFieldEnum | CatalogItemScalarFieldEnum[]
  }

  /**
   * CatalogItem findMany
   */
  export type CatalogItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogItem
     */
    select?: CatalogItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CatalogItem
     */
    omit?: CatalogItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogItemInclude<ExtArgs> | null
    /**
     * Filter, which CatalogItems to fetch.
     */
    where?: CatalogItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogItems to fetch.
     */
    orderBy?: CatalogItemOrderByWithRelationInput | CatalogItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CatalogItems.
     */
    cursor?: CatalogItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogItems.
     */
    skip?: number
    distinct?: CatalogItemScalarFieldEnum | CatalogItemScalarFieldEnum[]
  }

  /**
   * CatalogItem create
   */
  export type CatalogItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogItem
     */
    select?: CatalogItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CatalogItem
     */
    omit?: CatalogItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogItemInclude<ExtArgs> | null
    /**
     * The data needed to create a CatalogItem.
     */
    data: XOR<CatalogItemCreateInput, CatalogItemUncheckedCreateInput>
  }

  /**
   * CatalogItem createMany
   */
  export type CatalogItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CatalogItems.
     */
    data: CatalogItemCreateManyInput | CatalogItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CatalogItem createManyAndReturn
   */
  export type CatalogItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogItem
     */
    select?: CatalogItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CatalogItem
     */
    omit?: CatalogItemOmit<ExtArgs> | null
    /**
     * The data used to create many CatalogItems.
     */
    data: CatalogItemCreateManyInput | CatalogItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CatalogItem update
   */
  export type CatalogItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogItem
     */
    select?: CatalogItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CatalogItem
     */
    omit?: CatalogItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogItemInclude<ExtArgs> | null
    /**
     * The data needed to update a CatalogItem.
     */
    data: XOR<CatalogItemUpdateInput, CatalogItemUncheckedUpdateInput>
    /**
     * Choose, which CatalogItem to update.
     */
    where: CatalogItemWhereUniqueInput
  }

  /**
   * CatalogItem updateMany
   */
  export type CatalogItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CatalogItems.
     */
    data: XOR<CatalogItemUpdateManyMutationInput, CatalogItemUncheckedUpdateManyInput>
    /**
     * Filter which CatalogItems to update
     */
    where?: CatalogItemWhereInput
    /**
     * Limit how many CatalogItems to update.
     */
    limit?: number
  }

  /**
   * CatalogItem updateManyAndReturn
   */
  export type CatalogItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogItem
     */
    select?: CatalogItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CatalogItem
     */
    omit?: CatalogItemOmit<ExtArgs> | null
    /**
     * The data used to update CatalogItems.
     */
    data: XOR<CatalogItemUpdateManyMutationInput, CatalogItemUncheckedUpdateManyInput>
    /**
     * Filter which CatalogItems to update
     */
    where?: CatalogItemWhereInput
    /**
     * Limit how many CatalogItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CatalogItem upsert
   */
  export type CatalogItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogItem
     */
    select?: CatalogItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CatalogItem
     */
    omit?: CatalogItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogItemInclude<ExtArgs> | null
    /**
     * The filter to search for the CatalogItem to update in case it exists.
     */
    where: CatalogItemWhereUniqueInput
    /**
     * In case the CatalogItem found by the `where` argument doesn't exist, create a new CatalogItem with this data.
     */
    create: XOR<CatalogItemCreateInput, CatalogItemUncheckedCreateInput>
    /**
     * In case the CatalogItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CatalogItemUpdateInput, CatalogItemUncheckedUpdateInput>
  }

  /**
   * CatalogItem delete
   */
  export type CatalogItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogItem
     */
    select?: CatalogItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CatalogItem
     */
    omit?: CatalogItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogItemInclude<ExtArgs> | null
    /**
     * Filter which CatalogItem to delete.
     */
    where: CatalogItemWhereUniqueInput
  }

  /**
   * CatalogItem deleteMany
   */
  export type CatalogItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CatalogItems to delete
     */
    where?: CatalogItemWhereInput
    /**
     * Limit how many CatalogItems to delete.
     */
    limit?: number
  }

  /**
   * CatalogItem.AccessoryFitment
   */
  export type CatalogItem$AccessoryFitmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessoryFitment
     */
    select?: AccessoryFitmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessoryFitment
     */
    omit?: AccessoryFitmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessoryFitmentInclude<ExtArgs> | null
    where?: AccessoryFitmentWhereInput
    orderBy?: AccessoryFitmentOrderByWithRelationInput | AccessoryFitmentOrderByWithRelationInput[]
    cursor?: AccessoryFitmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccessoryFitmentScalarFieldEnum | AccessoryFitmentScalarFieldEnum[]
  }

  /**
   * CatalogItem.AccessorySpecs
   */
  export type CatalogItem$AccessorySpecsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessorySpecs
     */
    select?: AccessorySpecsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessorySpecs
     */
    omit?: AccessorySpecsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessorySpecsInclude<ExtArgs> | null
    where?: AccessorySpecsWhereInput
  }

  /**
   * CatalogItem.Alert
   */
  export type CatalogItem$AlertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    where?: AlertWhereInput
    orderBy?: AlertOrderByWithRelationInput | AlertOrderByWithRelationInput[]
    cursor?: AlertWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AlertScalarFieldEnum | AlertScalarFieldEnum[]
  }

  /**
   * CatalogItem.AmmoSpecs
   */
  export type CatalogItem$AmmoSpecsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmmoSpecs
     */
    select?: AmmoSpecsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmmoSpecs
     */
    omit?: AmmoSpecsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmmoSpecsInclude<ExtArgs> | null
    where?: AmmoSpecsWhereInput
  }

  /**
   * CatalogItem.Brand
   */
  export type CatalogItem$BrandArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    where?: BrandWhereInput
  }

  /**
   * CatalogItem.FirearmSpecs
   */
  export type CatalogItem$FirearmSpecsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FirearmSpecs
     */
    select?: FirearmSpecsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FirearmSpecs
     */
    omit?: FirearmSpecsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FirearmSpecsInclude<ExtArgs> | null
    where?: FirearmSpecsWhereInput
  }

  /**
   * CatalogItem.Offer
   */
  export type CatalogItem$OfferArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Offer
     */
    omit?: OfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    where?: OfferWhereInput
    orderBy?: OfferOrderByWithRelationInput | OfferOrderByWithRelationInput[]
    cursor?: OfferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OfferScalarFieldEnum | OfferScalarFieldEnum[]
  }

  /**
   * CatalogItem.OwnedFirearm
   */
  export type CatalogItem$OwnedFirearmArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnedFirearm
     */
    select?: OwnedFirearmSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OwnedFirearm
     */
    omit?: OwnedFirearmOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnedFirearmInclude<ExtArgs> | null
    where?: OwnedFirearmWhereInput
    orderBy?: OwnedFirearmOrderByWithRelationInput | OwnedFirearmOrderByWithRelationInput[]
    cursor?: OwnedFirearmWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OwnedFirearmScalarFieldEnum | OwnedFirearmScalarFieldEnum[]
  }

  /**
   * CatalogItem without action
   */
  export type CatalogItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogItem
     */
    select?: CatalogItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CatalogItem
     */
    omit?: CatalogItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogItemInclude<ExtArgs> | null
  }


  /**
   * Model FirearmCategory
   */

  export type AggregateFirearmCategory = {
    _count: FirearmCategoryCountAggregateOutputType | null
    _avg: FirearmCategoryAvgAggregateOutputType | null
    _sum: FirearmCategorySumAggregateOutputType | null
    _min: FirearmCategoryMinAggregateOutputType | null
    _max: FirearmCategoryMaxAggregateOutputType | null
  }

  export type FirearmCategoryAvgAggregateOutputType = {
    id: number | null
  }

  export type FirearmCategorySumAggregateOutputType = {
    id: number | null
  }

  export type FirearmCategoryMinAggregateOutputType = {
    id: number | null
    name: string | null
    slug: string | null
  }

  export type FirearmCategoryMaxAggregateOutputType = {
    id: number | null
    name: string | null
    slug: string | null
  }

  export type FirearmCategoryCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    _all: number
  }


  export type FirearmCategoryAvgAggregateInputType = {
    id?: true
  }

  export type FirearmCategorySumAggregateInputType = {
    id?: true
  }

  export type FirearmCategoryMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
  }

  export type FirearmCategoryMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
  }

  export type FirearmCategoryCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    _all?: true
  }

  export type FirearmCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FirearmCategory to aggregate.
     */
    where?: FirearmCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FirearmCategories to fetch.
     */
    orderBy?: FirearmCategoryOrderByWithRelationInput | FirearmCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FirearmCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FirearmCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FirearmCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FirearmCategories
    **/
    _count?: true | FirearmCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FirearmCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FirearmCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FirearmCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FirearmCategoryMaxAggregateInputType
  }

  export type GetFirearmCategoryAggregateType<T extends FirearmCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateFirearmCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFirearmCategory[P]>
      : GetScalarType<T[P], AggregateFirearmCategory[P]>
  }




  export type FirearmCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FirearmCategoryWhereInput
    orderBy?: FirearmCategoryOrderByWithAggregationInput | FirearmCategoryOrderByWithAggregationInput[]
    by: FirearmCategoryScalarFieldEnum[] | FirearmCategoryScalarFieldEnum
    having?: FirearmCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FirearmCategoryCountAggregateInputType | true
    _avg?: FirearmCategoryAvgAggregateInputType
    _sum?: FirearmCategorySumAggregateInputType
    _min?: FirearmCategoryMinAggregateInputType
    _max?: FirearmCategoryMaxAggregateInputType
  }

  export type FirearmCategoryGroupByOutputType = {
    id: number
    name: string
    slug: string
    _count: FirearmCategoryCountAggregateOutputType | null
    _avg: FirearmCategoryAvgAggregateOutputType | null
    _sum: FirearmCategorySumAggregateOutputType | null
    _min: FirearmCategoryMinAggregateOutputType | null
    _max: FirearmCategoryMaxAggregateOutputType | null
  }

  type GetFirearmCategoryGroupByPayload<T extends FirearmCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FirearmCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FirearmCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FirearmCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], FirearmCategoryGroupByOutputType[P]>
        }
      >
    >


  export type FirearmCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    FirearmSpecs?: boolean | FirearmCategory$FirearmSpecsArgs<ExtArgs>
    _count?: boolean | FirearmCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["firearmCategory"]>

  export type FirearmCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
  }, ExtArgs["result"]["firearmCategory"]>

  export type FirearmCategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
  }, ExtArgs["result"]["firearmCategory"]>

  export type FirearmCategorySelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
  }

  export type FirearmCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug", ExtArgs["result"]["firearmCategory"]>
  export type FirearmCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    FirearmSpecs?: boolean | FirearmCategory$FirearmSpecsArgs<ExtArgs>
    _count?: boolean | FirearmCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FirearmCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type FirearmCategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $FirearmCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FirearmCategory"
    objects: {
      FirearmSpecs: Prisma.$FirearmSpecsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      slug: string
    }, ExtArgs["result"]["firearmCategory"]>
    composites: {}
  }

  type FirearmCategoryGetPayload<S extends boolean | null | undefined | FirearmCategoryDefaultArgs> = $Result.GetResult<Prisma.$FirearmCategoryPayload, S>

  type FirearmCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FirearmCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FirearmCategoryCountAggregateInputType | true
    }

  export interface FirearmCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FirearmCategory'], meta: { name: 'FirearmCategory' } }
    /**
     * Find zero or one FirearmCategory that matches the filter.
     * @param {FirearmCategoryFindUniqueArgs} args - Arguments to find a FirearmCategory
     * @example
     * // Get one FirearmCategory
     * const firearmCategory = await prisma.firearmCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FirearmCategoryFindUniqueArgs>(args: SelectSubset<T, FirearmCategoryFindUniqueArgs<ExtArgs>>): Prisma__FirearmCategoryClient<$Result.GetResult<Prisma.$FirearmCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FirearmCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FirearmCategoryFindUniqueOrThrowArgs} args - Arguments to find a FirearmCategory
     * @example
     * // Get one FirearmCategory
     * const firearmCategory = await prisma.firearmCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FirearmCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, FirearmCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FirearmCategoryClient<$Result.GetResult<Prisma.$FirearmCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FirearmCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FirearmCategoryFindFirstArgs} args - Arguments to find a FirearmCategory
     * @example
     * // Get one FirearmCategory
     * const firearmCategory = await prisma.firearmCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FirearmCategoryFindFirstArgs>(args?: SelectSubset<T, FirearmCategoryFindFirstArgs<ExtArgs>>): Prisma__FirearmCategoryClient<$Result.GetResult<Prisma.$FirearmCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FirearmCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FirearmCategoryFindFirstOrThrowArgs} args - Arguments to find a FirearmCategory
     * @example
     * // Get one FirearmCategory
     * const firearmCategory = await prisma.firearmCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FirearmCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, FirearmCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__FirearmCategoryClient<$Result.GetResult<Prisma.$FirearmCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FirearmCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FirearmCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FirearmCategories
     * const firearmCategories = await prisma.firearmCategory.findMany()
     * 
     * // Get first 10 FirearmCategories
     * const firearmCategories = await prisma.firearmCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const firearmCategoryWithIdOnly = await prisma.firearmCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FirearmCategoryFindManyArgs>(args?: SelectSubset<T, FirearmCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FirearmCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FirearmCategory.
     * @param {FirearmCategoryCreateArgs} args - Arguments to create a FirearmCategory.
     * @example
     * // Create one FirearmCategory
     * const FirearmCategory = await prisma.firearmCategory.create({
     *   data: {
     *     // ... data to create a FirearmCategory
     *   }
     * })
     * 
     */
    create<T extends FirearmCategoryCreateArgs>(args: SelectSubset<T, FirearmCategoryCreateArgs<ExtArgs>>): Prisma__FirearmCategoryClient<$Result.GetResult<Prisma.$FirearmCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FirearmCategories.
     * @param {FirearmCategoryCreateManyArgs} args - Arguments to create many FirearmCategories.
     * @example
     * // Create many FirearmCategories
     * const firearmCategory = await prisma.firearmCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FirearmCategoryCreateManyArgs>(args?: SelectSubset<T, FirearmCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FirearmCategories and returns the data saved in the database.
     * @param {FirearmCategoryCreateManyAndReturnArgs} args - Arguments to create many FirearmCategories.
     * @example
     * // Create many FirearmCategories
     * const firearmCategory = await prisma.firearmCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FirearmCategories and only return the `id`
     * const firearmCategoryWithIdOnly = await prisma.firearmCategory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FirearmCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, FirearmCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FirearmCategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FirearmCategory.
     * @param {FirearmCategoryDeleteArgs} args - Arguments to delete one FirearmCategory.
     * @example
     * // Delete one FirearmCategory
     * const FirearmCategory = await prisma.firearmCategory.delete({
     *   where: {
     *     // ... filter to delete one FirearmCategory
     *   }
     * })
     * 
     */
    delete<T extends FirearmCategoryDeleteArgs>(args: SelectSubset<T, FirearmCategoryDeleteArgs<ExtArgs>>): Prisma__FirearmCategoryClient<$Result.GetResult<Prisma.$FirearmCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FirearmCategory.
     * @param {FirearmCategoryUpdateArgs} args - Arguments to update one FirearmCategory.
     * @example
     * // Update one FirearmCategory
     * const firearmCategory = await prisma.firearmCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FirearmCategoryUpdateArgs>(args: SelectSubset<T, FirearmCategoryUpdateArgs<ExtArgs>>): Prisma__FirearmCategoryClient<$Result.GetResult<Prisma.$FirearmCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FirearmCategories.
     * @param {FirearmCategoryDeleteManyArgs} args - Arguments to filter FirearmCategories to delete.
     * @example
     * // Delete a few FirearmCategories
     * const { count } = await prisma.firearmCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FirearmCategoryDeleteManyArgs>(args?: SelectSubset<T, FirearmCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FirearmCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FirearmCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FirearmCategories
     * const firearmCategory = await prisma.firearmCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FirearmCategoryUpdateManyArgs>(args: SelectSubset<T, FirearmCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FirearmCategories and returns the data updated in the database.
     * @param {FirearmCategoryUpdateManyAndReturnArgs} args - Arguments to update many FirearmCategories.
     * @example
     * // Update many FirearmCategories
     * const firearmCategory = await prisma.firearmCategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FirearmCategories and only return the `id`
     * const firearmCategoryWithIdOnly = await prisma.firearmCategory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FirearmCategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, FirearmCategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FirearmCategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FirearmCategory.
     * @param {FirearmCategoryUpsertArgs} args - Arguments to update or create a FirearmCategory.
     * @example
     * // Update or create a FirearmCategory
     * const firearmCategory = await prisma.firearmCategory.upsert({
     *   create: {
     *     // ... data to create a FirearmCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FirearmCategory we want to update
     *   }
     * })
     */
    upsert<T extends FirearmCategoryUpsertArgs>(args: SelectSubset<T, FirearmCategoryUpsertArgs<ExtArgs>>): Prisma__FirearmCategoryClient<$Result.GetResult<Prisma.$FirearmCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FirearmCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FirearmCategoryCountArgs} args - Arguments to filter FirearmCategories to count.
     * @example
     * // Count the number of FirearmCategories
     * const count = await prisma.firearmCategory.count({
     *   where: {
     *     // ... the filter for the FirearmCategories we want to count
     *   }
     * })
    **/
    count<T extends FirearmCategoryCountArgs>(
      args?: Subset<T, FirearmCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FirearmCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FirearmCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FirearmCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FirearmCategoryAggregateArgs>(args: Subset<T, FirearmCategoryAggregateArgs>): Prisma.PrismaPromise<GetFirearmCategoryAggregateType<T>>

    /**
     * Group by FirearmCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FirearmCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FirearmCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FirearmCategoryGroupByArgs['orderBy'] }
        : { orderBy?: FirearmCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FirearmCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFirearmCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FirearmCategory model
   */
  readonly fields: FirearmCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FirearmCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FirearmCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    FirearmSpecs<T extends FirearmCategory$FirearmSpecsArgs<ExtArgs> = {}>(args?: Subset<T, FirearmCategory$FirearmSpecsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FirearmSpecsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FirearmCategory model
   */
  interface FirearmCategoryFieldRefs {
    readonly id: FieldRef<"FirearmCategory", 'Int'>
    readonly name: FieldRef<"FirearmCategory", 'String'>
    readonly slug: FieldRef<"FirearmCategory", 'String'>
  }
    

  // Custom InputTypes
  /**
   * FirearmCategory findUnique
   */
  export type FirearmCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FirearmCategory
     */
    select?: FirearmCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FirearmCategory
     */
    omit?: FirearmCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FirearmCategoryInclude<ExtArgs> | null
    /**
     * Filter, which FirearmCategory to fetch.
     */
    where: FirearmCategoryWhereUniqueInput
  }

  /**
   * FirearmCategory findUniqueOrThrow
   */
  export type FirearmCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FirearmCategory
     */
    select?: FirearmCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FirearmCategory
     */
    omit?: FirearmCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FirearmCategoryInclude<ExtArgs> | null
    /**
     * Filter, which FirearmCategory to fetch.
     */
    where: FirearmCategoryWhereUniqueInput
  }

  /**
   * FirearmCategory findFirst
   */
  export type FirearmCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FirearmCategory
     */
    select?: FirearmCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FirearmCategory
     */
    omit?: FirearmCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FirearmCategoryInclude<ExtArgs> | null
    /**
     * Filter, which FirearmCategory to fetch.
     */
    where?: FirearmCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FirearmCategories to fetch.
     */
    orderBy?: FirearmCategoryOrderByWithRelationInput | FirearmCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FirearmCategories.
     */
    cursor?: FirearmCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FirearmCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FirearmCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FirearmCategories.
     */
    distinct?: FirearmCategoryScalarFieldEnum | FirearmCategoryScalarFieldEnum[]
  }

  /**
   * FirearmCategory findFirstOrThrow
   */
  export type FirearmCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FirearmCategory
     */
    select?: FirearmCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FirearmCategory
     */
    omit?: FirearmCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FirearmCategoryInclude<ExtArgs> | null
    /**
     * Filter, which FirearmCategory to fetch.
     */
    where?: FirearmCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FirearmCategories to fetch.
     */
    orderBy?: FirearmCategoryOrderByWithRelationInput | FirearmCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FirearmCategories.
     */
    cursor?: FirearmCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FirearmCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FirearmCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FirearmCategories.
     */
    distinct?: FirearmCategoryScalarFieldEnum | FirearmCategoryScalarFieldEnum[]
  }

  /**
   * FirearmCategory findMany
   */
  export type FirearmCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FirearmCategory
     */
    select?: FirearmCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FirearmCategory
     */
    omit?: FirearmCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FirearmCategoryInclude<ExtArgs> | null
    /**
     * Filter, which FirearmCategories to fetch.
     */
    where?: FirearmCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FirearmCategories to fetch.
     */
    orderBy?: FirearmCategoryOrderByWithRelationInput | FirearmCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FirearmCategories.
     */
    cursor?: FirearmCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FirearmCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FirearmCategories.
     */
    skip?: number
    distinct?: FirearmCategoryScalarFieldEnum | FirearmCategoryScalarFieldEnum[]
  }

  /**
   * FirearmCategory create
   */
  export type FirearmCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FirearmCategory
     */
    select?: FirearmCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FirearmCategory
     */
    omit?: FirearmCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FirearmCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a FirearmCategory.
     */
    data: XOR<FirearmCategoryCreateInput, FirearmCategoryUncheckedCreateInput>
  }

  /**
   * FirearmCategory createMany
   */
  export type FirearmCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FirearmCategories.
     */
    data: FirearmCategoryCreateManyInput | FirearmCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FirearmCategory createManyAndReturn
   */
  export type FirearmCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FirearmCategory
     */
    select?: FirearmCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FirearmCategory
     */
    omit?: FirearmCategoryOmit<ExtArgs> | null
    /**
     * The data used to create many FirearmCategories.
     */
    data: FirearmCategoryCreateManyInput | FirearmCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FirearmCategory update
   */
  export type FirearmCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FirearmCategory
     */
    select?: FirearmCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FirearmCategory
     */
    omit?: FirearmCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FirearmCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a FirearmCategory.
     */
    data: XOR<FirearmCategoryUpdateInput, FirearmCategoryUncheckedUpdateInput>
    /**
     * Choose, which FirearmCategory to update.
     */
    where: FirearmCategoryWhereUniqueInput
  }

  /**
   * FirearmCategory updateMany
   */
  export type FirearmCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FirearmCategories.
     */
    data: XOR<FirearmCategoryUpdateManyMutationInput, FirearmCategoryUncheckedUpdateManyInput>
    /**
     * Filter which FirearmCategories to update
     */
    where?: FirearmCategoryWhereInput
    /**
     * Limit how many FirearmCategories to update.
     */
    limit?: number
  }

  /**
   * FirearmCategory updateManyAndReturn
   */
  export type FirearmCategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FirearmCategory
     */
    select?: FirearmCategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FirearmCategory
     */
    omit?: FirearmCategoryOmit<ExtArgs> | null
    /**
     * The data used to update FirearmCategories.
     */
    data: XOR<FirearmCategoryUpdateManyMutationInput, FirearmCategoryUncheckedUpdateManyInput>
    /**
     * Filter which FirearmCategories to update
     */
    where?: FirearmCategoryWhereInput
    /**
     * Limit how many FirearmCategories to update.
     */
    limit?: number
  }

  /**
   * FirearmCategory upsert
   */
  export type FirearmCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FirearmCategory
     */
    select?: FirearmCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FirearmCategory
     */
    omit?: FirearmCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FirearmCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the FirearmCategory to update in case it exists.
     */
    where: FirearmCategoryWhereUniqueInput
    /**
     * In case the FirearmCategory found by the `where` argument doesn't exist, create a new FirearmCategory with this data.
     */
    create: XOR<FirearmCategoryCreateInput, FirearmCategoryUncheckedCreateInput>
    /**
     * In case the FirearmCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FirearmCategoryUpdateInput, FirearmCategoryUncheckedUpdateInput>
  }

  /**
   * FirearmCategory delete
   */
  export type FirearmCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FirearmCategory
     */
    select?: FirearmCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FirearmCategory
     */
    omit?: FirearmCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FirearmCategoryInclude<ExtArgs> | null
    /**
     * Filter which FirearmCategory to delete.
     */
    where: FirearmCategoryWhereUniqueInput
  }

  /**
   * FirearmCategory deleteMany
   */
  export type FirearmCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FirearmCategories to delete
     */
    where?: FirearmCategoryWhereInput
    /**
     * Limit how many FirearmCategories to delete.
     */
    limit?: number
  }

  /**
   * FirearmCategory.FirearmSpecs
   */
  export type FirearmCategory$FirearmSpecsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FirearmSpecs
     */
    select?: FirearmSpecsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FirearmSpecs
     */
    omit?: FirearmSpecsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FirearmSpecsInclude<ExtArgs> | null
    where?: FirearmSpecsWhereInput
    orderBy?: FirearmSpecsOrderByWithRelationInput | FirearmSpecsOrderByWithRelationInput[]
    cursor?: FirearmSpecsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FirearmSpecsScalarFieldEnum | FirearmSpecsScalarFieldEnum[]
  }

  /**
   * FirearmCategory without action
   */
  export type FirearmCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FirearmCategory
     */
    select?: FirearmCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FirearmCategory
     */
    omit?: FirearmCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FirearmCategoryInclude<ExtArgs> | null
  }


  /**
   * Model FirearmChamber
   */

  export type AggregateFirearmChamber = {
    _count: FirearmChamberCountAggregateOutputType | null
    _avg: FirearmChamberAvgAggregateOutputType | null
    _sum: FirearmChamberSumAggregateOutputType | null
    _min: FirearmChamberMinAggregateOutputType | null
    _max: FirearmChamberMaxAggregateOutputType | null
  }

  export type FirearmChamberAvgAggregateOutputType = {
    firearmSpecsId: number | null
    caliberId: number | null
  }

  export type FirearmChamberSumAggregateOutputType = {
    firearmSpecsId: number | null
    caliberId: number | null
  }

  export type FirearmChamberMinAggregateOutputType = {
    firearmSpecsId: number | null
    caliberId: number | null
    note: string | null
  }

  export type FirearmChamberMaxAggregateOutputType = {
    firearmSpecsId: number | null
    caliberId: number | null
    note: string | null
  }

  export type FirearmChamberCountAggregateOutputType = {
    firearmSpecsId: number
    caliberId: number
    note: number
    _all: number
  }


  export type FirearmChamberAvgAggregateInputType = {
    firearmSpecsId?: true
    caliberId?: true
  }

  export type FirearmChamberSumAggregateInputType = {
    firearmSpecsId?: true
    caliberId?: true
  }

  export type FirearmChamberMinAggregateInputType = {
    firearmSpecsId?: true
    caliberId?: true
    note?: true
  }

  export type FirearmChamberMaxAggregateInputType = {
    firearmSpecsId?: true
    caliberId?: true
    note?: true
  }

  export type FirearmChamberCountAggregateInputType = {
    firearmSpecsId?: true
    caliberId?: true
    note?: true
    _all?: true
  }

  export type FirearmChamberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FirearmChamber to aggregate.
     */
    where?: FirearmChamberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FirearmChambers to fetch.
     */
    orderBy?: FirearmChamberOrderByWithRelationInput | FirearmChamberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FirearmChamberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FirearmChambers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FirearmChambers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FirearmChambers
    **/
    _count?: true | FirearmChamberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FirearmChamberAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FirearmChamberSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FirearmChamberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FirearmChamberMaxAggregateInputType
  }

  export type GetFirearmChamberAggregateType<T extends FirearmChamberAggregateArgs> = {
        [P in keyof T & keyof AggregateFirearmChamber]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFirearmChamber[P]>
      : GetScalarType<T[P], AggregateFirearmChamber[P]>
  }




  export type FirearmChamberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FirearmChamberWhereInput
    orderBy?: FirearmChamberOrderByWithAggregationInput | FirearmChamberOrderByWithAggregationInput[]
    by: FirearmChamberScalarFieldEnum[] | FirearmChamberScalarFieldEnum
    having?: FirearmChamberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FirearmChamberCountAggregateInputType | true
    _avg?: FirearmChamberAvgAggregateInputType
    _sum?: FirearmChamberSumAggregateInputType
    _min?: FirearmChamberMinAggregateInputType
    _max?: FirearmChamberMaxAggregateInputType
  }

  export type FirearmChamberGroupByOutputType = {
    firearmSpecsId: number
    caliberId: number
    note: string | null
    _count: FirearmChamberCountAggregateOutputType | null
    _avg: FirearmChamberAvgAggregateOutputType | null
    _sum: FirearmChamberSumAggregateOutputType | null
    _min: FirearmChamberMinAggregateOutputType | null
    _max: FirearmChamberMaxAggregateOutputType | null
  }

  type GetFirearmChamberGroupByPayload<T extends FirearmChamberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FirearmChamberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FirearmChamberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FirearmChamberGroupByOutputType[P]>
            : GetScalarType<T[P], FirearmChamberGroupByOutputType[P]>
        }
      >
    >


  export type FirearmChamberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    firearmSpecsId?: boolean
    caliberId?: boolean
    note?: boolean
    Caliber?: boolean | CaliberDefaultArgs<ExtArgs>
    FirearmSpecs?: boolean | FirearmSpecsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["firearmChamber"]>

  export type FirearmChamberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    firearmSpecsId?: boolean
    caliberId?: boolean
    note?: boolean
    Caliber?: boolean | CaliberDefaultArgs<ExtArgs>
    FirearmSpecs?: boolean | FirearmSpecsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["firearmChamber"]>

  export type FirearmChamberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    firearmSpecsId?: boolean
    caliberId?: boolean
    note?: boolean
    Caliber?: boolean | CaliberDefaultArgs<ExtArgs>
    FirearmSpecs?: boolean | FirearmSpecsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["firearmChamber"]>

  export type FirearmChamberSelectScalar = {
    firearmSpecsId?: boolean
    caliberId?: boolean
    note?: boolean
  }

  export type FirearmChamberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"firearmSpecsId" | "caliberId" | "note", ExtArgs["result"]["firearmChamber"]>
  export type FirearmChamberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Caliber?: boolean | CaliberDefaultArgs<ExtArgs>
    FirearmSpecs?: boolean | FirearmSpecsDefaultArgs<ExtArgs>
  }
  export type FirearmChamberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Caliber?: boolean | CaliberDefaultArgs<ExtArgs>
    FirearmSpecs?: boolean | FirearmSpecsDefaultArgs<ExtArgs>
  }
  export type FirearmChamberIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Caliber?: boolean | CaliberDefaultArgs<ExtArgs>
    FirearmSpecs?: boolean | FirearmSpecsDefaultArgs<ExtArgs>
  }

  export type $FirearmChamberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FirearmChamber"
    objects: {
      Caliber: Prisma.$CaliberPayload<ExtArgs>
      FirearmSpecs: Prisma.$FirearmSpecsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      firearmSpecsId: number
      caliberId: number
      note: string | null
    }, ExtArgs["result"]["firearmChamber"]>
    composites: {}
  }

  type FirearmChamberGetPayload<S extends boolean | null | undefined | FirearmChamberDefaultArgs> = $Result.GetResult<Prisma.$FirearmChamberPayload, S>

  type FirearmChamberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FirearmChamberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FirearmChamberCountAggregateInputType | true
    }

  export interface FirearmChamberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FirearmChamber'], meta: { name: 'FirearmChamber' } }
    /**
     * Find zero or one FirearmChamber that matches the filter.
     * @param {FirearmChamberFindUniqueArgs} args - Arguments to find a FirearmChamber
     * @example
     * // Get one FirearmChamber
     * const firearmChamber = await prisma.firearmChamber.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FirearmChamberFindUniqueArgs>(args: SelectSubset<T, FirearmChamberFindUniqueArgs<ExtArgs>>): Prisma__FirearmChamberClient<$Result.GetResult<Prisma.$FirearmChamberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FirearmChamber that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FirearmChamberFindUniqueOrThrowArgs} args - Arguments to find a FirearmChamber
     * @example
     * // Get one FirearmChamber
     * const firearmChamber = await prisma.firearmChamber.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FirearmChamberFindUniqueOrThrowArgs>(args: SelectSubset<T, FirearmChamberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FirearmChamberClient<$Result.GetResult<Prisma.$FirearmChamberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FirearmChamber that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FirearmChamberFindFirstArgs} args - Arguments to find a FirearmChamber
     * @example
     * // Get one FirearmChamber
     * const firearmChamber = await prisma.firearmChamber.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FirearmChamberFindFirstArgs>(args?: SelectSubset<T, FirearmChamberFindFirstArgs<ExtArgs>>): Prisma__FirearmChamberClient<$Result.GetResult<Prisma.$FirearmChamberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FirearmChamber that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FirearmChamberFindFirstOrThrowArgs} args - Arguments to find a FirearmChamber
     * @example
     * // Get one FirearmChamber
     * const firearmChamber = await prisma.firearmChamber.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FirearmChamberFindFirstOrThrowArgs>(args?: SelectSubset<T, FirearmChamberFindFirstOrThrowArgs<ExtArgs>>): Prisma__FirearmChamberClient<$Result.GetResult<Prisma.$FirearmChamberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FirearmChambers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FirearmChamberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FirearmChambers
     * const firearmChambers = await prisma.firearmChamber.findMany()
     * 
     * // Get first 10 FirearmChambers
     * const firearmChambers = await prisma.firearmChamber.findMany({ take: 10 })
     * 
     * // Only select the `firearmSpecsId`
     * const firearmChamberWithFirearmSpecsIdOnly = await prisma.firearmChamber.findMany({ select: { firearmSpecsId: true } })
     * 
     */
    findMany<T extends FirearmChamberFindManyArgs>(args?: SelectSubset<T, FirearmChamberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FirearmChamberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FirearmChamber.
     * @param {FirearmChamberCreateArgs} args - Arguments to create a FirearmChamber.
     * @example
     * // Create one FirearmChamber
     * const FirearmChamber = await prisma.firearmChamber.create({
     *   data: {
     *     // ... data to create a FirearmChamber
     *   }
     * })
     * 
     */
    create<T extends FirearmChamberCreateArgs>(args: SelectSubset<T, FirearmChamberCreateArgs<ExtArgs>>): Prisma__FirearmChamberClient<$Result.GetResult<Prisma.$FirearmChamberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FirearmChambers.
     * @param {FirearmChamberCreateManyArgs} args - Arguments to create many FirearmChambers.
     * @example
     * // Create many FirearmChambers
     * const firearmChamber = await prisma.firearmChamber.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FirearmChamberCreateManyArgs>(args?: SelectSubset<T, FirearmChamberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FirearmChambers and returns the data saved in the database.
     * @param {FirearmChamberCreateManyAndReturnArgs} args - Arguments to create many FirearmChambers.
     * @example
     * // Create many FirearmChambers
     * const firearmChamber = await prisma.firearmChamber.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FirearmChambers and only return the `firearmSpecsId`
     * const firearmChamberWithFirearmSpecsIdOnly = await prisma.firearmChamber.createManyAndReturn({
     *   select: { firearmSpecsId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FirearmChamberCreateManyAndReturnArgs>(args?: SelectSubset<T, FirearmChamberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FirearmChamberPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FirearmChamber.
     * @param {FirearmChamberDeleteArgs} args - Arguments to delete one FirearmChamber.
     * @example
     * // Delete one FirearmChamber
     * const FirearmChamber = await prisma.firearmChamber.delete({
     *   where: {
     *     // ... filter to delete one FirearmChamber
     *   }
     * })
     * 
     */
    delete<T extends FirearmChamberDeleteArgs>(args: SelectSubset<T, FirearmChamberDeleteArgs<ExtArgs>>): Prisma__FirearmChamberClient<$Result.GetResult<Prisma.$FirearmChamberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FirearmChamber.
     * @param {FirearmChamberUpdateArgs} args - Arguments to update one FirearmChamber.
     * @example
     * // Update one FirearmChamber
     * const firearmChamber = await prisma.firearmChamber.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FirearmChamberUpdateArgs>(args: SelectSubset<T, FirearmChamberUpdateArgs<ExtArgs>>): Prisma__FirearmChamberClient<$Result.GetResult<Prisma.$FirearmChamberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FirearmChambers.
     * @param {FirearmChamberDeleteManyArgs} args - Arguments to filter FirearmChambers to delete.
     * @example
     * // Delete a few FirearmChambers
     * const { count } = await prisma.firearmChamber.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FirearmChamberDeleteManyArgs>(args?: SelectSubset<T, FirearmChamberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FirearmChambers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FirearmChamberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FirearmChambers
     * const firearmChamber = await prisma.firearmChamber.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FirearmChamberUpdateManyArgs>(args: SelectSubset<T, FirearmChamberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FirearmChambers and returns the data updated in the database.
     * @param {FirearmChamberUpdateManyAndReturnArgs} args - Arguments to update many FirearmChambers.
     * @example
     * // Update many FirearmChambers
     * const firearmChamber = await prisma.firearmChamber.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FirearmChambers and only return the `firearmSpecsId`
     * const firearmChamberWithFirearmSpecsIdOnly = await prisma.firearmChamber.updateManyAndReturn({
     *   select: { firearmSpecsId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FirearmChamberUpdateManyAndReturnArgs>(args: SelectSubset<T, FirearmChamberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FirearmChamberPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FirearmChamber.
     * @param {FirearmChamberUpsertArgs} args - Arguments to update or create a FirearmChamber.
     * @example
     * // Update or create a FirearmChamber
     * const firearmChamber = await prisma.firearmChamber.upsert({
     *   create: {
     *     // ... data to create a FirearmChamber
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FirearmChamber we want to update
     *   }
     * })
     */
    upsert<T extends FirearmChamberUpsertArgs>(args: SelectSubset<T, FirearmChamberUpsertArgs<ExtArgs>>): Prisma__FirearmChamberClient<$Result.GetResult<Prisma.$FirearmChamberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FirearmChambers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FirearmChamberCountArgs} args - Arguments to filter FirearmChambers to count.
     * @example
     * // Count the number of FirearmChambers
     * const count = await prisma.firearmChamber.count({
     *   where: {
     *     // ... the filter for the FirearmChambers we want to count
     *   }
     * })
    **/
    count<T extends FirearmChamberCountArgs>(
      args?: Subset<T, FirearmChamberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FirearmChamberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FirearmChamber.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FirearmChamberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FirearmChamberAggregateArgs>(args: Subset<T, FirearmChamberAggregateArgs>): Prisma.PrismaPromise<GetFirearmChamberAggregateType<T>>

    /**
     * Group by FirearmChamber.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FirearmChamberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FirearmChamberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FirearmChamberGroupByArgs['orderBy'] }
        : { orderBy?: FirearmChamberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FirearmChamberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFirearmChamberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FirearmChamber model
   */
  readonly fields: FirearmChamberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FirearmChamber.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FirearmChamberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Caliber<T extends CaliberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CaliberDefaultArgs<ExtArgs>>): Prisma__CaliberClient<$Result.GetResult<Prisma.$CaliberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    FirearmSpecs<T extends FirearmSpecsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FirearmSpecsDefaultArgs<ExtArgs>>): Prisma__FirearmSpecsClient<$Result.GetResult<Prisma.$FirearmSpecsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FirearmChamber model
   */
  interface FirearmChamberFieldRefs {
    readonly firearmSpecsId: FieldRef<"FirearmChamber", 'Int'>
    readonly caliberId: FieldRef<"FirearmChamber", 'Int'>
    readonly note: FieldRef<"FirearmChamber", 'String'>
  }
    

  // Custom InputTypes
  /**
   * FirearmChamber findUnique
   */
  export type FirearmChamberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FirearmChamber
     */
    select?: FirearmChamberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FirearmChamber
     */
    omit?: FirearmChamberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FirearmChamberInclude<ExtArgs> | null
    /**
     * Filter, which FirearmChamber to fetch.
     */
    where: FirearmChamberWhereUniqueInput
  }

  /**
   * FirearmChamber findUniqueOrThrow
   */
  export type FirearmChamberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FirearmChamber
     */
    select?: FirearmChamberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FirearmChamber
     */
    omit?: FirearmChamberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FirearmChamberInclude<ExtArgs> | null
    /**
     * Filter, which FirearmChamber to fetch.
     */
    where: FirearmChamberWhereUniqueInput
  }

  /**
   * FirearmChamber findFirst
   */
  export type FirearmChamberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FirearmChamber
     */
    select?: FirearmChamberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FirearmChamber
     */
    omit?: FirearmChamberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FirearmChamberInclude<ExtArgs> | null
    /**
     * Filter, which FirearmChamber to fetch.
     */
    where?: FirearmChamberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FirearmChambers to fetch.
     */
    orderBy?: FirearmChamberOrderByWithRelationInput | FirearmChamberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FirearmChambers.
     */
    cursor?: FirearmChamberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FirearmChambers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FirearmChambers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FirearmChambers.
     */
    distinct?: FirearmChamberScalarFieldEnum | FirearmChamberScalarFieldEnum[]
  }

  /**
   * FirearmChamber findFirstOrThrow
   */
  export type FirearmChamberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FirearmChamber
     */
    select?: FirearmChamberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FirearmChamber
     */
    omit?: FirearmChamberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FirearmChamberInclude<ExtArgs> | null
    /**
     * Filter, which FirearmChamber to fetch.
     */
    where?: FirearmChamberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FirearmChambers to fetch.
     */
    orderBy?: FirearmChamberOrderByWithRelationInput | FirearmChamberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FirearmChambers.
     */
    cursor?: FirearmChamberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FirearmChambers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FirearmChambers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FirearmChambers.
     */
    distinct?: FirearmChamberScalarFieldEnum | FirearmChamberScalarFieldEnum[]
  }

  /**
   * FirearmChamber findMany
   */
  export type FirearmChamberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FirearmChamber
     */
    select?: FirearmChamberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FirearmChamber
     */
    omit?: FirearmChamberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FirearmChamberInclude<ExtArgs> | null
    /**
     * Filter, which FirearmChambers to fetch.
     */
    where?: FirearmChamberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FirearmChambers to fetch.
     */
    orderBy?: FirearmChamberOrderByWithRelationInput | FirearmChamberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FirearmChambers.
     */
    cursor?: FirearmChamberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FirearmChambers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FirearmChambers.
     */
    skip?: number
    distinct?: FirearmChamberScalarFieldEnum | FirearmChamberScalarFieldEnum[]
  }

  /**
   * FirearmChamber create
   */
  export type FirearmChamberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FirearmChamber
     */
    select?: FirearmChamberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FirearmChamber
     */
    omit?: FirearmChamberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FirearmChamberInclude<ExtArgs> | null
    /**
     * The data needed to create a FirearmChamber.
     */
    data: XOR<FirearmChamberCreateInput, FirearmChamberUncheckedCreateInput>
  }

  /**
   * FirearmChamber createMany
   */
  export type FirearmChamberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FirearmChambers.
     */
    data: FirearmChamberCreateManyInput | FirearmChamberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FirearmChamber createManyAndReturn
   */
  export type FirearmChamberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FirearmChamber
     */
    select?: FirearmChamberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FirearmChamber
     */
    omit?: FirearmChamberOmit<ExtArgs> | null
    /**
     * The data used to create many FirearmChambers.
     */
    data: FirearmChamberCreateManyInput | FirearmChamberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FirearmChamberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FirearmChamber update
   */
  export type FirearmChamberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FirearmChamber
     */
    select?: FirearmChamberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FirearmChamber
     */
    omit?: FirearmChamberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FirearmChamberInclude<ExtArgs> | null
    /**
     * The data needed to update a FirearmChamber.
     */
    data: XOR<FirearmChamberUpdateInput, FirearmChamberUncheckedUpdateInput>
    /**
     * Choose, which FirearmChamber to update.
     */
    where: FirearmChamberWhereUniqueInput
  }

  /**
   * FirearmChamber updateMany
   */
  export type FirearmChamberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FirearmChambers.
     */
    data: XOR<FirearmChamberUpdateManyMutationInput, FirearmChamberUncheckedUpdateManyInput>
    /**
     * Filter which FirearmChambers to update
     */
    where?: FirearmChamberWhereInput
    /**
     * Limit how many FirearmChambers to update.
     */
    limit?: number
  }

  /**
   * FirearmChamber updateManyAndReturn
   */
  export type FirearmChamberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FirearmChamber
     */
    select?: FirearmChamberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FirearmChamber
     */
    omit?: FirearmChamberOmit<ExtArgs> | null
    /**
     * The data used to update FirearmChambers.
     */
    data: XOR<FirearmChamberUpdateManyMutationInput, FirearmChamberUncheckedUpdateManyInput>
    /**
     * Filter which FirearmChambers to update
     */
    where?: FirearmChamberWhereInput
    /**
     * Limit how many FirearmChambers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FirearmChamberIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FirearmChamber upsert
   */
  export type FirearmChamberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FirearmChamber
     */
    select?: FirearmChamberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FirearmChamber
     */
    omit?: FirearmChamberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FirearmChamberInclude<ExtArgs> | null
    /**
     * The filter to search for the FirearmChamber to update in case it exists.
     */
    where: FirearmChamberWhereUniqueInput
    /**
     * In case the FirearmChamber found by the `where` argument doesn't exist, create a new FirearmChamber with this data.
     */
    create: XOR<FirearmChamberCreateInput, FirearmChamberUncheckedCreateInput>
    /**
     * In case the FirearmChamber was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FirearmChamberUpdateInput, FirearmChamberUncheckedUpdateInput>
  }

  /**
   * FirearmChamber delete
   */
  export type FirearmChamberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FirearmChamber
     */
    select?: FirearmChamberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FirearmChamber
     */
    omit?: FirearmChamberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FirearmChamberInclude<ExtArgs> | null
    /**
     * Filter which FirearmChamber to delete.
     */
    where: FirearmChamberWhereUniqueInput
  }

  /**
   * FirearmChamber deleteMany
   */
  export type FirearmChamberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FirearmChambers to delete
     */
    where?: FirearmChamberWhereInput
    /**
     * Limit how many FirearmChambers to delete.
     */
    limit?: number
  }

  /**
   * FirearmChamber without action
   */
  export type FirearmChamberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FirearmChamber
     */
    select?: FirearmChamberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FirearmChamber
     */
    omit?: FirearmChamberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FirearmChamberInclude<ExtArgs> | null
  }


  /**
   * Model FirearmSpecs
   */

  export type AggregateFirearmSpecs = {
    _count: FirearmSpecsCountAggregateOutputType | null
    _avg: FirearmSpecsAvgAggregateOutputType | null
    _sum: FirearmSpecsSumAggregateOutputType | null
    _min: FirearmSpecsMinAggregateOutputType | null
    _max: FirearmSpecsMaxAggregateOutputType | null
  }

  export type FirearmSpecsAvgAggregateOutputType = {
    id: number | null
    firearmCategoryId: number | null
    barrelLengthIn: number | null
  }

  export type FirearmSpecsSumAggregateOutputType = {
    id: number | null
    firearmCategoryId: number | null
    barrelLengthIn: number | null
  }

  export type FirearmSpecsMinAggregateOutputType = {
    id: number | null
    itemId: string | null
    manufacturer: string | null
    model: string | null
    platform: string | null
    firearmCategoryId: number | null
    barrelLengthIn: number | null
    actionType: string | null
    isThreaded: boolean | null
    pressureRating: $Enums.FirearmPressureRating | null
    firearmType: string | null
    capacity: string | null
    finish: string | null
    weight: string | null
    overallLength: string | null
    features: string | null
    sight: string | null
    safety: string | null
  }

  export type FirearmSpecsMaxAggregateOutputType = {
    id: number | null
    itemId: string | null
    manufacturer: string | null
    model: string | null
    platform: string | null
    firearmCategoryId: number | null
    barrelLengthIn: number | null
    actionType: string | null
    isThreaded: boolean | null
    pressureRating: $Enums.FirearmPressureRating | null
    firearmType: string | null
    capacity: string | null
    finish: string | null
    weight: string | null
    overallLength: string | null
    features: string | null
    sight: string | null
    safety: string | null
  }

  export type FirearmSpecsCountAggregateOutputType = {
    id: number
    itemId: number
    manufacturer: number
    model: number
    platform: number
    firearmCategoryId: number
    barrelLengthIn: number
    actionType: number
    isThreaded: number
    pressureRating: number
    firearmType: number
    capacity: number
    finish: number
    weight: number
    overallLength: number
    features: number
    sight: number
    safety: number
    _all: number
  }


  export type FirearmSpecsAvgAggregateInputType = {
    id?: true
    firearmCategoryId?: true
    barrelLengthIn?: true
  }

  export type FirearmSpecsSumAggregateInputType = {
    id?: true
    firearmCategoryId?: true
    barrelLengthIn?: true
  }

  export type FirearmSpecsMinAggregateInputType = {
    id?: true
    itemId?: true
    manufacturer?: true
    model?: true
    platform?: true
    firearmCategoryId?: true
    barrelLengthIn?: true
    actionType?: true
    isThreaded?: true
    pressureRating?: true
    firearmType?: true
    capacity?: true
    finish?: true
    weight?: true
    overallLength?: true
    features?: true
    sight?: true
    safety?: true
  }

  export type FirearmSpecsMaxAggregateInputType = {
    id?: true
    itemId?: true
    manufacturer?: true
    model?: true
    platform?: true
    firearmCategoryId?: true
    barrelLengthIn?: true
    actionType?: true
    isThreaded?: true
    pressureRating?: true
    firearmType?: true
    capacity?: true
    finish?: true
    weight?: true
    overallLength?: true
    features?: true
    sight?: true
    safety?: true
  }

  export type FirearmSpecsCountAggregateInputType = {
    id?: true
    itemId?: true
    manufacturer?: true
    model?: true
    platform?: true
    firearmCategoryId?: true
    barrelLengthIn?: true
    actionType?: true
    isThreaded?: true
    pressureRating?: true
    firearmType?: true
    capacity?: true
    finish?: true
    weight?: true
    overallLength?: true
    features?: true
    sight?: true
    safety?: true
    _all?: true
  }

  export type FirearmSpecsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FirearmSpecs to aggregate.
     */
    where?: FirearmSpecsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FirearmSpecs to fetch.
     */
    orderBy?: FirearmSpecsOrderByWithRelationInput | FirearmSpecsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FirearmSpecsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FirearmSpecs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FirearmSpecs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FirearmSpecs
    **/
    _count?: true | FirearmSpecsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FirearmSpecsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FirearmSpecsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FirearmSpecsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FirearmSpecsMaxAggregateInputType
  }

  export type GetFirearmSpecsAggregateType<T extends FirearmSpecsAggregateArgs> = {
        [P in keyof T & keyof AggregateFirearmSpecs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFirearmSpecs[P]>
      : GetScalarType<T[P], AggregateFirearmSpecs[P]>
  }




  export type FirearmSpecsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FirearmSpecsWhereInput
    orderBy?: FirearmSpecsOrderByWithAggregationInput | FirearmSpecsOrderByWithAggregationInput[]
    by: FirearmSpecsScalarFieldEnum[] | FirearmSpecsScalarFieldEnum
    having?: FirearmSpecsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FirearmSpecsCountAggregateInputType | true
    _avg?: FirearmSpecsAvgAggregateInputType
    _sum?: FirearmSpecsSumAggregateInputType
    _min?: FirearmSpecsMinAggregateInputType
    _max?: FirearmSpecsMaxAggregateInputType
  }

  export type FirearmSpecsGroupByOutputType = {
    id: number
    itemId: string
    manufacturer: string | null
    model: string | null
    platform: string | null
    firearmCategoryId: number | null
    barrelLengthIn: number | null
    actionType: string | null
    isThreaded: boolean | null
    pressureRating: $Enums.FirearmPressureRating | null
    firearmType: string | null
    capacity: string | null
    finish: string | null
    weight: string | null
    overallLength: string | null
    features: string | null
    sight: string | null
    safety: string | null
    _count: FirearmSpecsCountAggregateOutputType | null
    _avg: FirearmSpecsAvgAggregateOutputType | null
    _sum: FirearmSpecsSumAggregateOutputType | null
    _min: FirearmSpecsMinAggregateOutputType | null
    _max: FirearmSpecsMaxAggregateOutputType | null
  }

  type GetFirearmSpecsGroupByPayload<T extends FirearmSpecsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FirearmSpecsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FirearmSpecsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FirearmSpecsGroupByOutputType[P]>
            : GetScalarType<T[P], FirearmSpecsGroupByOutputType[P]>
        }
      >
    >


  export type FirearmSpecsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itemId?: boolean
    manufacturer?: boolean
    model?: boolean
    platform?: boolean
    firearmCategoryId?: boolean
    barrelLengthIn?: boolean
    actionType?: boolean
    isThreaded?: boolean
    pressureRating?: boolean
    firearmType?: boolean
    capacity?: boolean
    finish?: boolean
    weight?: boolean
    overallLength?: boolean
    features?: boolean
    sight?: boolean
    safety?: boolean
    FirearmChamber?: boolean | FirearmSpecs$FirearmChamberArgs<ExtArgs>
    FirearmCategory?: boolean | FirearmSpecs$FirearmCategoryArgs<ExtArgs>
    CatalogItem?: boolean | CatalogItemDefaultArgs<ExtArgs>
    _count?: boolean | FirearmSpecsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["firearmSpecs"]>

  export type FirearmSpecsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itemId?: boolean
    manufacturer?: boolean
    model?: boolean
    platform?: boolean
    firearmCategoryId?: boolean
    barrelLengthIn?: boolean
    actionType?: boolean
    isThreaded?: boolean
    pressureRating?: boolean
    firearmType?: boolean
    capacity?: boolean
    finish?: boolean
    weight?: boolean
    overallLength?: boolean
    features?: boolean
    sight?: boolean
    safety?: boolean
    FirearmCategory?: boolean | FirearmSpecs$FirearmCategoryArgs<ExtArgs>
    CatalogItem?: boolean | CatalogItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["firearmSpecs"]>

  export type FirearmSpecsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itemId?: boolean
    manufacturer?: boolean
    model?: boolean
    platform?: boolean
    firearmCategoryId?: boolean
    barrelLengthIn?: boolean
    actionType?: boolean
    isThreaded?: boolean
    pressureRating?: boolean
    firearmType?: boolean
    capacity?: boolean
    finish?: boolean
    weight?: boolean
    overallLength?: boolean
    features?: boolean
    sight?: boolean
    safety?: boolean
    FirearmCategory?: boolean | FirearmSpecs$FirearmCategoryArgs<ExtArgs>
    CatalogItem?: boolean | CatalogItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["firearmSpecs"]>

  export type FirearmSpecsSelectScalar = {
    id?: boolean
    itemId?: boolean
    manufacturer?: boolean
    model?: boolean
    platform?: boolean
    firearmCategoryId?: boolean
    barrelLengthIn?: boolean
    actionType?: boolean
    isThreaded?: boolean
    pressureRating?: boolean
    firearmType?: boolean
    capacity?: boolean
    finish?: boolean
    weight?: boolean
    overallLength?: boolean
    features?: boolean
    sight?: boolean
    safety?: boolean
  }

  export type FirearmSpecsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "itemId" | "manufacturer" | "model" | "platform" | "firearmCategoryId" | "barrelLengthIn" | "actionType" | "isThreaded" | "pressureRating" | "firearmType" | "capacity" | "finish" | "weight" | "overallLength" | "features" | "sight" | "safety", ExtArgs["result"]["firearmSpecs"]>
  export type FirearmSpecsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    FirearmChamber?: boolean | FirearmSpecs$FirearmChamberArgs<ExtArgs>
    FirearmCategory?: boolean | FirearmSpecs$FirearmCategoryArgs<ExtArgs>
    CatalogItem?: boolean | CatalogItemDefaultArgs<ExtArgs>
    _count?: boolean | FirearmSpecsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FirearmSpecsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    FirearmCategory?: boolean | FirearmSpecs$FirearmCategoryArgs<ExtArgs>
    CatalogItem?: boolean | CatalogItemDefaultArgs<ExtArgs>
  }
  export type FirearmSpecsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    FirearmCategory?: boolean | FirearmSpecs$FirearmCategoryArgs<ExtArgs>
    CatalogItem?: boolean | CatalogItemDefaultArgs<ExtArgs>
  }

  export type $FirearmSpecsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FirearmSpecs"
    objects: {
      FirearmChamber: Prisma.$FirearmChamberPayload<ExtArgs>[]
      FirearmCategory: Prisma.$FirearmCategoryPayload<ExtArgs> | null
      CatalogItem: Prisma.$CatalogItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      itemId: string
      manufacturer: string | null
      model: string | null
      platform: string | null
      firearmCategoryId: number | null
      barrelLengthIn: number | null
      actionType: string | null
      isThreaded: boolean | null
      pressureRating: $Enums.FirearmPressureRating | null
      firearmType: string | null
      capacity: string | null
      finish: string | null
      weight: string | null
      overallLength: string | null
      features: string | null
      sight: string | null
      safety: string | null
    }, ExtArgs["result"]["firearmSpecs"]>
    composites: {}
  }

  type FirearmSpecsGetPayload<S extends boolean | null | undefined | FirearmSpecsDefaultArgs> = $Result.GetResult<Prisma.$FirearmSpecsPayload, S>

  type FirearmSpecsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FirearmSpecsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FirearmSpecsCountAggregateInputType | true
    }

  export interface FirearmSpecsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FirearmSpecs'], meta: { name: 'FirearmSpecs' } }
    /**
     * Find zero or one FirearmSpecs that matches the filter.
     * @param {FirearmSpecsFindUniqueArgs} args - Arguments to find a FirearmSpecs
     * @example
     * // Get one FirearmSpecs
     * const firearmSpecs = await prisma.firearmSpecs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FirearmSpecsFindUniqueArgs>(args: SelectSubset<T, FirearmSpecsFindUniqueArgs<ExtArgs>>): Prisma__FirearmSpecsClient<$Result.GetResult<Prisma.$FirearmSpecsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FirearmSpecs that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FirearmSpecsFindUniqueOrThrowArgs} args - Arguments to find a FirearmSpecs
     * @example
     * // Get one FirearmSpecs
     * const firearmSpecs = await prisma.firearmSpecs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FirearmSpecsFindUniqueOrThrowArgs>(args: SelectSubset<T, FirearmSpecsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FirearmSpecsClient<$Result.GetResult<Prisma.$FirearmSpecsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FirearmSpecs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FirearmSpecsFindFirstArgs} args - Arguments to find a FirearmSpecs
     * @example
     * // Get one FirearmSpecs
     * const firearmSpecs = await prisma.firearmSpecs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FirearmSpecsFindFirstArgs>(args?: SelectSubset<T, FirearmSpecsFindFirstArgs<ExtArgs>>): Prisma__FirearmSpecsClient<$Result.GetResult<Prisma.$FirearmSpecsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FirearmSpecs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FirearmSpecsFindFirstOrThrowArgs} args - Arguments to find a FirearmSpecs
     * @example
     * // Get one FirearmSpecs
     * const firearmSpecs = await prisma.firearmSpecs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FirearmSpecsFindFirstOrThrowArgs>(args?: SelectSubset<T, FirearmSpecsFindFirstOrThrowArgs<ExtArgs>>): Prisma__FirearmSpecsClient<$Result.GetResult<Prisma.$FirearmSpecsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FirearmSpecs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FirearmSpecsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FirearmSpecs
     * const firearmSpecs = await prisma.firearmSpecs.findMany()
     * 
     * // Get first 10 FirearmSpecs
     * const firearmSpecs = await prisma.firearmSpecs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const firearmSpecsWithIdOnly = await prisma.firearmSpecs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FirearmSpecsFindManyArgs>(args?: SelectSubset<T, FirearmSpecsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FirearmSpecsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FirearmSpecs.
     * @param {FirearmSpecsCreateArgs} args - Arguments to create a FirearmSpecs.
     * @example
     * // Create one FirearmSpecs
     * const FirearmSpecs = await prisma.firearmSpecs.create({
     *   data: {
     *     // ... data to create a FirearmSpecs
     *   }
     * })
     * 
     */
    create<T extends FirearmSpecsCreateArgs>(args: SelectSubset<T, FirearmSpecsCreateArgs<ExtArgs>>): Prisma__FirearmSpecsClient<$Result.GetResult<Prisma.$FirearmSpecsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FirearmSpecs.
     * @param {FirearmSpecsCreateManyArgs} args - Arguments to create many FirearmSpecs.
     * @example
     * // Create many FirearmSpecs
     * const firearmSpecs = await prisma.firearmSpecs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FirearmSpecsCreateManyArgs>(args?: SelectSubset<T, FirearmSpecsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FirearmSpecs and returns the data saved in the database.
     * @param {FirearmSpecsCreateManyAndReturnArgs} args - Arguments to create many FirearmSpecs.
     * @example
     * // Create many FirearmSpecs
     * const firearmSpecs = await prisma.firearmSpecs.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FirearmSpecs and only return the `id`
     * const firearmSpecsWithIdOnly = await prisma.firearmSpecs.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FirearmSpecsCreateManyAndReturnArgs>(args?: SelectSubset<T, FirearmSpecsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FirearmSpecsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FirearmSpecs.
     * @param {FirearmSpecsDeleteArgs} args - Arguments to delete one FirearmSpecs.
     * @example
     * // Delete one FirearmSpecs
     * const FirearmSpecs = await prisma.firearmSpecs.delete({
     *   where: {
     *     // ... filter to delete one FirearmSpecs
     *   }
     * })
     * 
     */
    delete<T extends FirearmSpecsDeleteArgs>(args: SelectSubset<T, FirearmSpecsDeleteArgs<ExtArgs>>): Prisma__FirearmSpecsClient<$Result.GetResult<Prisma.$FirearmSpecsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FirearmSpecs.
     * @param {FirearmSpecsUpdateArgs} args - Arguments to update one FirearmSpecs.
     * @example
     * // Update one FirearmSpecs
     * const firearmSpecs = await prisma.firearmSpecs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FirearmSpecsUpdateArgs>(args: SelectSubset<T, FirearmSpecsUpdateArgs<ExtArgs>>): Prisma__FirearmSpecsClient<$Result.GetResult<Prisma.$FirearmSpecsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FirearmSpecs.
     * @param {FirearmSpecsDeleteManyArgs} args - Arguments to filter FirearmSpecs to delete.
     * @example
     * // Delete a few FirearmSpecs
     * const { count } = await prisma.firearmSpecs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FirearmSpecsDeleteManyArgs>(args?: SelectSubset<T, FirearmSpecsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FirearmSpecs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FirearmSpecsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FirearmSpecs
     * const firearmSpecs = await prisma.firearmSpecs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FirearmSpecsUpdateManyArgs>(args: SelectSubset<T, FirearmSpecsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FirearmSpecs and returns the data updated in the database.
     * @param {FirearmSpecsUpdateManyAndReturnArgs} args - Arguments to update many FirearmSpecs.
     * @example
     * // Update many FirearmSpecs
     * const firearmSpecs = await prisma.firearmSpecs.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FirearmSpecs and only return the `id`
     * const firearmSpecsWithIdOnly = await prisma.firearmSpecs.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FirearmSpecsUpdateManyAndReturnArgs>(args: SelectSubset<T, FirearmSpecsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FirearmSpecsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FirearmSpecs.
     * @param {FirearmSpecsUpsertArgs} args - Arguments to update or create a FirearmSpecs.
     * @example
     * // Update or create a FirearmSpecs
     * const firearmSpecs = await prisma.firearmSpecs.upsert({
     *   create: {
     *     // ... data to create a FirearmSpecs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FirearmSpecs we want to update
     *   }
     * })
     */
    upsert<T extends FirearmSpecsUpsertArgs>(args: SelectSubset<T, FirearmSpecsUpsertArgs<ExtArgs>>): Prisma__FirearmSpecsClient<$Result.GetResult<Prisma.$FirearmSpecsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FirearmSpecs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FirearmSpecsCountArgs} args - Arguments to filter FirearmSpecs to count.
     * @example
     * // Count the number of FirearmSpecs
     * const count = await prisma.firearmSpecs.count({
     *   where: {
     *     // ... the filter for the FirearmSpecs we want to count
     *   }
     * })
    **/
    count<T extends FirearmSpecsCountArgs>(
      args?: Subset<T, FirearmSpecsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FirearmSpecsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FirearmSpecs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FirearmSpecsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FirearmSpecsAggregateArgs>(args: Subset<T, FirearmSpecsAggregateArgs>): Prisma.PrismaPromise<GetFirearmSpecsAggregateType<T>>

    /**
     * Group by FirearmSpecs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FirearmSpecsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FirearmSpecsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FirearmSpecsGroupByArgs['orderBy'] }
        : { orderBy?: FirearmSpecsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FirearmSpecsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFirearmSpecsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FirearmSpecs model
   */
  readonly fields: FirearmSpecsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FirearmSpecs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FirearmSpecsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    FirearmChamber<T extends FirearmSpecs$FirearmChamberArgs<ExtArgs> = {}>(args?: Subset<T, FirearmSpecs$FirearmChamberArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FirearmChamberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    FirearmCategory<T extends FirearmSpecs$FirearmCategoryArgs<ExtArgs> = {}>(args?: Subset<T, FirearmSpecs$FirearmCategoryArgs<ExtArgs>>): Prisma__FirearmCategoryClient<$Result.GetResult<Prisma.$FirearmCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    CatalogItem<T extends CatalogItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CatalogItemDefaultArgs<ExtArgs>>): Prisma__CatalogItemClient<$Result.GetResult<Prisma.$CatalogItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FirearmSpecs model
   */
  interface FirearmSpecsFieldRefs {
    readonly id: FieldRef<"FirearmSpecs", 'Int'>
    readonly itemId: FieldRef<"FirearmSpecs", 'String'>
    readonly manufacturer: FieldRef<"FirearmSpecs", 'String'>
    readonly model: FieldRef<"FirearmSpecs", 'String'>
    readonly platform: FieldRef<"FirearmSpecs", 'String'>
    readonly firearmCategoryId: FieldRef<"FirearmSpecs", 'Int'>
    readonly barrelLengthIn: FieldRef<"FirearmSpecs", 'Float'>
    readonly actionType: FieldRef<"FirearmSpecs", 'String'>
    readonly isThreaded: FieldRef<"FirearmSpecs", 'Boolean'>
    readonly pressureRating: FieldRef<"FirearmSpecs", 'FirearmPressureRating'>
    readonly firearmType: FieldRef<"FirearmSpecs", 'String'>
    readonly capacity: FieldRef<"FirearmSpecs", 'String'>
    readonly finish: FieldRef<"FirearmSpecs", 'String'>
    readonly weight: FieldRef<"FirearmSpecs", 'String'>
    readonly overallLength: FieldRef<"FirearmSpecs", 'String'>
    readonly features: FieldRef<"FirearmSpecs", 'String'>
    readonly sight: FieldRef<"FirearmSpecs", 'String'>
    readonly safety: FieldRef<"FirearmSpecs", 'String'>
  }
    

  // Custom InputTypes
  /**
   * FirearmSpecs findUnique
   */
  export type FirearmSpecsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FirearmSpecs
     */
    select?: FirearmSpecsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FirearmSpecs
     */
    omit?: FirearmSpecsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FirearmSpecsInclude<ExtArgs> | null
    /**
     * Filter, which FirearmSpecs to fetch.
     */
    where: FirearmSpecsWhereUniqueInput
  }

  /**
   * FirearmSpecs findUniqueOrThrow
   */
  export type FirearmSpecsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FirearmSpecs
     */
    select?: FirearmSpecsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FirearmSpecs
     */
    omit?: FirearmSpecsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FirearmSpecsInclude<ExtArgs> | null
    /**
     * Filter, which FirearmSpecs to fetch.
     */
    where: FirearmSpecsWhereUniqueInput
  }

  /**
   * FirearmSpecs findFirst
   */
  export type FirearmSpecsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FirearmSpecs
     */
    select?: FirearmSpecsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FirearmSpecs
     */
    omit?: FirearmSpecsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FirearmSpecsInclude<ExtArgs> | null
    /**
     * Filter, which FirearmSpecs to fetch.
     */
    where?: FirearmSpecsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FirearmSpecs to fetch.
     */
    orderBy?: FirearmSpecsOrderByWithRelationInput | FirearmSpecsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FirearmSpecs.
     */
    cursor?: FirearmSpecsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FirearmSpecs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FirearmSpecs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FirearmSpecs.
     */
    distinct?: FirearmSpecsScalarFieldEnum | FirearmSpecsScalarFieldEnum[]
  }

  /**
   * FirearmSpecs findFirstOrThrow
   */
  export type FirearmSpecsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FirearmSpecs
     */
    select?: FirearmSpecsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FirearmSpecs
     */
    omit?: FirearmSpecsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FirearmSpecsInclude<ExtArgs> | null
    /**
     * Filter, which FirearmSpecs to fetch.
     */
    where?: FirearmSpecsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FirearmSpecs to fetch.
     */
    orderBy?: FirearmSpecsOrderByWithRelationInput | FirearmSpecsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FirearmSpecs.
     */
    cursor?: FirearmSpecsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FirearmSpecs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FirearmSpecs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FirearmSpecs.
     */
    distinct?: FirearmSpecsScalarFieldEnum | FirearmSpecsScalarFieldEnum[]
  }

  /**
   * FirearmSpecs findMany
   */
  export type FirearmSpecsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FirearmSpecs
     */
    select?: FirearmSpecsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FirearmSpecs
     */
    omit?: FirearmSpecsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FirearmSpecsInclude<ExtArgs> | null
    /**
     * Filter, which FirearmSpecs to fetch.
     */
    where?: FirearmSpecsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FirearmSpecs to fetch.
     */
    orderBy?: FirearmSpecsOrderByWithRelationInput | FirearmSpecsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FirearmSpecs.
     */
    cursor?: FirearmSpecsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FirearmSpecs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FirearmSpecs.
     */
    skip?: number
    distinct?: FirearmSpecsScalarFieldEnum | FirearmSpecsScalarFieldEnum[]
  }

  /**
   * FirearmSpecs create
   */
  export type FirearmSpecsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FirearmSpecs
     */
    select?: FirearmSpecsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FirearmSpecs
     */
    omit?: FirearmSpecsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FirearmSpecsInclude<ExtArgs> | null
    /**
     * The data needed to create a FirearmSpecs.
     */
    data: XOR<FirearmSpecsCreateInput, FirearmSpecsUncheckedCreateInput>
  }

  /**
   * FirearmSpecs createMany
   */
  export type FirearmSpecsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FirearmSpecs.
     */
    data: FirearmSpecsCreateManyInput | FirearmSpecsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FirearmSpecs createManyAndReturn
   */
  export type FirearmSpecsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FirearmSpecs
     */
    select?: FirearmSpecsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FirearmSpecs
     */
    omit?: FirearmSpecsOmit<ExtArgs> | null
    /**
     * The data used to create many FirearmSpecs.
     */
    data: FirearmSpecsCreateManyInput | FirearmSpecsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FirearmSpecsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FirearmSpecs update
   */
  export type FirearmSpecsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FirearmSpecs
     */
    select?: FirearmSpecsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FirearmSpecs
     */
    omit?: FirearmSpecsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FirearmSpecsInclude<ExtArgs> | null
    /**
     * The data needed to update a FirearmSpecs.
     */
    data: XOR<FirearmSpecsUpdateInput, FirearmSpecsUncheckedUpdateInput>
    /**
     * Choose, which FirearmSpecs to update.
     */
    where: FirearmSpecsWhereUniqueInput
  }

  /**
   * FirearmSpecs updateMany
   */
  export type FirearmSpecsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FirearmSpecs.
     */
    data: XOR<FirearmSpecsUpdateManyMutationInput, FirearmSpecsUncheckedUpdateManyInput>
    /**
     * Filter which FirearmSpecs to update
     */
    where?: FirearmSpecsWhereInput
    /**
     * Limit how many FirearmSpecs to update.
     */
    limit?: number
  }

  /**
   * FirearmSpecs updateManyAndReturn
   */
  export type FirearmSpecsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FirearmSpecs
     */
    select?: FirearmSpecsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FirearmSpecs
     */
    omit?: FirearmSpecsOmit<ExtArgs> | null
    /**
     * The data used to update FirearmSpecs.
     */
    data: XOR<FirearmSpecsUpdateManyMutationInput, FirearmSpecsUncheckedUpdateManyInput>
    /**
     * Filter which FirearmSpecs to update
     */
    where?: FirearmSpecsWhereInput
    /**
     * Limit how many FirearmSpecs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FirearmSpecsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FirearmSpecs upsert
   */
  export type FirearmSpecsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FirearmSpecs
     */
    select?: FirearmSpecsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FirearmSpecs
     */
    omit?: FirearmSpecsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FirearmSpecsInclude<ExtArgs> | null
    /**
     * The filter to search for the FirearmSpecs to update in case it exists.
     */
    where: FirearmSpecsWhereUniqueInput
    /**
     * In case the FirearmSpecs found by the `where` argument doesn't exist, create a new FirearmSpecs with this data.
     */
    create: XOR<FirearmSpecsCreateInput, FirearmSpecsUncheckedCreateInput>
    /**
     * In case the FirearmSpecs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FirearmSpecsUpdateInput, FirearmSpecsUncheckedUpdateInput>
  }

  /**
   * FirearmSpecs delete
   */
  export type FirearmSpecsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FirearmSpecs
     */
    select?: FirearmSpecsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FirearmSpecs
     */
    omit?: FirearmSpecsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FirearmSpecsInclude<ExtArgs> | null
    /**
     * Filter which FirearmSpecs to delete.
     */
    where: FirearmSpecsWhereUniqueInput
  }

  /**
   * FirearmSpecs deleteMany
   */
  export type FirearmSpecsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FirearmSpecs to delete
     */
    where?: FirearmSpecsWhereInput
    /**
     * Limit how many FirearmSpecs to delete.
     */
    limit?: number
  }

  /**
   * FirearmSpecs.FirearmChamber
   */
  export type FirearmSpecs$FirearmChamberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FirearmChamber
     */
    select?: FirearmChamberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FirearmChamber
     */
    omit?: FirearmChamberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FirearmChamberInclude<ExtArgs> | null
    where?: FirearmChamberWhereInput
    orderBy?: FirearmChamberOrderByWithRelationInput | FirearmChamberOrderByWithRelationInput[]
    cursor?: FirearmChamberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FirearmChamberScalarFieldEnum | FirearmChamberScalarFieldEnum[]
  }

  /**
   * FirearmSpecs.FirearmCategory
   */
  export type FirearmSpecs$FirearmCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FirearmCategory
     */
    select?: FirearmCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FirearmCategory
     */
    omit?: FirearmCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FirearmCategoryInclude<ExtArgs> | null
    where?: FirearmCategoryWhereInput
  }

  /**
   * FirearmSpecs without action
   */
  export type FirearmSpecsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FirearmSpecs
     */
    select?: FirearmSpecsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FirearmSpecs
     */
    omit?: FirearmSpecsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FirearmSpecsInclude<ExtArgs> | null
  }


  /**
   * Model OwnedFirearm
   */

  export type AggregateOwnedFirearm = {
    _count: OwnedFirearmCountAggregateOutputType | null
    _min: OwnedFirearmMinAggregateOutputType | null
    _max: OwnedFirearmMaxAggregateOutputType | null
  }

  export type OwnedFirearmMinAggregateOutputType = {
    id: string | null
    userId: string | null
    firearmItemId: string | null
    nickname: string | null
    createdAt: Date | null
  }

  export type OwnedFirearmMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    firearmItemId: string | null
    nickname: string | null
    createdAt: Date | null
  }

  export type OwnedFirearmCountAggregateOutputType = {
    id: number
    userId: number
    firearmItemId: number
    nickname: number
    createdAt: number
    _all: number
  }


  export type OwnedFirearmMinAggregateInputType = {
    id?: true
    userId?: true
    firearmItemId?: true
    nickname?: true
    createdAt?: true
  }

  export type OwnedFirearmMaxAggregateInputType = {
    id?: true
    userId?: true
    firearmItemId?: true
    nickname?: true
    createdAt?: true
  }

  export type OwnedFirearmCountAggregateInputType = {
    id?: true
    userId?: true
    firearmItemId?: true
    nickname?: true
    createdAt?: true
    _all?: true
  }

  export type OwnedFirearmAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OwnedFirearm to aggregate.
     */
    where?: OwnedFirearmWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OwnedFirearms to fetch.
     */
    orderBy?: OwnedFirearmOrderByWithRelationInput | OwnedFirearmOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OwnedFirearmWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OwnedFirearms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OwnedFirearms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OwnedFirearms
    **/
    _count?: true | OwnedFirearmCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OwnedFirearmMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OwnedFirearmMaxAggregateInputType
  }

  export type GetOwnedFirearmAggregateType<T extends OwnedFirearmAggregateArgs> = {
        [P in keyof T & keyof AggregateOwnedFirearm]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOwnedFirearm[P]>
      : GetScalarType<T[P], AggregateOwnedFirearm[P]>
  }




  export type OwnedFirearmGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OwnedFirearmWhereInput
    orderBy?: OwnedFirearmOrderByWithAggregationInput | OwnedFirearmOrderByWithAggregationInput[]
    by: OwnedFirearmScalarFieldEnum[] | OwnedFirearmScalarFieldEnum
    having?: OwnedFirearmScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OwnedFirearmCountAggregateInputType | true
    _min?: OwnedFirearmMinAggregateInputType
    _max?: OwnedFirearmMaxAggregateInputType
  }

  export type OwnedFirearmGroupByOutputType = {
    id: string
    userId: string
    firearmItemId: string
    nickname: string | null
    createdAt: Date | null
    _count: OwnedFirearmCountAggregateOutputType | null
    _min: OwnedFirearmMinAggregateOutputType | null
    _max: OwnedFirearmMaxAggregateOutputType | null
  }

  type GetOwnedFirearmGroupByPayload<T extends OwnedFirearmGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OwnedFirearmGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OwnedFirearmGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OwnedFirearmGroupByOutputType[P]>
            : GetScalarType<T[P], OwnedFirearmGroupByOutputType[P]>
        }
      >
    >


  export type OwnedFirearmSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    firearmItemId?: boolean
    nickname?: boolean
    createdAt?: boolean
    CatalogItem?: boolean | CatalogItemDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ownedFirearm"]>

  export type OwnedFirearmSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    firearmItemId?: boolean
    nickname?: boolean
    createdAt?: boolean
    CatalogItem?: boolean | CatalogItemDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ownedFirearm"]>

  export type OwnedFirearmSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    firearmItemId?: boolean
    nickname?: boolean
    createdAt?: boolean
    CatalogItem?: boolean | CatalogItemDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ownedFirearm"]>

  export type OwnedFirearmSelectScalar = {
    id?: boolean
    userId?: boolean
    firearmItemId?: boolean
    nickname?: boolean
    createdAt?: boolean
  }

  export type OwnedFirearmOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "firearmItemId" | "nickname" | "createdAt", ExtArgs["result"]["ownedFirearm"]>
  export type OwnedFirearmInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CatalogItem?: boolean | CatalogItemDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type OwnedFirearmIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CatalogItem?: boolean | CatalogItemDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type OwnedFirearmIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CatalogItem?: boolean | CatalogItemDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $OwnedFirearmPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OwnedFirearm"
    objects: {
      CatalogItem: Prisma.$CatalogItemPayload<ExtArgs>
      User: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      firearmItemId: string
      nickname: string | null
      createdAt: Date | null
    }, ExtArgs["result"]["ownedFirearm"]>
    composites: {}
  }

  type OwnedFirearmGetPayload<S extends boolean | null | undefined | OwnedFirearmDefaultArgs> = $Result.GetResult<Prisma.$OwnedFirearmPayload, S>

  type OwnedFirearmCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OwnedFirearmFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OwnedFirearmCountAggregateInputType | true
    }

  export interface OwnedFirearmDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OwnedFirearm'], meta: { name: 'OwnedFirearm' } }
    /**
     * Find zero or one OwnedFirearm that matches the filter.
     * @param {OwnedFirearmFindUniqueArgs} args - Arguments to find a OwnedFirearm
     * @example
     * // Get one OwnedFirearm
     * const ownedFirearm = await prisma.ownedFirearm.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OwnedFirearmFindUniqueArgs>(args: SelectSubset<T, OwnedFirearmFindUniqueArgs<ExtArgs>>): Prisma__OwnedFirearmClient<$Result.GetResult<Prisma.$OwnedFirearmPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OwnedFirearm that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OwnedFirearmFindUniqueOrThrowArgs} args - Arguments to find a OwnedFirearm
     * @example
     * // Get one OwnedFirearm
     * const ownedFirearm = await prisma.ownedFirearm.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OwnedFirearmFindUniqueOrThrowArgs>(args: SelectSubset<T, OwnedFirearmFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OwnedFirearmClient<$Result.GetResult<Prisma.$OwnedFirearmPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OwnedFirearm that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnedFirearmFindFirstArgs} args - Arguments to find a OwnedFirearm
     * @example
     * // Get one OwnedFirearm
     * const ownedFirearm = await prisma.ownedFirearm.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OwnedFirearmFindFirstArgs>(args?: SelectSubset<T, OwnedFirearmFindFirstArgs<ExtArgs>>): Prisma__OwnedFirearmClient<$Result.GetResult<Prisma.$OwnedFirearmPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OwnedFirearm that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnedFirearmFindFirstOrThrowArgs} args - Arguments to find a OwnedFirearm
     * @example
     * // Get one OwnedFirearm
     * const ownedFirearm = await prisma.ownedFirearm.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OwnedFirearmFindFirstOrThrowArgs>(args?: SelectSubset<T, OwnedFirearmFindFirstOrThrowArgs<ExtArgs>>): Prisma__OwnedFirearmClient<$Result.GetResult<Prisma.$OwnedFirearmPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OwnedFirearms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnedFirearmFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OwnedFirearms
     * const ownedFirearms = await prisma.ownedFirearm.findMany()
     * 
     * // Get first 10 OwnedFirearms
     * const ownedFirearms = await prisma.ownedFirearm.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ownedFirearmWithIdOnly = await prisma.ownedFirearm.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OwnedFirearmFindManyArgs>(args?: SelectSubset<T, OwnedFirearmFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OwnedFirearmPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OwnedFirearm.
     * @param {OwnedFirearmCreateArgs} args - Arguments to create a OwnedFirearm.
     * @example
     * // Create one OwnedFirearm
     * const OwnedFirearm = await prisma.ownedFirearm.create({
     *   data: {
     *     // ... data to create a OwnedFirearm
     *   }
     * })
     * 
     */
    create<T extends OwnedFirearmCreateArgs>(args: SelectSubset<T, OwnedFirearmCreateArgs<ExtArgs>>): Prisma__OwnedFirearmClient<$Result.GetResult<Prisma.$OwnedFirearmPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OwnedFirearms.
     * @param {OwnedFirearmCreateManyArgs} args - Arguments to create many OwnedFirearms.
     * @example
     * // Create many OwnedFirearms
     * const ownedFirearm = await prisma.ownedFirearm.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OwnedFirearmCreateManyArgs>(args?: SelectSubset<T, OwnedFirearmCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OwnedFirearms and returns the data saved in the database.
     * @param {OwnedFirearmCreateManyAndReturnArgs} args - Arguments to create many OwnedFirearms.
     * @example
     * // Create many OwnedFirearms
     * const ownedFirearm = await prisma.ownedFirearm.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OwnedFirearms and only return the `id`
     * const ownedFirearmWithIdOnly = await prisma.ownedFirearm.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OwnedFirearmCreateManyAndReturnArgs>(args?: SelectSubset<T, OwnedFirearmCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OwnedFirearmPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OwnedFirearm.
     * @param {OwnedFirearmDeleteArgs} args - Arguments to delete one OwnedFirearm.
     * @example
     * // Delete one OwnedFirearm
     * const OwnedFirearm = await prisma.ownedFirearm.delete({
     *   where: {
     *     // ... filter to delete one OwnedFirearm
     *   }
     * })
     * 
     */
    delete<T extends OwnedFirearmDeleteArgs>(args: SelectSubset<T, OwnedFirearmDeleteArgs<ExtArgs>>): Prisma__OwnedFirearmClient<$Result.GetResult<Prisma.$OwnedFirearmPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OwnedFirearm.
     * @param {OwnedFirearmUpdateArgs} args - Arguments to update one OwnedFirearm.
     * @example
     * // Update one OwnedFirearm
     * const ownedFirearm = await prisma.ownedFirearm.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OwnedFirearmUpdateArgs>(args: SelectSubset<T, OwnedFirearmUpdateArgs<ExtArgs>>): Prisma__OwnedFirearmClient<$Result.GetResult<Prisma.$OwnedFirearmPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OwnedFirearms.
     * @param {OwnedFirearmDeleteManyArgs} args - Arguments to filter OwnedFirearms to delete.
     * @example
     * // Delete a few OwnedFirearms
     * const { count } = await prisma.ownedFirearm.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OwnedFirearmDeleteManyArgs>(args?: SelectSubset<T, OwnedFirearmDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OwnedFirearms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnedFirearmUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OwnedFirearms
     * const ownedFirearm = await prisma.ownedFirearm.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OwnedFirearmUpdateManyArgs>(args: SelectSubset<T, OwnedFirearmUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OwnedFirearms and returns the data updated in the database.
     * @param {OwnedFirearmUpdateManyAndReturnArgs} args - Arguments to update many OwnedFirearms.
     * @example
     * // Update many OwnedFirearms
     * const ownedFirearm = await prisma.ownedFirearm.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OwnedFirearms and only return the `id`
     * const ownedFirearmWithIdOnly = await prisma.ownedFirearm.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OwnedFirearmUpdateManyAndReturnArgs>(args: SelectSubset<T, OwnedFirearmUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OwnedFirearmPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OwnedFirearm.
     * @param {OwnedFirearmUpsertArgs} args - Arguments to update or create a OwnedFirearm.
     * @example
     * // Update or create a OwnedFirearm
     * const ownedFirearm = await prisma.ownedFirearm.upsert({
     *   create: {
     *     // ... data to create a OwnedFirearm
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OwnedFirearm we want to update
     *   }
     * })
     */
    upsert<T extends OwnedFirearmUpsertArgs>(args: SelectSubset<T, OwnedFirearmUpsertArgs<ExtArgs>>): Prisma__OwnedFirearmClient<$Result.GetResult<Prisma.$OwnedFirearmPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OwnedFirearms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnedFirearmCountArgs} args - Arguments to filter OwnedFirearms to count.
     * @example
     * // Count the number of OwnedFirearms
     * const count = await prisma.ownedFirearm.count({
     *   where: {
     *     // ... the filter for the OwnedFirearms we want to count
     *   }
     * })
    **/
    count<T extends OwnedFirearmCountArgs>(
      args?: Subset<T, OwnedFirearmCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OwnedFirearmCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OwnedFirearm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnedFirearmAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OwnedFirearmAggregateArgs>(args: Subset<T, OwnedFirearmAggregateArgs>): Prisma.PrismaPromise<GetOwnedFirearmAggregateType<T>>

    /**
     * Group by OwnedFirearm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnedFirearmGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OwnedFirearmGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OwnedFirearmGroupByArgs['orderBy'] }
        : { orderBy?: OwnedFirearmGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OwnedFirearmGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOwnedFirearmGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OwnedFirearm model
   */
  readonly fields: OwnedFirearmFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OwnedFirearm.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OwnedFirearmClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    CatalogItem<T extends CatalogItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CatalogItemDefaultArgs<ExtArgs>>): Prisma__CatalogItemClient<$Result.GetResult<Prisma.$CatalogItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OwnedFirearm model
   */
  interface OwnedFirearmFieldRefs {
    readonly id: FieldRef<"OwnedFirearm", 'String'>
    readonly userId: FieldRef<"OwnedFirearm", 'String'>
    readonly firearmItemId: FieldRef<"OwnedFirearm", 'String'>
    readonly nickname: FieldRef<"OwnedFirearm", 'String'>
    readonly createdAt: FieldRef<"OwnedFirearm", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OwnedFirearm findUnique
   */
  export type OwnedFirearmFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnedFirearm
     */
    select?: OwnedFirearmSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OwnedFirearm
     */
    omit?: OwnedFirearmOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnedFirearmInclude<ExtArgs> | null
    /**
     * Filter, which OwnedFirearm to fetch.
     */
    where: OwnedFirearmWhereUniqueInput
  }

  /**
   * OwnedFirearm findUniqueOrThrow
   */
  export type OwnedFirearmFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnedFirearm
     */
    select?: OwnedFirearmSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OwnedFirearm
     */
    omit?: OwnedFirearmOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnedFirearmInclude<ExtArgs> | null
    /**
     * Filter, which OwnedFirearm to fetch.
     */
    where: OwnedFirearmWhereUniqueInput
  }

  /**
   * OwnedFirearm findFirst
   */
  export type OwnedFirearmFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnedFirearm
     */
    select?: OwnedFirearmSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OwnedFirearm
     */
    omit?: OwnedFirearmOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnedFirearmInclude<ExtArgs> | null
    /**
     * Filter, which OwnedFirearm to fetch.
     */
    where?: OwnedFirearmWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OwnedFirearms to fetch.
     */
    orderBy?: OwnedFirearmOrderByWithRelationInput | OwnedFirearmOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OwnedFirearms.
     */
    cursor?: OwnedFirearmWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OwnedFirearms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OwnedFirearms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OwnedFirearms.
     */
    distinct?: OwnedFirearmScalarFieldEnum | OwnedFirearmScalarFieldEnum[]
  }

  /**
   * OwnedFirearm findFirstOrThrow
   */
  export type OwnedFirearmFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnedFirearm
     */
    select?: OwnedFirearmSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OwnedFirearm
     */
    omit?: OwnedFirearmOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnedFirearmInclude<ExtArgs> | null
    /**
     * Filter, which OwnedFirearm to fetch.
     */
    where?: OwnedFirearmWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OwnedFirearms to fetch.
     */
    orderBy?: OwnedFirearmOrderByWithRelationInput | OwnedFirearmOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OwnedFirearms.
     */
    cursor?: OwnedFirearmWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OwnedFirearms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OwnedFirearms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OwnedFirearms.
     */
    distinct?: OwnedFirearmScalarFieldEnum | OwnedFirearmScalarFieldEnum[]
  }

  /**
   * OwnedFirearm findMany
   */
  export type OwnedFirearmFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnedFirearm
     */
    select?: OwnedFirearmSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OwnedFirearm
     */
    omit?: OwnedFirearmOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnedFirearmInclude<ExtArgs> | null
    /**
     * Filter, which OwnedFirearms to fetch.
     */
    where?: OwnedFirearmWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OwnedFirearms to fetch.
     */
    orderBy?: OwnedFirearmOrderByWithRelationInput | OwnedFirearmOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OwnedFirearms.
     */
    cursor?: OwnedFirearmWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OwnedFirearms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OwnedFirearms.
     */
    skip?: number
    distinct?: OwnedFirearmScalarFieldEnum | OwnedFirearmScalarFieldEnum[]
  }

  /**
   * OwnedFirearm create
   */
  export type OwnedFirearmCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnedFirearm
     */
    select?: OwnedFirearmSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OwnedFirearm
     */
    omit?: OwnedFirearmOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnedFirearmInclude<ExtArgs> | null
    /**
     * The data needed to create a OwnedFirearm.
     */
    data: XOR<OwnedFirearmCreateInput, OwnedFirearmUncheckedCreateInput>
  }

  /**
   * OwnedFirearm createMany
   */
  export type OwnedFirearmCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OwnedFirearms.
     */
    data: OwnedFirearmCreateManyInput | OwnedFirearmCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OwnedFirearm createManyAndReturn
   */
  export type OwnedFirearmCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnedFirearm
     */
    select?: OwnedFirearmSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OwnedFirearm
     */
    omit?: OwnedFirearmOmit<ExtArgs> | null
    /**
     * The data used to create many OwnedFirearms.
     */
    data: OwnedFirearmCreateManyInput | OwnedFirearmCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnedFirearmIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OwnedFirearm update
   */
  export type OwnedFirearmUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnedFirearm
     */
    select?: OwnedFirearmSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OwnedFirearm
     */
    omit?: OwnedFirearmOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnedFirearmInclude<ExtArgs> | null
    /**
     * The data needed to update a OwnedFirearm.
     */
    data: XOR<OwnedFirearmUpdateInput, OwnedFirearmUncheckedUpdateInput>
    /**
     * Choose, which OwnedFirearm to update.
     */
    where: OwnedFirearmWhereUniqueInput
  }

  /**
   * OwnedFirearm updateMany
   */
  export type OwnedFirearmUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OwnedFirearms.
     */
    data: XOR<OwnedFirearmUpdateManyMutationInput, OwnedFirearmUncheckedUpdateManyInput>
    /**
     * Filter which OwnedFirearms to update
     */
    where?: OwnedFirearmWhereInput
    /**
     * Limit how many OwnedFirearms to update.
     */
    limit?: number
  }

  /**
   * OwnedFirearm updateManyAndReturn
   */
  export type OwnedFirearmUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnedFirearm
     */
    select?: OwnedFirearmSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OwnedFirearm
     */
    omit?: OwnedFirearmOmit<ExtArgs> | null
    /**
     * The data used to update OwnedFirearms.
     */
    data: XOR<OwnedFirearmUpdateManyMutationInput, OwnedFirearmUncheckedUpdateManyInput>
    /**
     * Filter which OwnedFirearms to update
     */
    where?: OwnedFirearmWhereInput
    /**
     * Limit how many OwnedFirearms to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnedFirearmIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OwnedFirearm upsert
   */
  export type OwnedFirearmUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnedFirearm
     */
    select?: OwnedFirearmSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OwnedFirearm
     */
    omit?: OwnedFirearmOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnedFirearmInclude<ExtArgs> | null
    /**
     * The filter to search for the OwnedFirearm to update in case it exists.
     */
    where: OwnedFirearmWhereUniqueInput
    /**
     * In case the OwnedFirearm found by the `where` argument doesn't exist, create a new OwnedFirearm with this data.
     */
    create: XOR<OwnedFirearmCreateInput, OwnedFirearmUncheckedCreateInput>
    /**
     * In case the OwnedFirearm was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OwnedFirearmUpdateInput, OwnedFirearmUncheckedUpdateInput>
  }

  /**
   * OwnedFirearm delete
   */
  export type OwnedFirearmDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnedFirearm
     */
    select?: OwnedFirearmSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OwnedFirearm
     */
    omit?: OwnedFirearmOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnedFirearmInclude<ExtArgs> | null
    /**
     * Filter which OwnedFirearm to delete.
     */
    where: OwnedFirearmWhereUniqueInput
  }

  /**
   * OwnedFirearm deleteMany
   */
  export type OwnedFirearmDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OwnedFirearms to delete
     */
    where?: OwnedFirearmWhereInput
    /**
     * Limit how many OwnedFirearms to delete.
     */
    limit?: number
  }

  /**
   * OwnedFirearm without action
   */
  export type OwnedFirearmDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnedFirearm
     */
    select?: OwnedFirearmSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OwnedFirearm
     */
    omit?: OwnedFirearmOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnedFirearmInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: Date | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: Date | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    emailVerified: number
    image: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string | null
    email: string | null
    emailVerified: Date | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Alert?: boolean | User$AlertArgs<ExtArgs>
    AlertDelivery?: boolean | User$AlertDeliveryArgs<ExtArgs>
    BlockedRetailer?: boolean | User$BlockedRetailerArgs<ExtArgs>
    OwnedFirearm?: boolean | User$OwnedFirearmArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "emailVerified" | "image" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Alert?: boolean | User$AlertArgs<ExtArgs>
    AlertDelivery?: boolean | User$AlertDeliveryArgs<ExtArgs>
    BlockedRetailer?: boolean | User$BlockedRetailerArgs<ExtArgs>
    OwnedFirearm?: boolean | User$OwnedFirearmArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      Alert: Prisma.$AlertPayload<ExtArgs>[]
      AlertDelivery: Prisma.$AlertDeliveryPayload<ExtArgs>[]
      BlockedRetailer: Prisma.$BlockedRetailerPayload<ExtArgs>[]
      OwnedFirearm: Prisma.$OwnedFirearmPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
      email: string | null
      emailVerified: Date | null
      image: string | null
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Alert<T extends User$AlertArgs<ExtArgs> = {}>(args?: Subset<T, User$AlertArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    AlertDelivery<T extends User$AlertDeliveryArgs<ExtArgs> = {}>(args?: Subset<T, User$AlertDeliveryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertDeliveryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    BlockedRetailer<T extends User$BlockedRetailerArgs<ExtArgs> = {}>(args?: Subset<T, User$BlockedRetailerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockedRetailerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    OwnedFirearm<T extends User$OwnedFirearmArgs<ExtArgs> = {}>(args?: Subset<T, User$OwnedFirearmArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OwnedFirearmPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'DateTime'>
    readonly image: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.Alert
   */
  export type User$AlertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    where?: AlertWhereInput
    orderBy?: AlertOrderByWithRelationInput | AlertOrderByWithRelationInput[]
    cursor?: AlertWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AlertScalarFieldEnum | AlertScalarFieldEnum[]
  }

  /**
   * User.AlertDelivery
   */
  export type User$AlertDeliveryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertDelivery
     */
    select?: AlertDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlertDelivery
     */
    omit?: AlertDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertDeliveryInclude<ExtArgs> | null
    where?: AlertDeliveryWhereInput
    orderBy?: AlertDeliveryOrderByWithRelationInput | AlertDeliveryOrderByWithRelationInput[]
    cursor?: AlertDeliveryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AlertDeliveryScalarFieldEnum | AlertDeliveryScalarFieldEnum[]
  }

  /**
   * User.BlockedRetailer
   */
  export type User$BlockedRetailerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedRetailer
     */
    select?: BlockedRetailerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlockedRetailer
     */
    omit?: BlockedRetailerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockedRetailerInclude<ExtArgs> | null
    where?: BlockedRetailerWhereInput
    orderBy?: BlockedRetailerOrderByWithRelationInput | BlockedRetailerOrderByWithRelationInput[]
    cursor?: BlockedRetailerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlockedRetailerScalarFieldEnum | BlockedRetailerScalarFieldEnum[]
  }

  /**
   * User.OwnedFirearm
   */
  export type User$OwnedFirearmArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnedFirearm
     */
    select?: OwnedFirearmSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OwnedFirearm
     */
    omit?: OwnedFirearmOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnedFirearmInclude<ExtArgs> | null
    where?: OwnedFirearmWhereInput
    orderBy?: OwnedFirearmOrderByWithRelationInput | OwnedFirearmOrderByWithRelationInput[]
    cursor?: OwnedFirearmWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OwnedFirearmScalarFieldEnum | OwnedFirearmScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model raw_offer_ingest
   */

  export type AggregateRaw_offer_ingest = {
    _count: Raw_offer_ingestCountAggregateOutputType | null
    _avg: Raw_offer_ingestAvgAggregateOutputType | null
    _sum: Raw_offer_ingestSumAggregateOutputType | null
    _min: Raw_offer_ingestMinAggregateOutputType | null
    _max: Raw_offer_ingestMaxAggregateOutputType | null
  }

  export type Raw_offer_ingestAvgAggregateOutputType = {
    price: number | null
    shipping_cost: number | null
    total: number | null
  }

  export type Raw_offer_ingestSumAggregateOutputType = {
    price: number | null
    shipping_cost: number | null
    total: number | null
  }

  export type Raw_offer_ingestMinAggregateOutputType = {
    time: Date | null
    bucket_5m: Date | null
    group_id: string | null
    item_url: string | null
    item_type: string | null
    retailer_name: string | null
    offer_url: string | null
    price: number | null
    shipping_text: string | null
    shipping_cost: number | null
    total: number | null
    in_stock: boolean | null
    source: string | null
    offer_fingerprint: string | null
  }

  export type Raw_offer_ingestMaxAggregateOutputType = {
    time: Date | null
    bucket_5m: Date | null
    group_id: string | null
    item_url: string | null
    item_type: string | null
    retailer_name: string | null
    offer_url: string | null
    price: number | null
    shipping_text: string | null
    shipping_cost: number | null
    total: number | null
    in_stock: boolean | null
    source: string | null
    offer_fingerprint: string | null
  }

  export type Raw_offer_ingestCountAggregateOutputType = {
    time: number
    bucket_5m: number
    group_id: number
    item_url: number
    item_type: number
    retailer_name: number
    offer_url: number
    price: number
    shipping_text: number
    shipping_cost: number
    total: number
    in_stock: number
    source: number
    offer_fingerprint: number
    _all: number
  }


  export type Raw_offer_ingestAvgAggregateInputType = {
    price?: true
    shipping_cost?: true
    total?: true
  }

  export type Raw_offer_ingestSumAggregateInputType = {
    price?: true
    shipping_cost?: true
    total?: true
  }

  export type Raw_offer_ingestMinAggregateInputType = {
    time?: true
    bucket_5m?: true
    group_id?: true
    item_url?: true
    item_type?: true
    retailer_name?: true
    offer_url?: true
    price?: true
    shipping_text?: true
    shipping_cost?: true
    total?: true
    in_stock?: true
    source?: true
    offer_fingerprint?: true
  }

  export type Raw_offer_ingestMaxAggregateInputType = {
    time?: true
    bucket_5m?: true
    group_id?: true
    item_url?: true
    item_type?: true
    retailer_name?: true
    offer_url?: true
    price?: true
    shipping_text?: true
    shipping_cost?: true
    total?: true
    in_stock?: true
    source?: true
    offer_fingerprint?: true
  }

  export type Raw_offer_ingestCountAggregateInputType = {
    time?: true
    bucket_5m?: true
    group_id?: true
    item_url?: true
    item_type?: true
    retailer_name?: true
    offer_url?: true
    price?: true
    shipping_text?: true
    shipping_cost?: true
    total?: true
    in_stock?: true
    source?: true
    offer_fingerprint?: true
    _all?: true
  }

  export type Raw_offer_ingestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which raw_offer_ingest to aggregate.
     */
    where?: raw_offer_ingestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of raw_offer_ingests to fetch.
     */
    orderBy?: raw_offer_ingestOrderByWithRelationInput | raw_offer_ingestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: raw_offer_ingestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` raw_offer_ingests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` raw_offer_ingests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned raw_offer_ingests
    **/
    _count?: true | Raw_offer_ingestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Raw_offer_ingestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Raw_offer_ingestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Raw_offer_ingestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Raw_offer_ingestMaxAggregateInputType
  }

  export type GetRaw_offer_ingestAggregateType<T extends Raw_offer_ingestAggregateArgs> = {
        [P in keyof T & keyof AggregateRaw_offer_ingest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRaw_offer_ingest[P]>
      : GetScalarType<T[P], AggregateRaw_offer_ingest[P]>
  }




  export type raw_offer_ingestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: raw_offer_ingestWhereInput
    orderBy?: raw_offer_ingestOrderByWithAggregationInput | raw_offer_ingestOrderByWithAggregationInput[]
    by: Raw_offer_ingestScalarFieldEnum[] | Raw_offer_ingestScalarFieldEnum
    having?: raw_offer_ingestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Raw_offer_ingestCountAggregateInputType | true
    _avg?: Raw_offer_ingestAvgAggregateInputType
    _sum?: Raw_offer_ingestSumAggregateInputType
    _min?: Raw_offer_ingestMinAggregateInputType
    _max?: Raw_offer_ingestMaxAggregateInputType
  }

  export type Raw_offer_ingestGroupByOutputType = {
    time: Date
    bucket_5m: Date
    group_id: string | null
    item_url: string | null
    item_type: string | null
    retailer_name: string | null
    offer_url: string | null
    price: number | null
    shipping_text: string | null
    shipping_cost: number | null
    total: number | null
    in_stock: boolean | null
    source: string | null
    offer_fingerprint: string
    _count: Raw_offer_ingestCountAggregateOutputType | null
    _avg: Raw_offer_ingestAvgAggregateOutputType | null
    _sum: Raw_offer_ingestSumAggregateOutputType | null
    _min: Raw_offer_ingestMinAggregateOutputType | null
    _max: Raw_offer_ingestMaxAggregateOutputType | null
  }

  type GetRaw_offer_ingestGroupByPayload<T extends raw_offer_ingestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Raw_offer_ingestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Raw_offer_ingestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Raw_offer_ingestGroupByOutputType[P]>
            : GetScalarType<T[P], Raw_offer_ingestGroupByOutputType[P]>
        }
      >
    >


  export type raw_offer_ingestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    time?: boolean
    bucket_5m?: boolean
    group_id?: boolean
    item_url?: boolean
    item_type?: boolean
    retailer_name?: boolean
    offer_url?: boolean
    price?: boolean
    shipping_text?: boolean
    shipping_cost?: boolean
    total?: boolean
    in_stock?: boolean
    source?: boolean
    offer_fingerprint?: boolean
  }, ExtArgs["result"]["raw_offer_ingest"]>

  export type raw_offer_ingestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    time?: boolean
    bucket_5m?: boolean
    group_id?: boolean
    item_url?: boolean
    item_type?: boolean
    retailer_name?: boolean
    offer_url?: boolean
    price?: boolean
    shipping_text?: boolean
    shipping_cost?: boolean
    total?: boolean
    in_stock?: boolean
    source?: boolean
    offer_fingerprint?: boolean
  }, ExtArgs["result"]["raw_offer_ingest"]>

  export type raw_offer_ingestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    time?: boolean
    bucket_5m?: boolean
    group_id?: boolean
    item_url?: boolean
    item_type?: boolean
    retailer_name?: boolean
    offer_url?: boolean
    price?: boolean
    shipping_text?: boolean
    shipping_cost?: boolean
    total?: boolean
    in_stock?: boolean
    source?: boolean
    offer_fingerprint?: boolean
  }, ExtArgs["result"]["raw_offer_ingest"]>

  export type raw_offer_ingestSelectScalar = {
    time?: boolean
    bucket_5m?: boolean
    group_id?: boolean
    item_url?: boolean
    item_type?: boolean
    retailer_name?: boolean
    offer_url?: boolean
    price?: boolean
    shipping_text?: boolean
    shipping_cost?: boolean
    total?: boolean
    in_stock?: boolean
    source?: boolean
    offer_fingerprint?: boolean
  }

  export type raw_offer_ingestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"time" | "bucket_5m" | "group_id" | "item_url" | "item_type" | "retailer_name" | "offer_url" | "price" | "shipping_text" | "shipping_cost" | "total" | "in_stock" | "source" | "offer_fingerprint", ExtArgs["result"]["raw_offer_ingest"]>

  export type $raw_offer_ingestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "raw_offer_ingest"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      time: Date
      bucket_5m: Date
      group_id: string | null
      item_url: string | null
      item_type: string | null
      retailer_name: string | null
      offer_url: string | null
      price: number | null
      shipping_text: string | null
      shipping_cost: number | null
      total: number | null
      in_stock: boolean | null
      source: string | null
      offer_fingerprint: string
    }, ExtArgs["result"]["raw_offer_ingest"]>
    composites: {}
  }

  type raw_offer_ingestGetPayload<S extends boolean | null | undefined | raw_offer_ingestDefaultArgs> = $Result.GetResult<Prisma.$raw_offer_ingestPayload, S>

  type raw_offer_ingestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<raw_offer_ingestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Raw_offer_ingestCountAggregateInputType | true
    }

  export interface raw_offer_ingestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['raw_offer_ingest'], meta: { name: 'raw_offer_ingest' } }
    /**
     * Find zero or one Raw_offer_ingest that matches the filter.
     * @param {raw_offer_ingestFindUniqueArgs} args - Arguments to find a Raw_offer_ingest
     * @example
     * // Get one Raw_offer_ingest
     * const raw_offer_ingest = await prisma.raw_offer_ingest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends raw_offer_ingestFindUniqueArgs>(args: SelectSubset<T, raw_offer_ingestFindUniqueArgs<ExtArgs>>): Prisma__raw_offer_ingestClient<$Result.GetResult<Prisma.$raw_offer_ingestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Raw_offer_ingest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {raw_offer_ingestFindUniqueOrThrowArgs} args - Arguments to find a Raw_offer_ingest
     * @example
     * // Get one Raw_offer_ingest
     * const raw_offer_ingest = await prisma.raw_offer_ingest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends raw_offer_ingestFindUniqueOrThrowArgs>(args: SelectSubset<T, raw_offer_ingestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__raw_offer_ingestClient<$Result.GetResult<Prisma.$raw_offer_ingestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Raw_offer_ingest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {raw_offer_ingestFindFirstArgs} args - Arguments to find a Raw_offer_ingest
     * @example
     * // Get one Raw_offer_ingest
     * const raw_offer_ingest = await prisma.raw_offer_ingest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends raw_offer_ingestFindFirstArgs>(args?: SelectSubset<T, raw_offer_ingestFindFirstArgs<ExtArgs>>): Prisma__raw_offer_ingestClient<$Result.GetResult<Prisma.$raw_offer_ingestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Raw_offer_ingest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {raw_offer_ingestFindFirstOrThrowArgs} args - Arguments to find a Raw_offer_ingest
     * @example
     * // Get one Raw_offer_ingest
     * const raw_offer_ingest = await prisma.raw_offer_ingest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends raw_offer_ingestFindFirstOrThrowArgs>(args?: SelectSubset<T, raw_offer_ingestFindFirstOrThrowArgs<ExtArgs>>): Prisma__raw_offer_ingestClient<$Result.GetResult<Prisma.$raw_offer_ingestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Raw_offer_ingests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {raw_offer_ingestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Raw_offer_ingests
     * const raw_offer_ingests = await prisma.raw_offer_ingest.findMany()
     * 
     * // Get first 10 Raw_offer_ingests
     * const raw_offer_ingests = await prisma.raw_offer_ingest.findMany({ take: 10 })
     * 
     * // Only select the `time`
     * const raw_offer_ingestWithTimeOnly = await prisma.raw_offer_ingest.findMany({ select: { time: true } })
     * 
     */
    findMany<T extends raw_offer_ingestFindManyArgs>(args?: SelectSubset<T, raw_offer_ingestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$raw_offer_ingestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Raw_offer_ingest.
     * @param {raw_offer_ingestCreateArgs} args - Arguments to create a Raw_offer_ingest.
     * @example
     * // Create one Raw_offer_ingest
     * const Raw_offer_ingest = await prisma.raw_offer_ingest.create({
     *   data: {
     *     // ... data to create a Raw_offer_ingest
     *   }
     * })
     * 
     */
    create<T extends raw_offer_ingestCreateArgs>(args: SelectSubset<T, raw_offer_ingestCreateArgs<ExtArgs>>): Prisma__raw_offer_ingestClient<$Result.GetResult<Prisma.$raw_offer_ingestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Raw_offer_ingests.
     * @param {raw_offer_ingestCreateManyArgs} args - Arguments to create many Raw_offer_ingests.
     * @example
     * // Create many Raw_offer_ingests
     * const raw_offer_ingest = await prisma.raw_offer_ingest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends raw_offer_ingestCreateManyArgs>(args?: SelectSubset<T, raw_offer_ingestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Raw_offer_ingests and returns the data saved in the database.
     * @param {raw_offer_ingestCreateManyAndReturnArgs} args - Arguments to create many Raw_offer_ingests.
     * @example
     * // Create many Raw_offer_ingests
     * const raw_offer_ingest = await prisma.raw_offer_ingest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Raw_offer_ingests and only return the `time`
     * const raw_offer_ingestWithTimeOnly = await prisma.raw_offer_ingest.createManyAndReturn({
     *   select: { time: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends raw_offer_ingestCreateManyAndReturnArgs>(args?: SelectSubset<T, raw_offer_ingestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$raw_offer_ingestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Raw_offer_ingest.
     * @param {raw_offer_ingestDeleteArgs} args - Arguments to delete one Raw_offer_ingest.
     * @example
     * // Delete one Raw_offer_ingest
     * const Raw_offer_ingest = await prisma.raw_offer_ingest.delete({
     *   where: {
     *     // ... filter to delete one Raw_offer_ingest
     *   }
     * })
     * 
     */
    delete<T extends raw_offer_ingestDeleteArgs>(args: SelectSubset<T, raw_offer_ingestDeleteArgs<ExtArgs>>): Prisma__raw_offer_ingestClient<$Result.GetResult<Prisma.$raw_offer_ingestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Raw_offer_ingest.
     * @param {raw_offer_ingestUpdateArgs} args - Arguments to update one Raw_offer_ingest.
     * @example
     * // Update one Raw_offer_ingest
     * const raw_offer_ingest = await prisma.raw_offer_ingest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends raw_offer_ingestUpdateArgs>(args: SelectSubset<T, raw_offer_ingestUpdateArgs<ExtArgs>>): Prisma__raw_offer_ingestClient<$Result.GetResult<Prisma.$raw_offer_ingestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Raw_offer_ingests.
     * @param {raw_offer_ingestDeleteManyArgs} args - Arguments to filter Raw_offer_ingests to delete.
     * @example
     * // Delete a few Raw_offer_ingests
     * const { count } = await prisma.raw_offer_ingest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends raw_offer_ingestDeleteManyArgs>(args?: SelectSubset<T, raw_offer_ingestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Raw_offer_ingests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {raw_offer_ingestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Raw_offer_ingests
     * const raw_offer_ingest = await prisma.raw_offer_ingest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends raw_offer_ingestUpdateManyArgs>(args: SelectSubset<T, raw_offer_ingestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Raw_offer_ingests and returns the data updated in the database.
     * @param {raw_offer_ingestUpdateManyAndReturnArgs} args - Arguments to update many Raw_offer_ingests.
     * @example
     * // Update many Raw_offer_ingests
     * const raw_offer_ingest = await prisma.raw_offer_ingest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Raw_offer_ingests and only return the `time`
     * const raw_offer_ingestWithTimeOnly = await prisma.raw_offer_ingest.updateManyAndReturn({
     *   select: { time: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends raw_offer_ingestUpdateManyAndReturnArgs>(args: SelectSubset<T, raw_offer_ingestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$raw_offer_ingestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Raw_offer_ingest.
     * @param {raw_offer_ingestUpsertArgs} args - Arguments to update or create a Raw_offer_ingest.
     * @example
     * // Update or create a Raw_offer_ingest
     * const raw_offer_ingest = await prisma.raw_offer_ingest.upsert({
     *   create: {
     *     // ... data to create a Raw_offer_ingest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Raw_offer_ingest we want to update
     *   }
     * })
     */
    upsert<T extends raw_offer_ingestUpsertArgs>(args: SelectSubset<T, raw_offer_ingestUpsertArgs<ExtArgs>>): Prisma__raw_offer_ingestClient<$Result.GetResult<Prisma.$raw_offer_ingestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Raw_offer_ingests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {raw_offer_ingestCountArgs} args - Arguments to filter Raw_offer_ingests to count.
     * @example
     * // Count the number of Raw_offer_ingests
     * const count = await prisma.raw_offer_ingest.count({
     *   where: {
     *     // ... the filter for the Raw_offer_ingests we want to count
     *   }
     * })
    **/
    count<T extends raw_offer_ingestCountArgs>(
      args?: Subset<T, raw_offer_ingestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Raw_offer_ingestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Raw_offer_ingest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Raw_offer_ingestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Raw_offer_ingestAggregateArgs>(args: Subset<T, Raw_offer_ingestAggregateArgs>): Prisma.PrismaPromise<GetRaw_offer_ingestAggregateType<T>>

    /**
     * Group by Raw_offer_ingest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {raw_offer_ingestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends raw_offer_ingestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: raw_offer_ingestGroupByArgs['orderBy'] }
        : { orderBy?: raw_offer_ingestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, raw_offer_ingestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRaw_offer_ingestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the raw_offer_ingest model
   */
  readonly fields: raw_offer_ingestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for raw_offer_ingest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__raw_offer_ingestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the raw_offer_ingest model
   */
  interface raw_offer_ingestFieldRefs {
    readonly time: FieldRef<"raw_offer_ingest", 'DateTime'>
    readonly bucket_5m: FieldRef<"raw_offer_ingest", 'DateTime'>
    readonly group_id: FieldRef<"raw_offer_ingest", 'String'>
    readonly item_url: FieldRef<"raw_offer_ingest", 'String'>
    readonly item_type: FieldRef<"raw_offer_ingest", 'String'>
    readonly retailer_name: FieldRef<"raw_offer_ingest", 'String'>
    readonly offer_url: FieldRef<"raw_offer_ingest", 'String'>
    readonly price: FieldRef<"raw_offer_ingest", 'Float'>
    readonly shipping_text: FieldRef<"raw_offer_ingest", 'String'>
    readonly shipping_cost: FieldRef<"raw_offer_ingest", 'Float'>
    readonly total: FieldRef<"raw_offer_ingest", 'Float'>
    readonly in_stock: FieldRef<"raw_offer_ingest", 'Boolean'>
    readonly source: FieldRef<"raw_offer_ingest", 'String'>
    readonly offer_fingerprint: FieldRef<"raw_offer_ingest", 'String'>
  }
    

  // Custom InputTypes
  /**
   * raw_offer_ingest findUnique
   */
  export type raw_offer_ingestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the raw_offer_ingest
     */
    select?: raw_offer_ingestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the raw_offer_ingest
     */
    omit?: raw_offer_ingestOmit<ExtArgs> | null
    /**
     * Filter, which raw_offer_ingest to fetch.
     */
    where: raw_offer_ingestWhereUniqueInput
  }

  /**
   * raw_offer_ingest findUniqueOrThrow
   */
  export type raw_offer_ingestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the raw_offer_ingest
     */
    select?: raw_offer_ingestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the raw_offer_ingest
     */
    omit?: raw_offer_ingestOmit<ExtArgs> | null
    /**
     * Filter, which raw_offer_ingest to fetch.
     */
    where: raw_offer_ingestWhereUniqueInput
  }

  /**
   * raw_offer_ingest findFirst
   */
  export type raw_offer_ingestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the raw_offer_ingest
     */
    select?: raw_offer_ingestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the raw_offer_ingest
     */
    omit?: raw_offer_ingestOmit<ExtArgs> | null
    /**
     * Filter, which raw_offer_ingest to fetch.
     */
    where?: raw_offer_ingestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of raw_offer_ingests to fetch.
     */
    orderBy?: raw_offer_ingestOrderByWithRelationInput | raw_offer_ingestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for raw_offer_ingests.
     */
    cursor?: raw_offer_ingestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` raw_offer_ingests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` raw_offer_ingests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of raw_offer_ingests.
     */
    distinct?: Raw_offer_ingestScalarFieldEnum | Raw_offer_ingestScalarFieldEnum[]
  }

  /**
   * raw_offer_ingest findFirstOrThrow
   */
  export type raw_offer_ingestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the raw_offer_ingest
     */
    select?: raw_offer_ingestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the raw_offer_ingest
     */
    omit?: raw_offer_ingestOmit<ExtArgs> | null
    /**
     * Filter, which raw_offer_ingest to fetch.
     */
    where?: raw_offer_ingestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of raw_offer_ingests to fetch.
     */
    orderBy?: raw_offer_ingestOrderByWithRelationInput | raw_offer_ingestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for raw_offer_ingests.
     */
    cursor?: raw_offer_ingestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` raw_offer_ingests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` raw_offer_ingests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of raw_offer_ingests.
     */
    distinct?: Raw_offer_ingestScalarFieldEnum | Raw_offer_ingestScalarFieldEnum[]
  }

  /**
   * raw_offer_ingest findMany
   */
  export type raw_offer_ingestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the raw_offer_ingest
     */
    select?: raw_offer_ingestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the raw_offer_ingest
     */
    omit?: raw_offer_ingestOmit<ExtArgs> | null
    /**
     * Filter, which raw_offer_ingests to fetch.
     */
    where?: raw_offer_ingestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of raw_offer_ingests to fetch.
     */
    orderBy?: raw_offer_ingestOrderByWithRelationInput | raw_offer_ingestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing raw_offer_ingests.
     */
    cursor?: raw_offer_ingestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` raw_offer_ingests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` raw_offer_ingests.
     */
    skip?: number
    distinct?: Raw_offer_ingestScalarFieldEnum | Raw_offer_ingestScalarFieldEnum[]
  }

  /**
   * raw_offer_ingest create
   */
  export type raw_offer_ingestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the raw_offer_ingest
     */
    select?: raw_offer_ingestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the raw_offer_ingest
     */
    omit?: raw_offer_ingestOmit<ExtArgs> | null
    /**
     * The data needed to create a raw_offer_ingest.
     */
    data: XOR<raw_offer_ingestCreateInput, raw_offer_ingestUncheckedCreateInput>
  }

  /**
   * raw_offer_ingest createMany
   */
  export type raw_offer_ingestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many raw_offer_ingests.
     */
    data: raw_offer_ingestCreateManyInput | raw_offer_ingestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * raw_offer_ingest createManyAndReturn
   */
  export type raw_offer_ingestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the raw_offer_ingest
     */
    select?: raw_offer_ingestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the raw_offer_ingest
     */
    omit?: raw_offer_ingestOmit<ExtArgs> | null
    /**
     * The data used to create many raw_offer_ingests.
     */
    data: raw_offer_ingestCreateManyInput | raw_offer_ingestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * raw_offer_ingest update
   */
  export type raw_offer_ingestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the raw_offer_ingest
     */
    select?: raw_offer_ingestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the raw_offer_ingest
     */
    omit?: raw_offer_ingestOmit<ExtArgs> | null
    /**
     * The data needed to update a raw_offer_ingest.
     */
    data: XOR<raw_offer_ingestUpdateInput, raw_offer_ingestUncheckedUpdateInput>
    /**
     * Choose, which raw_offer_ingest to update.
     */
    where: raw_offer_ingestWhereUniqueInput
  }

  /**
   * raw_offer_ingest updateMany
   */
  export type raw_offer_ingestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update raw_offer_ingests.
     */
    data: XOR<raw_offer_ingestUpdateManyMutationInput, raw_offer_ingestUncheckedUpdateManyInput>
    /**
     * Filter which raw_offer_ingests to update
     */
    where?: raw_offer_ingestWhereInput
    /**
     * Limit how many raw_offer_ingests to update.
     */
    limit?: number
  }

  /**
   * raw_offer_ingest updateManyAndReturn
   */
  export type raw_offer_ingestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the raw_offer_ingest
     */
    select?: raw_offer_ingestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the raw_offer_ingest
     */
    omit?: raw_offer_ingestOmit<ExtArgs> | null
    /**
     * The data used to update raw_offer_ingests.
     */
    data: XOR<raw_offer_ingestUpdateManyMutationInput, raw_offer_ingestUncheckedUpdateManyInput>
    /**
     * Filter which raw_offer_ingests to update
     */
    where?: raw_offer_ingestWhereInput
    /**
     * Limit how many raw_offer_ingests to update.
     */
    limit?: number
  }

  /**
   * raw_offer_ingest upsert
   */
  export type raw_offer_ingestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the raw_offer_ingest
     */
    select?: raw_offer_ingestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the raw_offer_ingest
     */
    omit?: raw_offer_ingestOmit<ExtArgs> | null
    /**
     * The filter to search for the raw_offer_ingest to update in case it exists.
     */
    where: raw_offer_ingestWhereUniqueInput
    /**
     * In case the raw_offer_ingest found by the `where` argument doesn't exist, create a new raw_offer_ingest with this data.
     */
    create: XOR<raw_offer_ingestCreateInput, raw_offer_ingestUncheckedCreateInput>
    /**
     * In case the raw_offer_ingest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<raw_offer_ingestUpdateInput, raw_offer_ingestUncheckedUpdateInput>
  }

  /**
   * raw_offer_ingest delete
   */
  export type raw_offer_ingestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the raw_offer_ingest
     */
    select?: raw_offer_ingestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the raw_offer_ingest
     */
    omit?: raw_offer_ingestOmit<ExtArgs> | null
    /**
     * Filter which raw_offer_ingest to delete.
     */
    where: raw_offer_ingestWhereUniqueInput
  }

  /**
   * raw_offer_ingest deleteMany
   */
  export type raw_offer_ingestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which raw_offer_ingests to delete
     */
    where?: raw_offer_ingestWhereInput
    /**
     * Limit how many raw_offer_ingests to delete.
     */
    limit?: number
  }

  /**
   * raw_offer_ingest without action
   */
  export type raw_offer_ingestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the raw_offer_ingest
     */
    select?: raw_offer_ingestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the raw_offer_ingest
     */
    omit?: raw_offer_ingestOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const BrandScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    website: 'website',
    logo: 'logo',
    description: 'description'
  };

  export type BrandScalarFieldEnum = (typeof BrandScalarFieldEnum)[keyof typeof BrandScalarFieldEnum]


  export const CaliberScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    type: 'type'
  };

  export type CaliberScalarFieldEnum = (typeof CaliberScalarFieldEnum)[keyof typeof CaliberScalarFieldEnum]


  export const OfferScalarFieldEnum: {
    id: 'id',
    itemId: 'itemId',
    retailerId: 'retailerId',
    url: 'url',
    inStock: 'inStock',
    price: 'price',
    currency: 'currency',
    shippingCost: 'shippingCost',
    total: 'total',
    freeShipping: 'freeShipping',
    shippingNote: 'shippingNote',
    shippingUpdatedAt: 'shippingUpdatedAt',
    unitsCount: 'unitsCount',
    unitLabel: 'unitLabel',
    unitPrice: 'unitPrice',
    totalUnitPrice: 'totalUnitPrice',
    retailerSku: 'retailerSku',
    isManuallyOOS: 'isManuallyOOS',
    oosReportCount: 'oosReportCount',
    lastStockChange: 'lastStockChange',
    lastSeen: 'lastSeen'
  };

  export type OfferScalarFieldEnum = (typeof OfferScalarFieldEnum)[keyof typeof OfferScalarFieldEnum]


  export const RetailerScalarFieldEnum: {
    id: 'id',
    name: 'name',
    domain: 'domain',
    logo: 'logo',
    rating: 'rating',
    shippingRating: 'shippingRating'
  };

  export type RetailerScalarFieldEnum = (typeof RetailerScalarFieldEnum)[keyof typeof RetailerScalarFieldEnum]


  export const AccessoryFitmentScalarFieldEnum: {
    id: 'id',
    accessorySpecsId: 'accessorySpecsId',
    fitmentType: 'fitmentType',
    firearmItemId: 'firearmItemId',
    platform: 'platform',
    note: 'note'
  };

  export type AccessoryFitmentScalarFieldEnum = (typeof AccessoryFitmentScalarFieldEnum)[keyof typeof AccessoryFitmentScalarFieldEnum]


  export const AccessorySpecsScalarFieldEnum: {
    id: 'id',
    itemId: 'itemId',
    accessoryTypeId: 'accessoryTypeId',
    material: 'material',
    color: 'color',
    notes: 'notes'
  };

  export type AccessorySpecsScalarFieldEnum = (typeof AccessorySpecsScalarFieldEnum)[keyof typeof AccessorySpecsScalarFieldEnum]


  export const AccessoryTypeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug'
  };

  export type AccessoryTypeScalarFieldEnum = (typeof AccessoryTypeScalarFieldEnum)[keyof typeof AccessoryTypeScalarFieldEnum]


  export const AlertScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    calId: 'calId',
    itemId: 'itemId',
    keyword: 'keyword',
    targetCpr: 'targetCpr',
    excludeSteel: 'excludeSteel',
    excludeReman: 'excludeReman',
    lastTriggered: 'lastTriggered',
    isActive: 'isActive',
    createdAt: 'createdAt'
  };

  export type AlertScalarFieldEnum = (typeof AlertScalarFieldEnum)[keyof typeof AlertScalarFieldEnum]


  export const AlertDeliveryScalarFieldEnum: {
    id: 'id',
    alertId: 'alertId',
    offerId: 'offerId',
    sentAt: 'sentAt',
    fingerprint: 'fingerprint',
    userId: 'userId'
  };

  export type AlertDeliveryScalarFieldEnum = (typeof AlertDeliveryScalarFieldEnum)[keyof typeof AlertDeliveryScalarFieldEnum]


  export const AmmoSpecsScalarFieldEnum: {
    id: 'id',
    itemId: 'itemId',
    caliberId: 'caliberId',
    grain: 'grain',
    gauge: 'gauge',
    velocity: 'velocity',
    energy: 'energy',
    casing: 'casing',
    bulletType: 'bulletType',
    restrictions: 'restrictions',
    pressure: 'pressure',
    isSteelCase: 'isSteelCase',
    isRemanufactured: 'isRemanufactured',
    isSubsonic: 'isSubsonic'
  };

  export type AmmoSpecsScalarFieldEnum = (typeof AmmoSpecsScalarFieldEnum)[keyof typeof AmmoSpecsScalarFieldEnum]


  export const BlockedRetailerScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    retailerId: 'retailerId',
    createdAt: 'createdAt'
  };

  export type BlockedRetailerScalarFieldEnum = (typeof BlockedRetailerScalarFieldEnum)[keyof typeof BlockedRetailerScalarFieldEnum]


  export const CaliberAliasScalarFieldEnum: {
    id: 'id',
    caliberId: 'caliberId',
    alias: 'alias'
  };

  export type CaliberAliasScalarFieldEnum = (typeof CaliberAliasScalarFieldEnum)[keyof typeof CaliberAliasScalarFieldEnum]


  export const CatalogItemScalarFieldEnum: {
    id: 'id',
    kind: 'kind',
    slug: 'slug',
    upc: 'upc',
    mpn: 'mpn',
    title: 'title',
    image: 'image',
    description: 'description',
    brandId: 'brandId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    bestPrice: 'bestPrice',
    bestRetailerId: 'bestRetailerId',
    bestRetailerName: 'bestRetailerName',
    offerCount: 'offerCount',
    bestCpr: 'bestCpr',
    bestCprShipped: 'bestCprShipped',
    upvotes: 'upvotes',
    downvotes: 'downvotes'
  };

  export type CatalogItemScalarFieldEnum = (typeof CatalogItemScalarFieldEnum)[keyof typeof CatalogItemScalarFieldEnum]


  export const FirearmCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug'
  };

  export type FirearmCategoryScalarFieldEnum = (typeof FirearmCategoryScalarFieldEnum)[keyof typeof FirearmCategoryScalarFieldEnum]


  export const FirearmChamberScalarFieldEnum: {
    firearmSpecsId: 'firearmSpecsId',
    caliberId: 'caliberId',
    note: 'note'
  };

  export type FirearmChamberScalarFieldEnum = (typeof FirearmChamberScalarFieldEnum)[keyof typeof FirearmChamberScalarFieldEnum]


  export const FirearmSpecsScalarFieldEnum: {
    id: 'id',
    itemId: 'itemId',
    manufacturer: 'manufacturer',
    model: 'model',
    platform: 'platform',
    firearmCategoryId: 'firearmCategoryId',
    barrelLengthIn: 'barrelLengthIn',
    actionType: 'actionType',
    isThreaded: 'isThreaded',
    pressureRating: 'pressureRating',
    firearmType: 'firearmType',
    capacity: 'capacity',
    finish: 'finish',
    weight: 'weight',
    overallLength: 'overallLength',
    features: 'features',
    sight: 'sight',
    safety: 'safety'
  };

  export type FirearmSpecsScalarFieldEnum = (typeof FirearmSpecsScalarFieldEnum)[keyof typeof FirearmSpecsScalarFieldEnum]


  export const OwnedFirearmScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    firearmItemId: 'firearmItemId',
    nickname: 'nickname',
    createdAt: 'createdAt'
  };

  export type OwnedFirearmScalarFieldEnum = (typeof OwnedFirearmScalarFieldEnum)[keyof typeof OwnedFirearmScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    emailVerified: 'emailVerified',
    image: 'image',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const Raw_offer_ingestScalarFieldEnum: {
    time: 'time',
    bucket_5m: 'bucket_5m',
    group_id: 'group_id',
    item_url: 'item_url',
    item_type: 'item_type',
    retailer_name: 'retailer_name',
    offer_url: 'offer_url',
    price: 'price',
    shipping_text: 'shipping_text',
    shipping_cost: 'shipping_cost',
    total: 'total',
    in_stock: 'in_stock',
    source: 'source',
    offer_fingerprint: 'offer_fingerprint'
  };

  export type Raw_offer_ingestScalarFieldEnum = (typeof Raw_offer_ingestScalarFieldEnum)[keyof typeof Raw_offer_ingestScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'FitmentType'
   */
  export type EnumFitmentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FitmentType'>
    


  /**
   * Reference to a field of type 'FitmentType[]'
   */
  export type ListEnumFitmentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FitmentType[]'>
    


  /**
   * Reference to a field of type 'AlertType'
   */
  export type EnumAlertTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AlertType'>
    


  /**
   * Reference to a field of type 'AlertType[]'
   */
  export type ListEnumAlertTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AlertType[]'>
    


  /**
   * Reference to a field of type 'AmmoPressure'
   */
  export type EnumAmmoPressureFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AmmoPressure'>
    


  /**
   * Reference to a field of type 'AmmoPressure[]'
   */
  export type ListEnumAmmoPressureFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AmmoPressure[]'>
    


  /**
   * Reference to a field of type 'CatalogKind'
   */
  export type EnumCatalogKindFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CatalogKind'>
    


  /**
   * Reference to a field of type 'CatalogKind[]'
   */
  export type ListEnumCatalogKindFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CatalogKind[]'>
    


  /**
   * Reference to a field of type 'FirearmPressureRating'
   */
  export type EnumFirearmPressureRatingFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FirearmPressureRating'>
    


  /**
   * Reference to a field of type 'FirearmPressureRating[]'
   */
  export type ListEnumFirearmPressureRatingFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FirearmPressureRating[]'>
    
  /**
   * Deep Input Types
   */


  export type BrandWhereInput = {
    AND?: BrandWhereInput | BrandWhereInput[]
    OR?: BrandWhereInput[]
    NOT?: BrandWhereInput | BrandWhereInput[]
    id?: IntFilter<"Brand"> | number
    name?: StringFilter<"Brand"> | string
    slug?: StringFilter<"Brand"> | string
    website?: StringNullableFilter<"Brand"> | string | null
    logo?: StringNullableFilter<"Brand"> | string | null
    description?: StringNullableFilter<"Brand"> | string | null
    CatalogItem?: CatalogItemListRelationFilter
  }

  export type BrandOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    website?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    CatalogItem?: CatalogItemOrderByRelationAggregateInput
  }

  export type BrandWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    slug?: string
    AND?: BrandWhereInput | BrandWhereInput[]
    OR?: BrandWhereInput[]
    NOT?: BrandWhereInput | BrandWhereInput[]
    website?: StringNullableFilter<"Brand"> | string | null
    logo?: StringNullableFilter<"Brand"> | string | null
    description?: StringNullableFilter<"Brand"> | string | null
    CatalogItem?: CatalogItemListRelationFilter
  }, "id" | "name" | "slug">

  export type BrandOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    website?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    _count?: BrandCountOrderByAggregateInput
    _avg?: BrandAvgOrderByAggregateInput
    _max?: BrandMaxOrderByAggregateInput
    _min?: BrandMinOrderByAggregateInput
    _sum?: BrandSumOrderByAggregateInput
  }

  export type BrandScalarWhereWithAggregatesInput = {
    AND?: BrandScalarWhereWithAggregatesInput | BrandScalarWhereWithAggregatesInput[]
    OR?: BrandScalarWhereWithAggregatesInput[]
    NOT?: BrandScalarWhereWithAggregatesInput | BrandScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Brand"> | number
    name?: StringWithAggregatesFilter<"Brand"> | string
    slug?: StringWithAggregatesFilter<"Brand"> | string
    website?: StringNullableWithAggregatesFilter<"Brand"> | string | null
    logo?: StringNullableWithAggregatesFilter<"Brand"> | string | null
    description?: StringNullableWithAggregatesFilter<"Brand"> | string | null
  }

  export type CaliberWhereInput = {
    AND?: CaliberWhereInput | CaliberWhereInput[]
    OR?: CaliberWhereInput[]
    NOT?: CaliberWhereInput | CaliberWhereInput[]
    id?: IntFilter<"Caliber"> | number
    name?: StringFilter<"Caliber"> | string
    slug?: StringFilter<"Caliber"> | string
    type?: StringNullableFilter<"Caliber"> | string | null
    Alert?: AlertListRelationFilter
    AmmoSpecs?: AmmoSpecsListRelationFilter
    CaliberAlias?: CaliberAliasListRelationFilter
    FirearmChamber?: FirearmChamberListRelationFilter
  }

  export type CaliberOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    type?: SortOrderInput | SortOrder
    Alert?: AlertOrderByRelationAggregateInput
    AmmoSpecs?: AmmoSpecsOrderByRelationAggregateInput
    CaliberAlias?: CaliberAliasOrderByRelationAggregateInput
    FirearmChamber?: FirearmChamberOrderByRelationAggregateInput
  }

  export type CaliberWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    slug?: string
    AND?: CaliberWhereInput | CaliberWhereInput[]
    OR?: CaliberWhereInput[]
    NOT?: CaliberWhereInput | CaliberWhereInput[]
    name?: StringFilter<"Caliber"> | string
    type?: StringNullableFilter<"Caliber"> | string | null
    Alert?: AlertListRelationFilter
    AmmoSpecs?: AmmoSpecsListRelationFilter
    CaliberAlias?: CaliberAliasListRelationFilter
    FirearmChamber?: FirearmChamberListRelationFilter
  }, "id" | "slug">

  export type CaliberOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    type?: SortOrderInput | SortOrder
    _count?: CaliberCountOrderByAggregateInput
    _avg?: CaliberAvgOrderByAggregateInput
    _max?: CaliberMaxOrderByAggregateInput
    _min?: CaliberMinOrderByAggregateInput
    _sum?: CaliberSumOrderByAggregateInput
  }

  export type CaliberScalarWhereWithAggregatesInput = {
    AND?: CaliberScalarWhereWithAggregatesInput | CaliberScalarWhereWithAggregatesInput[]
    OR?: CaliberScalarWhereWithAggregatesInput[]
    NOT?: CaliberScalarWhereWithAggregatesInput | CaliberScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Caliber"> | number
    name?: StringWithAggregatesFilter<"Caliber"> | string
    slug?: StringWithAggregatesFilter<"Caliber"> | string
    type?: StringNullableWithAggregatesFilter<"Caliber"> | string | null
  }

  export type OfferWhereInput = {
    AND?: OfferWhereInput | OfferWhereInput[]
    OR?: OfferWhereInput[]
    NOT?: OfferWhereInput | OfferWhereInput[]
    id?: IntFilter<"Offer"> | number
    itemId?: StringFilter<"Offer"> | string
    retailerId?: IntFilter<"Offer"> | number
    url?: StringFilter<"Offer"> | string
    inStock?: BoolNullableFilter<"Offer"> | boolean | null
    price?: FloatFilter<"Offer"> | number
    currency?: StringNullableFilter<"Offer"> | string | null
    shippingCost?: FloatNullableFilter<"Offer"> | number | null
    total?: FloatNullableFilter<"Offer"> | number | null
    freeShipping?: BoolNullableFilter<"Offer"> | boolean | null
    shippingNote?: StringNullableFilter<"Offer"> | string | null
    shippingUpdatedAt?: DateTimeNullableFilter<"Offer"> | Date | string | null
    unitsCount?: IntNullableFilter<"Offer"> | number | null
    unitLabel?: StringNullableFilter<"Offer"> | string | null
    unitPrice?: FloatNullableFilter<"Offer"> | number | null
    totalUnitPrice?: FloatNullableFilter<"Offer"> | number | null
    retailerSku?: StringNullableFilter<"Offer"> | string | null
    isManuallyOOS?: BoolNullableFilter<"Offer"> | boolean | null
    oosReportCount?: IntNullableFilter<"Offer"> | number | null
    lastStockChange?: DateTimeNullableFilter<"Offer"> | Date | string | null
    lastSeen?: DateTimeNullableFilter<"Offer"> | Date | string | null
    AlertDelivery?: AlertDeliveryListRelationFilter
    CatalogItem?: XOR<CatalogItemScalarRelationFilter, CatalogItemWhereInput>
    retailer?: XOR<RetailerScalarRelationFilter, RetailerWhereInput>
  }

  export type OfferOrderByWithRelationInput = {
    id?: SortOrder
    itemId?: SortOrder
    retailerId?: SortOrder
    url?: SortOrder
    inStock?: SortOrderInput | SortOrder
    price?: SortOrder
    currency?: SortOrderInput | SortOrder
    shippingCost?: SortOrderInput | SortOrder
    total?: SortOrderInput | SortOrder
    freeShipping?: SortOrderInput | SortOrder
    shippingNote?: SortOrderInput | SortOrder
    shippingUpdatedAt?: SortOrderInput | SortOrder
    unitsCount?: SortOrderInput | SortOrder
    unitLabel?: SortOrderInput | SortOrder
    unitPrice?: SortOrderInput | SortOrder
    totalUnitPrice?: SortOrderInput | SortOrder
    retailerSku?: SortOrderInput | SortOrder
    isManuallyOOS?: SortOrderInput | SortOrder
    oosReportCount?: SortOrderInput | SortOrder
    lastStockChange?: SortOrderInput | SortOrder
    lastSeen?: SortOrderInput | SortOrder
    AlertDelivery?: AlertDeliveryOrderByRelationAggregateInput
    CatalogItem?: CatalogItemOrderByWithRelationInput
    retailer?: RetailerOrderByWithRelationInput
  }

  export type OfferWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    itemId_retailerId_unitsCount_currency?: OfferItemIdRetailerIdUnitsCountCurrencyCompoundUniqueInput
    AND?: OfferWhereInput | OfferWhereInput[]
    OR?: OfferWhereInput[]
    NOT?: OfferWhereInput | OfferWhereInput[]
    itemId?: StringFilter<"Offer"> | string
    retailerId?: IntFilter<"Offer"> | number
    url?: StringFilter<"Offer"> | string
    inStock?: BoolNullableFilter<"Offer"> | boolean | null
    price?: FloatFilter<"Offer"> | number
    currency?: StringNullableFilter<"Offer"> | string | null
    shippingCost?: FloatNullableFilter<"Offer"> | number | null
    total?: FloatNullableFilter<"Offer"> | number | null
    freeShipping?: BoolNullableFilter<"Offer"> | boolean | null
    shippingNote?: StringNullableFilter<"Offer"> | string | null
    shippingUpdatedAt?: DateTimeNullableFilter<"Offer"> | Date | string | null
    unitsCount?: IntNullableFilter<"Offer"> | number | null
    unitLabel?: StringNullableFilter<"Offer"> | string | null
    unitPrice?: FloatNullableFilter<"Offer"> | number | null
    totalUnitPrice?: FloatNullableFilter<"Offer"> | number | null
    retailerSku?: StringNullableFilter<"Offer"> | string | null
    isManuallyOOS?: BoolNullableFilter<"Offer"> | boolean | null
    oosReportCount?: IntNullableFilter<"Offer"> | number | null
    lastStockChange?: DateTimeNullableFilter<"Offer"> | Date | string | null
    lastSeen?: DateTimeNullableFilter<"Offer"> | Date | string | null
    AlertDelivery?: AlertDeliveryListRelationFilter
    CatalogItem?: XOR<CatalogItemScalarRelationFilter, CatalogItemWhereInput>
    retailer?: XOR<RetailerScalarRelationFilter, RetailerWhereInput>
  }, "id" | "itemId_retailerId_unitsCount_currency">

  export type OfferOrderByWithAggregationInput = {
    id?: SortOrder
    itemId?: SortOrder
    retailerId?: SortOrder
    url?: SortOrder
    inStock?: SortOrderInput | SortOrder
    price?: SortOrder
    currency?: SortOrderInput | SortOrder
    shippingCost?: SortOrderInput | SortOrder
    total?: SortOrderInput | SortOrder
    freeShipping?: SortOrderInput | SortOrder
    shippingNote?: SortOrderInput | SortOrder
    shippingUpdatedAt?: SortOrderInput | SortOrder
    unitsCount?: SortOrderInput | SortOrder
    unitLabel?: SortOrderInput | SortOrder
    unitPrice?: SortOrderInput | SortOrder
    totalUnitPrice?: SortOrderInput | SortOrder
    retailerSku?: SortOrderInput | SortOrder
    isManuallyOOS?: SortOrderInput | SortOrder
    oosReportCount?: SortOrderInput | SortOrder
    lastStockChange?: SortOrderInput | SortOrder
    lastSeen?: SortOrderInput | SortOrder
    _count?: OfferCountOrderByAggregateInput
    _avg?: OfferAvgOrderByAggregateInput
    _max?: OfferMaxOrderByAggregateInput
    _min?: OfferMinOrderByAggregateInput
    _sum?: OfferSumOrderByAggregateInput
  }

  export type OfferScalarWhereWithAggregatesInput = {
    AND?: OfferScalarWhereWithAggregatesInput | OfferScalarWhereWithAggregatesInput[]
    OR?: OfferScalarWhereWithAggregatesInput[]
    NOT?: OfferScalarWhereWithAggregatesInput | OfferScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Offer"> | number
    itemId?: StringWithAggregatesFilter<"Offer"> | string
    retailerId?: IntWithAggregatesFilter<"Offer"> | number
    url?: StringWithAggregatesFilter<"Offer"> | string
    inStock?: BoolNullableWithAggregatesFilter<"Offer"> | boolean | null
    price?: FloatWithAggregatesFilter<"Offer"> | number
    currency?: StringNullableWithAggregatesFilter<"Offer"> | string | null
    shippingCost?: FloatNullableWithAggregatesFilter<"Offer"> | number | null
    total?: FloatNullableWithAggregatesFilter<"Offer"> | number | null
    freeShipping?: BoolNullableWithAggregatesFilter<"Offer"> | boolean | null
    shippingNote?: StringNullableWithAggregatesFilter<"Offer"> | string | null
    shippingUpdatedAt?: DateTimeNullableWithAggregatesFilter<"Offer"> | Date | string | null
    unitsCount?: IntNullableWithAggregatesFilter<"Offer"> | number | null
    unitLabel?: StringNullableWithAggregatesFilter<"Offer"> | string | null
    unitPrice?: FloatNullableWithAggregatesFilter<"Offer"> | number | null
    totalUnitPrice?: FloatNullableWithAggregatesFilter<"Offer"> | number | null
    retailerSku?: StringNullableWithAggregatesFilter<"Offer"> | string | null
    isManuallyOOS?: BoolNullableWithAggregatesFilter<"Offer"> | boolean | null
    oosReportCount?: IntNullableWithAggregatesFilter<"Offer"> | number | null
    lastStockChange?: DateTimeNullableWithAggregatesFilter<"Offer"> | Date | string | null
    lastSeen?: DateTimeNullableWithAggregatesFilter<"Offer"> | Date | string | null
  }

  export type RetailerWhereInput = {
    AND?: RetailerWhereInput | RetailerWhereInput[]
    OR?: RetailerWhereInput[]
    NOT?: RetailerWhereInput | RetailerWhereInput[]
    id?: IntFilter<"Retailer"> | number
    name?: StringFilter<"Retailer"> | string
    domain?: StringNullableFilter<"Retailer"> | string | null
    logo?: StringNullableFilter<"Retailer"> | string | null
    rating?: FloatNullableFilter<"Retailer"> | number | null
    shippingRating?: IntNullableFilter<"Retailer"> | number | null
    BlockedRetailer?: BlockedRetailerListRelationFilter
    offers?: OfferListRelationFilter
  }

  export type RetailerOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    domain?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    rating?: SortOrderInput | SortOrder
    shippingRating?: SortOrderInput | SortOrder
    BlockedRetailer?: BlockedRetailerOrderByRelationAggregateInput
    offers?: OfferOrderByRelationAggregateInput
  }

  export type RetailerWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    domain?: string
    AND?: RetailerWhereInput | RetailerWhereInput[]
    OR?: RetailerWhereInput[]
    NOT?: RetailerWhereInput | RetailerWhereInput[]
    logo?: StringNullableFilter<"Retailer"> | string | null
    rating?: FloatNullableFilter<"Retailer"> | number | null
    shippingRating?: IntNullableFilter<"Retailer"> | number | null
    BlockedRetailer?: BlockedRetailerListRelationFilter
    offers?: OfferListRelationFilter
  }, "id" | "name" | "domain">

  export type RetailerOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    domain?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    rating?: SortOrderInput | SortOrder
    shippingRating?: SortOrderInput | SortOrder
    _count?: RetailerCountOrderByAggregateInput
    _avg?: RetailerAvgOrderByAggregateInput
    _max?: RetailerMaxOrderByAggregateInput
    _min?: RetailerMinOrderByAggregateInput
    _sum?: RetailerSumOrderByAggregateInput
  }

  export type RetailerScalarWhereWithAggregatesInput = {
    AND?: RetailerScalarWhereWithAggregatesInput | RetailerScalarWhereWithAggregatesInput[]
    OR?: RetailerScalarWhereWithAggregatesInput[]
    NOT?: RetailerScalarWhereWithAggregatesInput | RetailerScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Retailer"> | number
    name?: StringWithAggregatesFilter<"Retailer"> | string
    domain?: StringNullableWithAggregatesFilter<"Retailer"> | string | null
    logo?: StringNullableWithAggregatesFilter<"Retailer"> | string | null
    rating?: FloatNullableWithAggregatesFilter<"Retailer"> | number | null
    shippingRating?: IntNullableWithAggregatesFilter<"Retailer"> | number | null
  }

  export type AccessoryFitmentWhereInput = {
    AND?: AccessoryFitmentWhereInput | AccessoryFitmentWhereInput[]
    OR?: AccessoryFitmentWhereInput[]
    NOT?: AccessoryFitmentWhereInput | AccessoryFitmentWhereInput[]
    id?: IntFilter<"AccessoryFitment"> | number
    accessorySpecsId?: IntFilter<"AccessoryFitment"> | number
    fitmentType?: EnumFitmentTypeFilter<"AccessoryFitment"> | $Enums.FitmentType
    firearmItemId?: StringNullableFilter<"AccessoryFitment"> | string | null
    platform?: StringNullableFilter<"AccessoryFitment"> | string | null
    note?: StringNullableFilter<"AccessoryFitment"> | string | null
    AccessorySpecs?: XOR<AccessorySpecsScalarRelationFilter, AccessorySpecsWhereInput>
    CatalogItem?: XOR<CatalogItemNullableScalarRelationFilter, CatalogItemWhereInput> | null
  }

  export type AccessoryFitmentOrderByWithRelationInput = {
    id?: SortOrder
    accessorySpecsId?: SortOrder
    fitmentType?: SortOrder
    firearmItemId?: SortOrderInput | SortOrder
    platform?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    AccessorySpecs?: AccessorySpecsOrderByWithRelationInput
    CatalogItem?: CatalogItemOrderByWithRelationInput
  }

  export type AccessoryFitmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AccessoryFitmentWhereInput | AccessoryFitmentWhereInput[]
    OR?: AccessoryFitmentWhereInput[]
    NOT?: AccessoryFitmentWhereInput | AccessoryFitmentWhereInput[]
    accessorySpecsId?: IntFilter<"AccessoryFitment"> | number
    fitmentType?: EnumFitmentTypeFilter<"AccessoryFitment"> | $Enums.FitmentType
    firearmItemId?: StringNullableFilter<"AccessoryFitment"> | string | null
    platform?: StringNullableFilter<"AccessoryFitment"> | string | null
    note?: StringNullableFilter<"AccessoryFitment"> | string | null
    AccessorySpecs?: XOR<AccessorySpecsScalarRelationFilter, AccessorySpecsWhereInput>
    CatalogItem?: XOR<CatalogItemNullableScalarRelationFilter, CatalogItemWhereInput> | null
  }, "id">

  export type AccessoryFitmentOrderByWithAggregationInput = {
    id?: SortOrder
    accessorySpecsId?: SortOrder
    fitmentType?: SortOrder
    firearmItemId?: SortOrderInput | SortOrder
    platform?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    _count?: AccessoryFitmentCountOrderByAggregateInput
    _avg?: AccessoryFitmentAvgOrderByAggregateInput
    _max?: AccessoryFitmentMaxOrderByAggregateInput
    _min?: AccessoryFitmentMinOrderByAggregateInput
    _sum?: AccessoryFitmentSumOrderByAggregateInput
  }

  export type AccessoryFitmentScalarWhereWithAggregatesInput = {
    AND?: AccessoryFitmentScalarWhereWithAggregatesInput | AccessoryFitmentScalarWhereWithAggregatesInput[]
    OR?: AccessoryFitmentScalarWhereWithAggregatesInput[]
    NOT?: AccessoryFitmentScalarWhereWithAggregatesInput | AccessoryFitmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AccessoryFitment"> | number
    accessorySpecsId?: IntWithAggregatesFilter<"AccessoryFitment"> | number
    fitmentType?: EnumFitmentTypeWithAggregatesFilter<"AccessoryFitment"> | $Enums.FitmentType
    firearmItemId?: StringNullableWithAggregatesFilter<"AccessoryFitment"> | string | null
    platform?: StringNullableWithAggregatesFilter<"AccessoryFitment"> | string | null
    note?: StringNullableWithAggregatesFilter<"AccessoryFitment"> | string | null
  }

  export type AccessorySpecsWhereInput = {
    AND?: AccessorySpecsWhereInput | AccessorySpecsWhereInput[]
    OR?: AccessorySpecsWhereInput[]
    NOT?: AccessorySpecsWhereInput | AccessorySpecsWhereInput[]
    id?: IntFilter<"AccessorySpecs"> | number
    itemId?: StringFilter<"AccessorySpecs"> | string
    accessoryTypeId?: IntNullableFilter<"AccessorySpecs"> | number | null
    material?: StringNullableFilter<"AccessorySpecs"> | string | null
    color?: StringNullableFilter<"AccessorySpecs"> | string | null
    notes?: StringNullableFilter<"AccessorySpecs"> | string | null
    AccessoryFitment?: AccessoryFitmentListRelationFilter
    AccessoryType?: XOR<AccessoryTypeNullableScalarRelationFilter, AccessoryTypeWhereInput> | null
    CatalogItem?: XOR<CatalogItemScalarRelationFilter, CatalogItemWhereInput>
  }

  export type AccessorySpecsOrderByWithRelationInput = {
    id?: SortOrder
    itemId?: SortOrder
    accessoryTypeId?: SortOrderInput | SortOrder
    material?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    AccessoryFitment?: AccessoryFitmentOrderByRelationAggregateInput
    AccessoryType?: AccessoryTypeOrderByWithRelationInput
    CatalogItem?: CatalogItemOrderByWithRelationInput
  }

  export type AccessorySpecsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    itemId?: string
    AND?: AccessorySpecsWhereInput | AccessorySpecsWhereInput[]
    OR?: AccessorySpecsWhereInput[]
    NOT?: AccessorySpecsWhereInput | AccessorySpecsWhereInput[]
    accessoryTypeId?: IntNullableFilter<"AccessorySpecs"> | number | null
    material?: StringNullableFilter<"AccessorySpecs"> | string | null
    color?: StringNullableFilter<"AccessorySpecs"> | string | null
    notes?: StringNullableFilter<"AccessorySpecs"> | string | null
    AccessoryFitment?: AccessoryFitmentListRelationFilter
    AccessoryType?: XOR<AccessoryTypeNullableScalarRelationFilter, AccessoryTypeWhereInput> | null
    CatalogItem?: XOR<CatalogItemScalarRelationFilter, CatalogItemWhereInput>
  }, "id" | "itemId">

  export type AccessorySpecsOrderByWithAggregationInput = {
    id?: SortOrder
    itemId?: SortOrder
    accessoryTypeId?: SortOrderInput | SortOrder
    material?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    _count?: AccessorySpecsCountOrderByAggregateInput
    _avg?: AccessorySpecsAvgOrderByAggregateInput
    _max?: AccessorySpecsMaxOrderByAggregateInput
    _min?: AccessorySpecsMinOrderByAggregateInput
    _sum?: AccessorySpecsSumOrderByAggregateInput
  }

  export type AccessorySpecsScalarWhereWithAggregatesInput = {
    AND?: AccessorySpecsScalarWhereWithAggregatesInput | AccessorySpecsScalarWhereWithAggregatesInput[]
    OR?: AccessorySpecsScalarWhereWithAggregatesInput[]
    NOT?: AccessorySpecsScalarWhereWithAggregatesInput | AccessorySpecsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AccessorySpecs"> | number
    itemId?: StringWithAggregatesFilter<"AccessorySpecs"> | string
    accessoryTypeId?: IntNullableWithAggregatesFilter<"AccessorySpecs"> | number | null
    material?: StringNullableWithAggregatesFilter<"AccessorySpecs"> | string | null
    color?: StringNullableWithAggregatesFilter<"AccessorySpecs"> | string | null
    notes?: StringNullableWithAggregatesFilter<"AccessorySpecs"> | string | null
  }

  export type AccessoryTypeWhereInput = {
    AND?: AccessoryTypeWhereInput | AccessoryTypeWhereInput[]
    OR?: AccessoryTypeWhereInput[]
    NOT?: AccessoryTypeWhereInput | AccessoryTypeWhereInput[]
    id?: IntFilter<"AccessoryType"> | number
    name?: StringFilter<"AccessoryType"> | string
    slug?: StringFilter<"AccessoryType"> | string
    AccessorySpecs?: AccessorySpecsListRelationFilter
  }

  export type AccessoryTypeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    AccessorySpecs?: AccessorySpecsOrderByRelationAggregateInput
  }

  export type AccessoryTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    slug?: string
    AND?: AccessoryTypeWhereInput | AccessoryTypeWhereInput[]
    OR?: AccessoryTypeWhereInput[]
    NOT?: AccessoryTypeWhereInput | AccessoryTypeWhereInput[]
    AccessorySpecs?: AccessorySpecsListRelationFilter
  }, "id" | "name" | "slug">

  export type AccessoryTypeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    _count?: AccessoryTypeCountOrderByAggregateInput
    _avg?: AccessoryTypeAvgOrderByAggregateInput
    _max?: AccessoryTypeMaxOrderByAggregateInput
    _min?: AccessoryTypeMinOrderByAggregateInput
    _sum?: AccessoryTypeSumOrderByAggregateInput
  }

  export type AccessoryTypeScalarWhereWithAggregatesInput = {
    AND?: AccessoryTypeScalarWhereWithAggregatesInput | AccessoryTypeScalarWhereWithAggregatesInput[]
    OR?: AccessoryTypeScalarWhereWithAggregatesInput[]
    NOT?: AccessoryTypeScalarWhereWithAggregatesInput | AccessoryTypeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AccessoryType"> | number
    name?: StringWithAggregatesFilter<"AccessoryType"> | string
    slug?: StringWithAggregatesFilter<"AccessoryType"> | string
  }

  export type AlertWhereInput = {
    AND?: AlertWhereInput | AlertWhereInput[]
    OR?: AlertWhereInput[]
    NOT?: AlertWhereInput | AlertWhereInput[]
    id?: StringFilter<"Alert"> | string
    userId?: StringFilter<"Alert"> | string
    type?: EnumAlertTypeFilter<"Alert"> | $Enums.AlertType
    calId?: IntNullableFilter<"Alert"> | number | null
    itemId?: StringNullableFilter<"Alert"> | string | null
    keyword?: StringNullableFilter<"Alert"> | string | null
    targetCpr?: FloatNullableFilter<"Alert"> | number | null
    excludeSteel?: BoolNullableFilter<"Alert"> | boolean | null
    excludeReman?: BoolNullableFilter<"Alert"> | boolean | null
    lastTriggered?: DateTimeNullableFilter<"Alert"> | Date | string | null
    isActive?: BoolNullableFilter<"Alert"> | boolean | null
    createdAt?: DateTimeNullableFilter<"Alert"> | Date | string | null
    Caliber?: XOR<CaliberNullableScalarRelationFilter, CaliberWhereInput> | null
    CatalogItem?: XOR<CatalogItemNullableScalarRelationFilter, CatalogItemWhereInput> | null
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
    AlertDelivery?: AlertDeliveryListRelationFilter
  }

  export type AlertOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    calId?: SortOrderInput | SortOrder
    itemId?: SortOrderInput | SortOrder
    keyword?: SortOrderInput | SortOrder
    targetCpr?: SortOrderInput | SortOrder
    excludeSteel?: SortOrderInput | SortOrder
    excludeReman?: SortOrderInput | SortOrder
    lastTriggered?: SortOrderInput | SortOrder
    isActive?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    Caliber?: CaliberOrderByWithRelationInput
    CatalogItem?: CatalogItemOrderByWithRelationInput
    User?: UserOrderByWithRelationInput
    AlertDelivery?: AlertDeliveryOrderByRelationAggregateInput
  }

  export type AlertWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AlertWhereInput | AlertWhereInput[]
    OR?: AlertWhereInput[]
    NOT?: AlertWhereInput | AlertWhereInput[]
    userId?: StringFilter<"Alert"> | string
    type?: EnumAlertTypeFilter<"Alert"> | $Enums.AlertType
    calId?: IntNullableFilter<"Alert"> | number | null
    itemId?: StringNullableFilter<"Alert"> | string | null
    keyword?: StringNullableFilter<"Alert"> | string | null
    targetCpr?: FloatNullableFilter<"Alert"> | number | null
    excludeSteel?: BoolNullableFilter<"Alert"> | boolean | null
    excludeReman?: BoolNullableFilter<"Alert"> | boolean | null
    lastTriggered?: DateTimeNullableFilter<"Alert"> | Date | string | null
    isActive?: BoolNullableFilter<"Alert"> | boolean | null
    createdAt?: DateTimeNullableFilter<"Alert"> | Date | string | null
    Caliber?: XOR<CaliberNullableScalarRelationFilter, CaliberWhereInput> | null
    CatalogItem?: XOR<CatalogItemNullableScalarRelationFilter, CatalogItemWhereInput> | null
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
    AlertDelivery?: AlertDeliveryListRelationFilter
  }, "id">

  export type AlertOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    calId?: SortOrderInput | SortOrder
    itemId?: SortOrderInput | SortOrder
    keyword?: SortOrderInput | SortOrder
    targetCpr?: SortOrderInput | SortOrder
    excludeSteel?: SortOrderInput | SortOrder
    excludeReman?: SortOrderInput | SortOrder
    lastTriggered?: SortOrderInput | SortOrder
    isActive?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    _count?: AlertCountOrderByAggregateInput
    _avg?: AlertAvgOrderByAggregateInput
    _max?: AlertMaxOrderByAggregateInput
    _min?: AlertMinOrderByAggregateInput
    _sum?: AlertSumOrderByAggregateInput
  }

  export type AlertScalarWhereWithAggregatesInput = {
    AND?: AlertScalarWhereWithAggregatesInput | AlertScalarWhereWithAggregatesInput[]
    OR?: AlertScalarWhereWithAggregatesInput[]
    NOT?: AlertScalarWhereWithAggregatesInput | AlertScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Alert"> | string
    userId?: StringWithAggregatesFilter<"Alert"> | string
    type?: EnumAlertTypeWithAggregatesFilter<"Alert"> | $Enums.AlertType
    calId?: IntNullableWithAggregatesFilter<"Alert"> | number | null
    itemId?: StringNullableWithAggregatesFilter<"Alert"> | string | null
    keyword?: StringNullableWithAggregatesFilter<"Alert"> | string | null
    targetCpr?: FloatNullableWithAggregatesFilter<"Alert"> | number | null
    excludeSteel?: BoolNullableWithAggregatesFilter<"Alert"> | boolean | null
    excludeReman?: BoolNullableWithAggregatesFilter<"Alert"> | boolean | null
    lastTriggered?: DateTimeNullableWithAggregatesFilter<"Alert"> | Date | string | null
    isActive?: BoolNullableWithAggregatesFilter<"Alert"> | boolean | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"Alert"> | Date | string | null
  }

  export type AlertDeliveryWhereInput = {
    AND?: AlertDeliveryWhereInput | AlertDeliveryWhereInput[]
    OR?: AlertDeliveryWhereInput[]
    NOT?: AlertDeliveryWhereInput | AlertDeliveryWhereInput[]
    id?: StringFilter<"AlertDelivery"> | string
    alertId?: StringFilter<"AlertDelivery"> | string
    offerId?: IntNullableFilter<"AlertDelivery"> | number | null
    sentAt?: DateTimeNullableFilter<"AlertDelivery"> | Date | string | null
    fingerprint?: StringFilter<"AlertDelivery"> | string
    userId?: StringFilter<"AlertDelivery"> | string
    Alert?: XOR<AlertScalarRelationFilter, AlertWhereInput>
    Offer?: XOR<OfferNullableScalarRelationFilter, OfferWhereInput> | null
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AlertDeliveryOrderByWithRelationInput = {
    id?: SortOrder
    alertId?: SortOrder
    offerId?: SortOrderInput | SortOrder
    sentAt?: SortOrderInput | SortOrder
    fingerprint?: SortOrder
    userId?: SortOrder
    Alert?: AlertOrderByWithRelationInput
    Offer?: OfferOrderByWithRelationInput
    User?: UserOrderByWithRelationInput
  }

  export type AlertDeliveryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    alertId_fingerprint?: AlertDeliveryAlertIdFingerprintCompoundUniqueInput
    AND?: AlertDeliveryWhereInput | AlertDeliveryWhereInput[]
    OR?: AlertDeliveryWhereInput[]
    NOT?: AlertDeliveryWhereInput | AlertDeliveryWhereInput[]
    alertId?: StringFilter<"AlertDelivery"> | string
    offerId?: IntNullableFilter<"AlertDelivery"> | number | null
    sentAt?: DateTimeNullableFilter<"AlertDelivery"> | Date | string | null
    fingerprint?: StringFilter<"AlertDelivery"> | string
    userId?: StringFilter<"AlertDelivery"> | string
    Alert?: XOR<AlertScalarRelationFilter, AlertWhereInput>
    Offer?: XOR<OfferNullableScalarRelationFilter, OfferWhereInput> | null
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "alertId_fingerprint">

  export type AlertDeliveryOrderByWithAggregationInput = {
    id?: SortOrder
    alertId?: SortOrder
    offerId?: SortOrderInput | SortOrder
    sentAt?: SortOrderInput | SortOrder
    fingerprint?: SortOrder
    userId?: SortOrder
    _count?: AlertDeliveryCountOrderByAggregateInput
    _avg?: AlertDeliveryAvgOrderByAggregateInput
    _max?: AlertDeliveryMaxOrderByAggregateInput
    _min?: AlertDeliveryMinOrderByAggregateInput
    _sum?: AlertDeliverySumOrderByAggregateInput
  }

  export type AlertDeliveryScalarWhereWithAggregatesInput = {
    AND?: AlertDeliveryScalarWhereWithAggregatesInput | AlertDeliveryScalarWhereWithAggregatesInput[]
    OR?: AlertDeliveryScalarWhereWithAggregatesInput[]
    NOT?: AlertDeliveryScalarWhereWithAggregatesInput | AlertDeliveryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AlertDelivery"> | string
    alertId?: StringWithAggregatesFilter<"AlertDelivery"> | string
    offerId?: IntNullableWithAggregatesFilter<"AlertDelivery"> | number | null
    sentAt?: DateTimeNullableWithAggregatesFilter<"AlertDelivery"> | Date | string | null
    fingerprint?: StringWithAggregatesFilter<"AlertDelivery"> | string
    userId?: StringWithAggregatesFilter<"AlertDelivery"> | string
  }

  export type AmmoSpecsWhereInput = {
    AND?: AmmoSpecsWhereInput | AmmoSpecsWhereInput[]
    OR?: AmmoSpecsWhereInput[]
    NOT?: AmmoSpecsWhereInput | AmmoSpecsWhereInput[]
    id?: IntFilter<"AmmoSpecs"> | number
    itemId?: StringFilter<"AmmoSpecs"> | string
    caliberId?: IntFilter<"AmmoSpecs"> | number
    grain?: IntNullableFilter<"AmmoSpecs"> | number | null
    gauge?: StringNullableFilter<"AmmoSpecs"> | string | null
    velocity?: IntNullableFilter<"AmmoSpecs"> | number | null
    energy?: IntNullableFilter<"AmmoSpecs"> | number | null
    casing?: StringNullableFilter<"AmmoSpecs"> | string | null
    bulletType?: StringNullableFilter<"AmmoSpecs"> | string | null
    restrictions?: StringNullableListFilter<"AmmoSpecs">
    pressure?: EnumAmmoPressureNullableFilter<"AmmoSpecs"> | $Enums.AmmoPressure | null
    isSteelCase?: BoolNullableFilter<"AmmoSpecs"> | boolean | null
    isRemanufactured?: BoolNullableFilter<"AmmoSpecs"> | boolean | null
    isSubsonic?: BoolNullableFilter<"AmmoSpecs"> | boolean | null
    Caliber?: XOR<CaliberScalarRelationFilter, CaliberWhereInput>
    CatalogItem?: XOR<CatalogItemScalarRelationFilter, CatalogItemWhereInput>
  }

  export type AmmoSpecsOrderByWithRelationInput = {
    id?: SortOrder
    itemId?: SortOrder
    caliberId?: SortOrder
    grain?: SortOrderInput | SortOrder
    gauge?: SortOrderInput | SortOrder
    velocity?: SortOrderInput | SortOrder
    energy?: SortOrderInput | SortOrder
    casing?: SortOrderInput | SortOrder
    bulletType?: SortOrderInput | SortOrder
    restrictions?: SortOrder
    pressure?: SortOrderInput | SortOrder
    isSteelCase?: SortOrderInput | SortOrder
    isRemanufactured?: SortOrderInput | SortOrder
    isSubsonic?: SortOrderInput | SortOrder
    Caliber?: CaliberOrderByWithRelationInput
    CatalogItem?: CatalogItemOrderByWithRelationInput
  }

  export type AmmoSpecsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    itemId?: string
    AND?: AmmoSpecsWhereInput | AmmoSpecsWhereInput[]
    OR?: AmmoSpecsWhereInput[]
    NOT?: AmmoSpecsWhereInput | AmmoSpecsWhereInput[]
    caliberId?: IntFilter<"AmmoSpecs"> | number
    grain?: IntNullableFilter<"AmmoSpecs"> | number | null
    gauge?: StringNullableFilter<"AmmoSpecs"> | string | null
    velocity?: IntNullableFilter<"AmmoSpecs"> | number | null
    energy?: IntNullableFilter<"AmmoSpecs"> | number | null
    casing?: StringNullableFilter<"AmmoSpecs"> | string | null
    bulletType?: StringNullableFilter<"AmmoSpecs"> | string | null
    restrictions?: StringNullableListFilter<"AmmoSpecs">
    pressure?: EnumAmmoPressureNullableFilter<"AmmoSpecs"> | $Enums.AmmoPressure | null
    isSteelCase?: BoolNullableFilter<"AmmoSpecs"> | boolean | null
    isRemanufactured?: BoolNullableFilter<"AmmoSpecs"> | boolean | null
    isSubsonic?: BoolNullableFilter<"AmmoSpecs"> | boolean | null
    Caliber?: XOR<CaliberScalarRelationFilter, CaliberWhereInput>
    CatalogItem?: XOR<CatalogItemScalarRelationFilter, CatalogItemWhereInput>
  }, "id" | "itemId">

  export type AmmoSpecsOrderByWithAggregationInput = {
    id?: SortOrder
    itemId?: SortOrder
    caliberId?: SortOrder
    grain?: SortOrderInput | SortOrder
    gauge?: SortOrderInput | SortOrder
    velocity?: SortOrderInput | SortOrder
    energy?: SortOrderInput | SortOrder
    casing?: SortOrderInput | SortOrder
    bulletType?: SortOrderInput | SortOrder
    restrictions?: SortOrder
    pressure?: SortOrderInput | SortOrder
    isSteelCase?: SortOrderInput | SortOrder
    isRemanufactured?: SortOrderInput | SortOrder
    isSubsonic?: SortOrderInput | SortOrder
    _count?: AmmoSpecsCountOrderByAggregateInput
    _avg?: AmmoSpecsAvgOrderByAggregateInput
    _max?: AmmoSpecsMaxOrderByAggregateInput
    _min?: AmmoSpecsMinOrderByAggregateInput
    _sum?: AmmoSpecsSumOrderByAggregateInput
  }

  export type AmmoSpecsScalarWhereWithAggregatesInput = {
    AND?: AmmoSpecsScalarWhereWithAggregatesInput | AmmoSpecsScalarWhereWithAggregatesInput[]
    OR?: AmmoSpecsScalarWhereWithAggregatesInput[]
    NOT?: AmmoSpecsScalarWhereWithAggregatesInput | AmmoSpecsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AmmoSpecs"> | number
    itemId?: StringWithAggregatesFilter<"AmmoSpecs"> | string
    caliberId?: IntWithAggregatesFilter<"AmmoSpecs"> | number
    grain?: IntNullableWithAggregatesFilter<"AmmoSpecs"> | number | null
    gauge?: StringNullableWithAggregatesFilter<"AmmoSpecs"> | string | null
    velocity?: IntNullableWithAggregatesFilter<"AmmoSpecs"> | number | null
    energy?: IntNullableWithAggregatesFilter<"AmmoSpecs"> | number | null
    casing?: StringNullableWithAggregatesFilter<"AmmoSpecs"> | string | null
    bulletType?: StringNullableWithAggregatesFilter<"AmmoSpecs"> | string | null
    restrictions?: StringNullableListFilter<"AmmoSpecs">
    pressure?: EnumAmmoPressureNullableWithAggregatesFilter<"AmmoSpecs"> | $Enums.AmmoPressure | null
    isSteelCase?: BoolNullableWithAggregatesFilter<"AmmoSpecs"> | boolean | null
    isRemanufactured?: BoolNullableWithAggregatesFilter<"AmmoSpecs"> | boolean | null
    isSubsonic?: BoolNullableWithAggregatesFilter<"AmmoSpecs"> | boolean | null
  }

  export type BlockedRetailerWhereInput = {
    AND?: BlockedRetailerWhereInput | BlockedRetailerWhereInput[]
    OR?: BlockedRetailerWhereInput[]
    NOT?: BlockedRetailerWhereInput | BlockedRetailerWhereInput[]
    id?: StringFilter<"BlockedRetailer"> | string
    userId?: StringFilter<"BlockedRetailer"> | string
    retailerId?: IntFilter<"BlockedRetailer"> | number
    createdAt?: DateTimeNullableFilter<"BlockedRetailer"> | Date | string | null
    Retailer?: XOR<RetailerScalarRelationFilter, RetailerWhereInput>
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type BlockedRetailerOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    retailerId?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    Retailer?: RetailerOrderByWithRelationInput
    User?: UserOrderByWithRelationInput
  }

  export type BlockedRetailerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BlockedRetailerWhereInput | BlockedRetailerWhereInput[]
    OR?: BlockedRetailerWhereInput[]
    NOT?: BlockedRetailerWhereInput | BlockedRetailerWhereInput[]
    userId?: StringFilter<"BlockedRetailer"> | string
    retailerId?: IntFilter<"BlockedRetailer"> | number
    createdAt?: DateTimeNullableFilter<"BlockedRetailer"> | Date | string | null
    Retailer?: XOR<RetailerScalarRelationFilter, RetailerWhereInput>
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type BlockedRetailerOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    retailerId?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    _count?: BlockedRetailerCountOrderByAggregateInput
    _avg?: BlockedRetailerAvgOrderByAggregateInput
    _max?: BlockedRetailerMaxOrderByAggregateInput
    _min?: BlockedRetailerMinOrderByAggregateInput
    _sum?: BlockedRetailerSumOrderByAggregateInput
  }

  export type BlockedRetailerScalarWhereWithAggregatesInput = {
    AND?: BlockedRetailerScalarWhereWithAggregatesInput | BlockedRetailerScalarWhereWithAggregatesInput[]
    OR?: BlockedRetailerScalarWhereWithAggregatesInput[]
    NOT?: BlockedRetailerScalarWhereWithAggregatesInput | BlockedRetailerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BlockedRetailer"> | string
    userId?: StringWithAggregatesFilter<"BlockedRetailer"> | string
    retailerId?: IntWithAggregatesFilter<"BlockedRetailer"> | number
    createdAt?: DateTimeNullableWithAggregatesFilter<"BlockedRetailer"> | Date | string | null
  }

  export type CaliberAliasWhereInput = {
    AND?: CaliberAliasWhereInput | CaliberAliasWhereInput[]
    OR?: CaliberAliasWhereInput[]
    NOT?: CaliberAliasWhereInput | CaliberAliasWhereInput[]
    id?: IntFilter<"CaliberAlias"> | number
    caliberId?: IntFilter<"CaliberAlias"> | number
    alias?: StringFilter<"CaliberAlias"> | string
    Caliber?: XOR<CaliberScalarRelationFilter, CaliberWhereInput>
  }

  export type CaliberAliasOrderByWithRelationInput = {
    id?: SortOrder
    caliberId?: SortOrder
    alias?: SortOrder
    Caliber?: CaliberOrderByWithRelationInput
  }

  export type CaliberAliasWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    alias?: string
    AND?: CaliberAliasWhereInput | CaliberAliasWhereInput[]
    OR?: CaliberAliasWhereInput[]
    NOT?: CaliberAliasWhereInput | CaliberAliasWhereInput[]
    caliberId?: IntFilter<"CaliberAlias"> | number
    Caliber?: XOR<CaliberScalarRelationFilter, CaliberWhereInput>
  }, "id" | "alias">

  export type CaliberAliasOrderByWithAggregationInput = {
    id?: SortOrder
    caliberId?: SortOrder
    alias?: SortOrder
    _count?: CaliberAliasCountOrderByAggregateInput
    _avg?: CaliberAliasAvgOrderByAggregateInput
    _max?: CaliberAliasMaxOrderByAggregateInput
    _min?: CaliberAliasMinOrderByAggregateInput
    _sum?: CaliberAliasSumOrderByAggregateInput
  }

  export type CaliberAliasScalarWhereWithAggregatesInput = {
    AND?: CaliberAliasScalarWhereWithAggregatesInput | CaliberAliasScalarWhereWithAggregatesInput[]
    OR?: CaliberAliasScalarWhereWithAggregatesInput[]
    NOT?: CaliberAliasScalarWhereWithAggregatesInput | CaliberAliasScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CaliberAlias"> | number
    caliberId?: IntWithAggregatesFilter<"CaliberAlias"> | number
    alias?: StringWithAggregatesFilter<"CaliberAlias"> | string
  }

  export type CatalogItemWhereInput = {
    AND?: CatalogItemWhereInput | CatalogItemWhereInput[]
    OR?: CatalogItemWhereInput[]
    NOT?: CatalogItemWhereInput | CatalogItemWhereInput[]
    id?: StringFilter<"CatalogItem"> | string
    kind?: EnumCatalogKindFilter<"CatalogItem"> | $Enums.CatalogKind
    slug?: StringFilter<"CatalogItem"> | string
    upc?: StringNullableFilter<"CatalogItem"> | string | null
    mpn?: StringNullableFilter<"CatalogItem"> | string | null
    title?: StringFilter<"CatalogItem"> | string
    image?: StringNullableFilter<"CatalogItem"> | string | null
    description?: StringNullableFilter<"CatalogItem"> | string | null
    brandId?: IntNullableFilter<"CatalogItem"> | number | null
    createdAt?: DateTimeNullableFilter<"CatalogItem"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"CatalogItem"> | Date | string | null
    bestPrice?: FloatNullableFilter<"CatalogItem"> | number | null
    bestRetailerId?: IntNullableFilter<"CatalogItem"> | number | null
    bestRetailerName?: StringNullableFilter<"CatalogItem"> | string | null
    offerCount?: IntNullableFilter<"CatalogItem"> | number | null
    bestCpr?: FloatNullableFilter<"CatalogItem"> | number | null
    bestCprShipped?: FloatNullableFilter<"CatalogItem"> | number | null
    upvotes?: IntNullableFilter<"CatalogItem"> | number | null
    downvotes?: IntNullableFilter<"CatalogItem"> | number | null
    AccessoryFitment?: AccessoryFitmentListRelationFilter
    AccessorySpecs?: XOR<AccessorySpecsNullableScalarRelationFilter, AccessorySpecsWhereInput> | null
    Alert?: AlertListRelationFilter
    AmmoSpecs?: XOR<AmmoSpecsNullableScalarRelationFilter, AmmoSpecsWhereInput> | null
    Brand?: XOR<BrandNullableScalarRelationFilter, BrandWhereInput> | null
    FirearmSpecs?: XOR<FirearmSpecsNullableScalarRelationFilter, FirearmSpecsWhereInput> | null
    Offer?: OfferListRelationFilter
    OwnedFirearm?: OwnedFirearmListRelationFilter
  }

  export type CatalogItemOrderByWithRelationInput = {
    id?: SortOrder
    kind?: SortOrder
    slug?: SortOrder
    upc?: SortOrderInput | SortOrder
    mpn?: SortOrderInput | SortOrder
    title?: SortOrder
    image?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    brandId?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    bestPrice?: SortOrderInput | SortOrder
    bestRetailerId?: SortOrderInput | SortOrder
    bestRetailerName?: SortOrderInput | SortOrder
    offerCount?: SortOrderInput | SortOrder
    bestCpr?: SortOrderInput | SortOrder
    bestCprShipped?: SortOrderInput | SortOrder
    upvotes?: SortOrderInput | SortOrder
    downvotes?: SortOrderInput | SortOrder
    AccessoryFitment?: AccessoryFitmentOrderByRelationAggregateInput
    AccessorySpecs?: AccessorySpecsOrderByWithRelationInput
    Alert?: AlertOrderByRelationAggregateInput
    AmmoSpecs?: AmmoSpecsOrderByWithRelationInput
    Brand?: BrandOrderByWithRelationInput
    FirearmSpecs?: FirearmSpecsOrderByWithRelationInput
    Offer?: OfferOrderByRelationAggregateInput
    OwnedFirearm?: OwnedFirearmOrderByRelationAggregateInput
  }

  export type CatalogItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    upc?: string
    AND?: CatalogItemWhereInput | CatalogItemWhereInput[]
    OR?: CatalogItemWhereInput[]
    NOT?: CatalogItemWhereInput | CatalogItemWhereInput[]
    kind?: EnumCatalogKindFilter<"CatalogItem"> | $Enums.CatalogKind
    mpn?: StringNullableFilter<"CatalogItem"> | string | null
    title?: StringFilter<"CatalogItem"> | string
    image?: StringNullableFilter<"CatalogItem"> | string | null
    description?: StringNullableFilter<"CatalogItem"> | string | null
    brandId?: IntNullableFilter<"CatalogItem"> | number | null
    createdAt?: DateTimeNullableFilter<"CatalogItem"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"CatalogItem"> | Date | string | null
    bestPrice?: FloatNullableFilter<"CatalogItem"> | number | null
    bestRetailerId?: IntNullableFilter<"CatalogItem"> | number | null
    bestRetailerName?: StringNullableFilter<"CatalogItem"> | string | null
    offerCount?: IntNullableFilter<"CatalogItem"> | number | null
    bestCpr?: FloatNullableFilter<"CatalogItem"> | number | null
    bestCprShipped?: FloatNullableFilter<"CatalogItem"> | number | null
    upvotes?: IntNullableFilter<"CatalogItem"> | number | null
    downvotes?: IntNullableFilter<"CatalogItem"> | number | null
    AccessoryFitment?: AccessoryFitmentListRelationFilter
    AccessorySpecs?: XOR<AccessorySpecsNullableScalarRelationFilter, AccessorySpecsWhereInput> | null
    Alert?: AlertListRelationFilter
    AmmoSpecs?: XOR<AmmoSpecsNullableScalarRelationFilter, AmmoSpecsWhereInput> | null
    Brand?: XOR<BrandNullableScalarRelationFilter, BrandWhereInput> | null
    FirearmSpecs?: XOR<FirearmSpecsNullableScalarRelationFilter, FirearmSpecsWhereInput> | null
    Offer?: OfferListRelationFilter
    OwnedFirearm?: OwnedFirearmListRelationFilter
  }, "id" | "slug" | "upc">

  export type CatalogItemOrderByWithAggregationInput = {
    id?: SortOrder
    kind?: SortOrder
    slug?: SortOrder
    upc?: SortOrderInput | SortOrder
    mpn?: SortOrderInput | SortOrder
    title?: SortOrder
    image?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    brandId?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    bestPrice?: SortOrderInput | SortOrder
    bestRetailerId?: SortOrderInput | SortOrder
    bestRetailerName?: SortOrderInput | SortOrder
    offerCount?: SortOrderInput | SortOrder
    bestCpr?: SortOrderInput | SortOrder
    bestCprShipped?: SortOrderInput | SortOrder
    upvotes?: SortOrderInput | SortOrder
    downvotes?: SortOrderInput | SortOrder
    _count?: CatalogItemCountOrderByAggregateInput
    _avg?: CatalogItemAvgOrderByAggregateInput
    _max?: CatalogItemMaxOrderByAggregateInput
    _min?: CatalogItemMinOrderByAggregateInput
    _sum?: CatalogItemSumOrderByAggregateInput
  }

  export type CatalogItemScalarWhereWithAggregatesInput = {
    AND?: CatalogItemScalarWhereWithAggregatesInput | CatalogItemScalarWhereWithAggregatesInput[]
    OR?: CatalogItemScalarWhereWithAggregatesInput[]
    NOT?: CatalogItemScalarWhereWithAggregatesInput | CatalogItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CatalogItem"> | string
    kind?: EnumCatalogKindWithAggregatesFilter<"CatalogItem"> | $Enums.CatalogKind
    slug?: StringWithAggregatesFilter<"CatalogItem"> | string
    upc?: StringNullableWithAggregatesFilter<"CatalogItem"> | string | null
    mpn?: StringNullableWithAggregatesFilter<"CatalogItem"> | string | null
    title?: StringWithAggregatesFilter<"CatalogItem"> | string
    image?: StringNullableWithAggregatesFilter<"CatalogItem"> | string | null
    description?: StringNullableWithAggregatesFilter<"CatalogItem"> | string | null
    brandId?: IntNullableWithAggregatesFilter<"CatalogItem"> | number | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"CatalogItem"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"CatalogItem"> | Date | string | null
    bestPrice?: FloatNullableWithAggregatesFilter<"CatalogItem"> | number | null
    bestRetailerId?: IntNullableWithAggregatesFilter<"CatalogItem"> | number | null
    bestRetailerName?: StringNullableWithAggregatesFilter<"CatalogItem"> | string | null
    offerCount?: IntNullableWithAggregatesFilter<"CatalogItem"> | number | null
    bestCpr?: FloatNullableWithAggregatesFilter<"CatalogItem"> | number | null
    bestCprShipped?: FloatNullableWithAggregatesFilter<"CatalogItem"> | number | null
    upvotes?: IntNullableWithAggregatesFilter<"CatalogItem"> | number | null
    downvotes?: IntNullableWithAggregatesFilter<"CatalogItem"> | number | null
  }

  export type FirearmCategoryWhereInput = {
    AND?: FirearmCategoryWhereInput | FirearmCategoryWhereInput[]
    OR?: FirearmCategoryWhereInput[]
    NOT?: FirearmCategoryWhereInput | FirearmCategoryWhereInput[]
    id?: IntFilter<"FirearmCategory"> | number
    name?: StringFilter<"FirearmCategory"> | string
    slug?: StringFilter<"FirearmCategory"> | string
    FirearmSpecs?: FirearmSpecsListRelationFilter
  }

  export type FirearmCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    FirearmSpecs?: FirearmSpecsOrderByRelationAggregateInput
  }

  export type FirearmCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    slug?: string
    AND?: FirearmCategoryWhereInput | FirearmCategoryWhereInput[]
    OR?: FirearmCategoryWhereInput[]
    NOT?: FirearmCategoryWhereInput | FirearmCategoryWhereInput[]
    FirearmSpecs?: FirearmSpecsListRelationFilter
  }, "id" | "name" | "slug">

  export type FirearmCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    _count?: FirearmCategoryCountOrderByAggregateInput
    _avg?: FirearmCategoryAvgOrderByAggregateInput
    _max?: FirearmCategoryMaxOrderByAggregateInput
    _min?: FirearmCategoryMinOrderByAggregateInput
    _sum?: FirearmCategorySumOrderByAggregateInput
  }

  export type FirearmCategoryScalarWhereWithAggregatesInput = {
    AND?: FirearmCategoryScalarWhereWithAggregatesInput | FirearmCategoryScalarWhereWithAggregatesInput[]
    OR?: FirearmCategoryScalarWhereWithAggregatesInput[]
    NOT?: FirearmCategoryScalarWhereWithAggregatesInput | FirearmCategoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FirearmCategory"> | number
    name?: StringWithAggregatesFilter<"FirearmCategory"> | string
    slug?: StringWithAggregatesFilter<"FirearmCategory"> | string
  }

  export type FirearmChamberWhereInput = {
    AND?: FirearmChamberWhereInput | FirearmChamberWhereInput[]
    OR?: FirearmChamberWhereInput[]
    NOT?: FirearmChamberWhereInput | FirearmChamberWhereInput[]
    firearmSpecsId?: IntFilter<"FirearmChamber"> | number
    caliberId?: IntFilter<"FirearmChamber"> | number
    note?: StringNullableFilter<"FirearmChamber"> | string | null
    Caliber?: XOR<CaliberScalarRelationFilter, CaliberWhereInput>
    FirearmSpecs?: XOR<FirearmSpecsScalarRelationFilter, FirearmSpecsWhereInput>
  }

  export type FirearmChamberOrderByWithRelationInput = {
    firearmSpecsId?: SortOrder
    caliberId?: SortOrder
    note?: SortOrderInput | SortOrder
    Caliber?: CaliberOrderByWithRelationInput
    FirearmSpecs?: FirearmSpecsOrderByWithRelationInput
  }

  export type FirearmChamberWhereUniqueInput = Prisma.AtLeast<{
    firearmSpecsId_caliberId?: FirearmChamberFirearmSpecsIdCaliberIdCompoundUniqueInput
    AND?: FirearmChamberWhereInput | FirearmChamberWhereInput[]
    OR?: FirearmChamberWhereInput[]
    NOT?: FirearmChamberWhereInput | FirearmChamberWhereInput[]
    firearmSpecsId?: IntFilter<"FirearmChamber"> | number
    caliberId?: IntFilter<"FirearmChamber"> | number
    note?: StringNullableFilter<"FirearmChamber"> | string | null
    Caliber?: XOR<CaliberScalarRelationFilter, CaliberWhereInput>
    FirearmSpecs?: XOR<FirearmSpecsScalarRelationFilter, FirearmSpecsWhereInput>
  }, "firearmSpecsId_caliberId">

  export type FirearmChamberOrderByWithAggregationInput = {
    firearmSpecsId?: SortOrder
    caliberId?: SortOrder
    note?: SortOrderInput | SortOrder
    _count?: FirearmChamberCountOrderByAggregateInput
    _avg?: FirearmChamberAvgOrderByAggregateInput
    _max?: FirearmChamberMaxOrderByAggregateInput
    _min?: FirearmChamberMinOrderByAggregateInput
    _sum?: FirearmChamberSumOrderByAggregateInput
  }

  export type FirearmChamberScalarWhereWithAggregatesInput = {
    AND?: FirearmChamberScalarWhereWithAggregatesInput | FirearmChamberScalarWhereWithAggregatesInput[]
    OR?: FirearmChamberScalarWhereWithAggregatesInput[]
    NOT?: FirearmChamberScalarWhereWithAggregatesInput | FirearmChamberScalarWhereWithAggregatesInput[]
    firearmSpecsId?: IntWithAggregatesFilter<"FirearmChamber"> | number
    caliberId?: IntWithAggregatesFilter<"FirearmChamber"> | number
    note?: StringNullableWithAggregatesFilter<"FirearmChamber"> | string | null
  }

  export type FirearmSpecsWhereInput = {
    AND?: FirearmSpecsWhereInput | FirearmSpecsWhereInput[]
    OR?: FirearmSpecsWhereInput[]
    NOT?: FirearmSpecsWhereInput | FirearmSpecsWhereInput[]
    id?: IntFilter<"FirearmSpecs"> | number
    itemId?: StringFilter<"FirearmSpecs"> | string
    manufacturer?: StringNullableFilter<"FirearmSpecs"> | string | null
    model?: StringNullableFilter<"FirearmSpecs"> | string | null
    platform?: StringNullableFilter<"FirearmSpecs"> | string | null
    firearmCategoryId?: IntNullableFilter<"FirearmSpecs"> | number | null
    barrelLengthIn?: FloatNullableFilter<"FirearmSpecs"> | number | null
    actionType?: StringNullableFilter<"FirearmSpecs"> | string | null
    isThreaded?: BoolNullableFilter<"FirearmSpecs"> | boolean | null
    pressureRating?: EnumFirearmPressureRatingNullableFilter<"FirearmSpecs"> | $Enums.FirearmPressureRating | null
    firearmType?: StringNullableFilter<"FirearmSpecs"> | string | null
    capacity?: StringNullableFilter<"FirearmSpecs"> | string | null
    finish?: StringNullableFilter<"FirearmSpecs"> | string | null
    weight?: StringNullableFilter<"FirearmSpecs"> | string | null
    overallLength?: StringNullableFilter<"FirearmSpecs"> | string | null
    features?: StringNullableFilter<"FirearmSpecs"> | string | null
    sight?: StringNullableFilter<"FirearmSpecs"> | string | null
    safety?: StringNullableFilter<"FirearmSpecs"> | string | null
    FirearmChamber?: FirearmChamberListRelationFilter
    FirearmCategory?: XOR<FirearmCategoryNullableScalarRelationFilter, FirearmCategoryWhereInput> | null
    CatalogItem?: XOR<CatalogItemScalarRelationFilter, CatalogItemWhereInput>
  }

  export type FirearmSpecsOrderByWithRelationInput = {
    id?: SortOrder
    itemId?: SortOrder
    manufacturer?: SortOrderInput | SortOrder
    model?: SortOrderInput | SortOrder
    platform?: SortOrderInput | SortOrder
    firearmCategoryId?: SortOrderInput | SortOrder
    barrelLengthIn?: SortOrderInput | SortOrder
    actionType?: SortOrderInput | SortOrder
    isThreaded?: SortOrderInput | SortOrder
    pressureRating?: SortOrderInput | SortOrder
    firearmType?: SortOrderInput | SortOrder
    capacity?: SortOrderInput | SortOrder
    finish?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    overallLength?: SortOrderInput | SortOrder
    features?: SortOrderInput | SortOrder
    sight?: SortOrderInput | SortOrder
    safety?: SortOrderInput | SortOrder
    FirearmChamber?: FirearmChamberOrderByRelationAggregateInput
    FirearmCategory?: FirearmCategoryOrderByWithRelationInput
    CatalogItem?: CatalogItemOrderByWithRelationInput
  }

  export type FirearmSpecsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    itemId?: string
    AND?: FirearmSpecsWhereInput | FirearmSpecsWhereInput[]
    OR?: FirearmSpecsWhereInput[]
    NOT?: FirearmSpecsWhereInput | FirearmSpecsWhereInput[]
    manufacturer?: StringNullableFilter<"FirearmSpecs"> | string | null
    model?: StringNullableFilter<"FirearmSpecs"> | string | null
    platform?: StringNullableFilter<"FirearmSpecs"> | string | null
    firearmCategoryId?: IntNullableFilter<"FirearmSpecs"> | number | null
    barrelLengthIn?: FloatNullableFilter<"FirearmSpecs"> | number | null
    actionType?: StringNullableFilter<"FirearmSpecs"> | string | null
    isThreaded?: BoolNullableFilter<"FirearmSpecs"> | boolean | null
    pressureRating?: EnumFirearmPressureRatingNullableFilter<"FirearmSpecs"> | $Enums.FirearmPressureRating | null
    firearmType?: StringNullableFilter<"FirearmSpecs"> | string | null
    capacity?: StringNullableFilter<"FirearmSpecs"> | string | null
    finish?: StringNullableFilter<"FirearmSpecs"> | string | null
    weight?: StringNullableFilter<"FirearmSpecs"> | string | null
    overallLength?: StringNullableFilter<"FirearmSpecs"> | string | null
    features?: StringNullableFilter<"FirearmSpecs"> | string | null
    sight?: StringNullableFilter<"FirearmSpecs"> | string | null
    safety?: StringNullableFilter<"FirearmSpecs"> | string | null
    FirearmChamber?: FirearmChamberListRelationFilter
    FirearmCategory?: XOR<FirearmCategoryNullableScalarRelationFilter, FirearmCategoryWhereInput> | null
    CatalogItem?: XOR<CatalogItemScalarRelationFilter, CatalogItemWhereInput>
  }, "id" | "itemId">

  export type FirearmSpecsOrderByWithAggregationInput = {
    id?: SortOrder
    itemId?: SortOrder
    manufacturer?: SortOrderInput | SortOrder
    model?: SortOrderInput | SortOrder
    platform?: SortOrderInput | SortOrder
    firearmCategoryId?: SortOrderInput | SortOrder
    barrelLengthIn?: SortOrderInput | SortOrder
    actionType?: SortOrderInput | SortOrder
    isThreaded?: SortOrderInput | SortOrder
    pressureRating?: SortOrderInput | SortOrder
    firearmType?: SortOrderInput | SortOrder
    capacity?: SortOrderInput | SortOrder
    finish?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    overallLength?: SortOrderInput | SortOrder
    features?: SortOrderInput | SortOrder
    sight?: SortOrderInput | SortOrder
    safety?: SortOrderInput | SortOrder
    _count?: FirearmSpecsCountOrderByAggregateInput
    _avg?: FirearmSpecsAvgOrderByAggregateInput
    _max?: FirearmSpecsMaxOrderByAggregateInput
    _min?: FirearmSpecsMinOrderByAggregateInput
    _sum?: FirearmSpecsSumOrderByAggregateInput
  }

  export type FirearmSpecsScalarWhereWithAggregatesInput = {
    AND?: FirearmSpecsScalarWhereWithAggregatesInput | FirearmSpecsScalarWhereWithAggregatesInput[]
    OR?: FirearmSpecsScalarWhereWithAggregatesInput[]
    NOT?: FirearmSpecsScalarWhereWithAggregatesInput | FirearmSpecsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FirearmSpecs"> | number
    itemId?: StringWithAggregatesFilter<"FirearmSpecs"> | string
    manufacturer?: StringNullableWithAggregatesFilter<"FirearmSpecs"> | string | null
    model?: StringNullableWithAggregatesFilter<"FirearmSpecs"> | string | null
    platform?: StringNullableWithAggregatesFilter<"FirearmSpecs"> | string | null
    firearmCategoryId?: IntNullableWithAggregatesFilter<"FirearmSpecs"> | number | null
    barrelLengthIn?: FloatNullableWithAggregatesFilter<"FirearmSpecs"> | number | null
    actionType?: StringNullableWithAggregatesFilter<"FirearmSpecs"> | string | null
    isThreaded?: BoolNullableWithAggregatesFilter<"FirearmSpecs"> | boolean | null
    pressureRating?: EnumFirearmPressureRatingNullableWithAggregatesFilter<"FirearmSpecs"> | $Enums.FirearmPressureRating | null
    firearmType?: StringNullableWithAggregatesFilter<"FirearmSpecs"> | string | null
    capacity?: StringNullableWithAggregatesFilter<"FirearmSpecs"> | string | null
    finish?: StringNullableWithAggregatesFilter<"FirearmSpecs"> | string | null
    weight?: StringNullableWithAggregatesFilter<"FirearmSpecs"> | string | null
    overallLength?: StringNullableWithAggregatesFilter<"FirearmSpecs"> | string | null
    features?: StringNullableWithAggregatesFilter<"FirearmSpecs"> | string | null
    sight?: StringNullableWithAggregatesFilter<"FirearmSpecs"> | string | null
    safety?: StringNullableWithAggregatesFilter<"FirearmSpecs"> | string | null
  }

  export type OwnedFirearmWhereInput = {
    AND?: OwnedFirearmWhereInput | OwnedFirearmWhereInput[]
    OR?: OwnedFirearmWhereInput[]
    NOT?: OwnedFirearmWhereInput | OwnedFirearmWhereInput[]
    id?: StringFilter<"OwnedFirearm"> | string
    userId?: StringFilter<"OwnedFirearm"> | string
    firearmItemId?: StringFilter<"OwnedFirearm"> | string
    nickname?: StringNullableFilter<"OwnedFirearm"> | string | null
    createdAt?: DateTimeNullableFilter<"OwnedFirearm"> | Date | string | null
    CatalogItem?: XOR<CatalogItemScalarRelationFilter, CatalogItemWhereInput>
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type OwnedFirearmOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    firearmItemId?: SortOrder
    nickname?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    CatalogItem?: CatalogItemOrderByWithRelationInput
    User?: UserOrderByWithRelationInput
  }

  export type OwnedFirearmWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_firearmItemId?: OwnedFirearmUserIdFirearmItemIdCompoundUniqueInput
    AND?: OwnedFirearmWhereInput | OwnedFirearmWhereInput[]
    OR?: OwnedFirearmWhereInput[]
    NOT?: OwnedFirearmWhereInput | OwnedFirearmWhereInput[]
    userId?: StringFilter<"OwnedFirearm"> | string
    firearmItemId?: StringFilter<"OwnedFirearm"> | string
    nickname?: StringNullableFilter<"OwnedFirearm"> | string | null
    createdAt?: DateTimeNullableFilter<"OwnedFirearm"> | Date | string | null
    CatalogItem?: XOR<CatalogItemScalarRelationFilter, CatalogItemWhereInput>
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_firearmItemId">

  export type OwnedFirearmOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    firearmItemId?: SortOrder
    nickname?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    _count?: OwnedFirearmCountOrderByAggregateInput
    _max?: OwnedFirearmMaxOrderByAggregateInput
    _min?: OwnedFirearmMinOrderByAggregateInput
  }

  export type OwnedFirearmScalarWhereWithAggregatesInput = {
    AND?: OwnedFirearmScalarWhereWithAggregatesInput | OwnedFirearmScalarWhereWithAggregatesInput[]
    OR?: OwnedFirearmScalarWhereWithAggregatesInput[]
    NOT?: OwnedFirearmScalarWhereWithAggregatesInput | OwnedFirearmScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OwnedFirearm"> | string
    userId?: StringWithAggregatesFilter<"OwnedFirearm"> | string
    firearmItemId?: StringWithAggregatesFilter<"OwnedFirearm"> | string
    nickname?: StringNullableWithAggregatesFilter<"OwnedFirearm"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"OwnedFirearm"> | Date | string | null
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    email?: StringNullableFilter<"User"> | string | null
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    image?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeNullableFilter<"User"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    Alert?: AlertListRelationFilter
    AlertDelivery?: AlertDeliveryListRelationFilter
    BlockedRetailer?: BlockedRetailerListRelationFilter
    OwnedFirearm?: OwnedFirearmListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    emailVerified?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    Alert?: AlertOrderByRelationAggregateInput
    AlertDelivery?: AlertDeliveryOrderByRelationAggregateInput
    BlockedRetailer?: BlockedRetailerOrderByRelationAggregateInput
    OwnedFirearm?: OwnedFirearmOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    image?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeNullableFilter<"User"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    Alert?: AlertListRelationFilter
    AlertDelivery?: AlertDeliveryListRelationFilter
    BlockedRetailer?: BlockedRetailerListRelationFilter
    OwnedFirearm?: OwnedFirearmListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    emailVerified?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    emailVerified?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
  }

  export type raw_offer_ingestWhereInput = {
    AND?: raw_offer_ingestWhereInput | raw_offer_ingestWhereInput[]
    OR?: raw_offer_ingestWhereInput[]
    NOT?: raw_offer_ingestWhereInput | raw_offer_ingestWhereInput[]
    time?: DateTimeFilter<"raw_offer_ingest"> | Date | string
    bucket_5m?: DateTimeFilter<"raw_offer_ingest"> | Date | string
    group_id?: StringNullableFilter<"raw_offer_ingest"> | string | null
    item_url?: StringNullableFilter<"raw_offer_ingest"> | string | null
    item_type?: StringNullableFilter<"raw_offer_ingest"> | string | null
    retailer_name?: StringNullableFilter<"raw_offer_ingest"> | string | null
    offer_url?: StringNullableFilter<"raw_offer_ingest"> | string | null
    price?: FloatNullableFilter<"raw_offer_ingest"> | number | null
    shipping_text?: StringNullableFilter<"raw_offer_ingest"> | string | null
    shipping_cost?: FloatNullableFilter<"raw_offer_ingest"> | number | null
    total?: FloatNullableFilter<"raw_offer_ingest"> | number | null
    in_stock?: BoolNullableFilter<"raw_offer_ingest"> | boolean | null
    source?: StringNullableFilter<"raw_offer_ingest"> | string | null
    offer_fingerprint?: StringFilter<"raw_offer_ingest"> | string
  }

  export type raw_offer_ingestOrderByWithRelationInput = {
    time?: SortOrder
    bucket_5m?: SortOrder
    group_id?: SortOrderInput | SortOrder
    item_url?: SortOrderInput | SortOrder
    item_type?: SortOrderInput | SortOrder
    retailer_name?: SortOrderInput | SortOrder
    offer_url?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    shipping_text?: SortOrderInput | SortOrder
    shipping_cost?: SortOrderInput | SortOrder
    total?: SortOrderInput | SortOrder
    in_stock?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    offer_fingerprint?: SortOrder
  }

  export type raw_offer_ingestWhereUniqueInput = Prisma.AtLeast<{
    offer_fingerprint_bucket_5m_time?: raw_offer_ingestOffer_fingerprintBucket_5mTimeCompoundUniqueInput
    AND?: raw_offer_ingestWhereInput | raw_offer_ingestWhereInput[]
    OR?: raw_offer_ingestWhereInput[]
    NOT?: raw_offer_ingestWhereInput | raw_offer_ingestWhereInput[]
    time?: DateTimeFilter<"raw_offer_ingest"> | Date | string
    bucket_5m?: DateTimeFilter<"raw_offer_ingest"> | Date | string
    group_id?: StringNullableFilter<"raw_offer_ingest"> | string | null
    item_url?: StringNullableFilter<"raw_offer_ingest"> | string | null
    item_type?: StringNullableFilter<"raw_offer_ingest"> | string | null
    retailer_name?: StringNullableFilter<"raw_offer_ingest"> | string | null
    offer_url?: StringNullableFilter<"raw_offer_ingest"> | string | null
    price?: FloatNullableFilter<"raw_offer_ingest"> | number | null
    shipping_text?: StringNullableFilter<"raw_offer_ingest"> | string | null
    shipping_cost?: FloatNullableFilter<"raw_offer_ingest"> | number | null
    total?: FloatNullableFilter<"raw_offer_ingest"> | number | null
    in_stock?: BoolNullableFilter<"raw_offer_ingest"> | boolean | null
    source?: StringNullableFilter<"raw_offer_ingest"> | string | null
    offer_fingerprint?: StringFilter<"raw_offer_ingest"> | string
  }, "offer_fingerprint_bucket_5m_time">

  export type raw_offer_ingestOrderByWithAggregationInput = {
    time?: SortOrder
    bucket_5m?: SortOrder
    group_id?: SortOrderInput | SortOrder
    item_url?: SortOrderInput | SortOrder
    item_type?: SortOrderInput | SortOrder
    retailer_name?: SortOrderInput | SortOrder
    offer_url?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    shipping_text?: SortOrderInput | SortOrder
    shipping_cost?: SortOrderInput | SortOrder
    total?: SortOrderInput | SortOrder
    in_stock?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    offer_fingerprint?: SortOrder
    _count?: raw_offer_ingestCountOrderByAggregateInput
    _avg?: raw_offer_ingestAvgOrderByAggregateInput
    _max?: raw_offer_ingestMaxOrderByAggregateInput
    _min?: raw_offer_ingestMinOrderByAggregateInput
    _sum?: raw_offer_ingestSumOrderByAggregateInput
  }

  export type raw_offer_ingestScalarWhereWithAggregatesInput = {
    AND?: raw_offer_ingestScalarWhereWithAggregatesInput | raw_offer_ingestScalarWhereWithAggregatesInput[]
    OR?: raw_offer_ingestScalarWhereWithAggregatesInput[]
    NOT?: raw_offer_ingestScalarWhereWithAggregatesInput | raw_offer_ingestScalarWhereWithAggregatesInput[]
    time?: DateTimeWithAggregatesFilter<"raw_offer_ingest"> | Date | string
    bucket_5m?: DateTimeWithAggregatesFilter<"raw_offer_ingest"> | Date | string
    group_id?: StringNullableWithAggregatesFilter<"raw_offer_ingest"> | string | null
    item_url?: StringNullableWithAggregatesFilter<"raw_offer_ingest"> | string | null
    item_type?: StringNullableWithAggregatesFilter<"raw_offer_ingest"> | string | null
    retailer_name?: StringNullableWithAggregatesFilter<"raw_offer_ingest"> | string | null
    offer_url?: StringNullableWithAggregatesFilter<"raw_offer_ingest"> | string | null
    price?: FloatNullableWithAggregatesFilter<"raw_offer_ingest"> | number | null
    shipping_text?: StringNullableWithAggregatesFilter<"raw_offer_ingest"> | string | null
    shipping_cost?: FloatNullableWithAggregatesFilter<"raw_offer_ingest"> | number | null
    total?: FloatNullableWithAggregatesFilter<"raw_offer_ingest"> | number | null
    in_stock?: BoolNullableWithAggregatesFilter<"raw_offer_ingest"> | boolean | null
    source?: StringNullableWithAggregatesFilter<"raw_offer_ingest"> | string | null
    offer_fingerprint?: StringWithAggregatesFilter<"raw_offer_ingest"> | string
  }

  export type BrandCreateInput = {
    name: string
    slug: string
    website?: string | null
    logo?: string | null
    description?: string | null
    CatalogItem?: CatalogItemCreateNestedManyWithoutBrandInput
  }

  export type BrandUncheckedCreateInput = {
    id?: number
    name: string
    slug: string
    website?: string | null
    logo?: string | null
    description?: string | null
    CatalogItem?: CatalogItemUncheckedCreateNestedManyWithoutBrandInput
  }

  export type BrandUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    CatalogItem?: CatalogItemUpdateManyWithoutBrandNestedInput
  }

  export type BrandUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    CatalogItem?: CatalogItemUncheckedUpdateManyWithoutBrandNestedInput
  }

  export type BrandCreateManyInput = {
    id?: number
    name: string
    slug: string
    website?: string | null
    logo?: string | null
    description?: string | null
  }

  export type BrandUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BrandUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CaliberCreateInput = {
    name: string
    slug: string
    type?: string | null
    Alert?: AlertCreateNestedManyWithoutCaliberInput
    AmmoSpecs?: AmmoSpecsCreateNestedManyWithoutCaliberInput
    CaliberAlias?: CaliberAliasCreateNestedManyWithoutCaliberInput
    FirearmChamber?: FirearmChamberCreateNestedManyWithoutCaliberInput
  }

  export type CaliberUncheckedCreateInput = {
    id?: number
    name: string
    slug: string
    type?: string | null
    Alert?: AlertUncheckedCreateNestedManyWithoutCaliberInput
    AmmoSpecs?: AmmoSpecsUncheckedCreateNestedManyWithoutCaliberInput
    CaliberAlias?: CaliberAliasUncheckedCreateNestedManyWithoutCaliberInput
    FirearmChamber?: FirearmChamberUncheckedCreateNestedManyWithoutCaliberInput
  }

  export type CaliberUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    Alert?: AlertUpdateManyWithoutCaliberNestedInput
    AmmoSpecs?: AmmoSpecsUpdateManyWithoutCaliberNestedInput
    CaliberAlias?: CaliberAliasUpdateManyWithoutCaliberNestedInput
    FirearmChamber?: FirearmChamberUpdateManyWithoutCaliberNestedInput
  }

  export type CaliberUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    Alert?: AlertUncheckedUpdateManyWithoutCaliberNestedInput
    AmmoSpecs?: AmmoSpecsUncheckedUpdateManyWithoutCaliberNestedInput
    CaliberAlias?: CaliberAliasUncheckedUpdateManyWithoutCaliberNestedInput
    FirearmChamber?: FirearmChamberUncheckedUpdateManyWithoutCaliberNestedInput
  }

  export type CaliberCreateManyInput = {
    id?: number
    name: string
    slug: string
    type?: string | null
  }

  export type CaliberUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CaliberUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OfferCreateInput = {
    url: string
    inStock?: boolean | null
    price: number
    currency?: string | null
    shippingCost?: number | null
    total?: number | null
    freeShipping?: boolean | null
    shippingNote?: string | null
    shippingUpdatedAt?: Date | string | null
    unitsCount?: number | null
    unitLabel?: string | null
    unitPrice?: number | null
    totalUnitPrice?: number | null
    retailerSku?: string | null
    isManuallyOOS?: boolean | null
    oosReportCount?: number | null
    lastStockChange?: Date | string | null
    lastSeen?: Date | string | null
    AlertDelivery?: AlertDeliveryCreateNestedManyWithoutOfferInput
    CatalogItem: CatalogItemCreateNestedOneWithoutOfferInput
    retailer: RetailerCreateNestedOneWithoutOffersInput
  }

  export type OfferUncheckedCreateInput = {
    id?: number
    itemId: string
    retailerId: number
    url: string
    inStock?: boolean | null
    price: number
    currency?: string | null
    shippingCost?: number | null
    total?: number | null
    freeShipping?: boolean | null
    shippingNote?: string | null
    shippingUpdatedAt?: Date | string | null
    unitsCount?: number | null
    unitLabel?: string | null
    unitPrice?: number | null
    totalUnitPrice?: number | null
    retailerSku?: string | null
    isManuallyOOS?: boolean | null
    oosReportCount?: number | null
    lastStockChange?: Date | string | null
    lastSeen?: Date | string | null
    AlertDelivery?: AlertDeliveryUncheckedCreateNestedManyWithoutOfferInput
  }

  export type OfferUpdateInput = {
    url?: StringFieldUpdateOperationsInput | string
    inStock?: NullableBoolFieldUpdateOperationsInput | boolean | null
    price?: FloatFieldUpdateOperationsInput | number
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    shippingCost?: NullableFloatFieldUpdateOperationsInput | number | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    freeShipping?: NullableBoolFieldUpdateOperationsInput | boolean | null
    shippingNote?: NullableStringFieldUpdateOperationsInput | string | null
    shippingUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unitsCount?: NullableIntFieldUpdateOperationsInput | number | null
    unitLabel?: NullableStringFieldUpdateOperationsInput | string | null
    unitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    totalUnitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    retailerSku?: NullableStringFieldUpdateOperationsInput | string | null
    isManuallyOOS?: NullableBoolFieldUpdateOperationsInput | boolean | null
    oosReportCount?: NullableIntFieldUpdateOperationsInput | number | null
    lastStockChange?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    AlertDelivery?: AlertDeliveryUpdateManyWithoutOfferNestedInput
    CatalogItem?: CatalogItemUpdateOneRequiredWithoutOfferNestedInput
    retailer?: RetailerUpdateOneRequiredWithoutOffersNestedInput
  }

  export type OfferUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemId?: StringFieldUpdateOperationsInput | string
    retailerId?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    inStock?: NullableBoolFieldUpdateOperationsInput | boolean | null
    price?: FloatFieldUpdateOperationsInput | number
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    shippingCost?: NullableFloatFieldUpdateOperationsInput | number | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    freeShipping?: NullableBoolFieldUpdateOperationsInput | boolean | null
    shippingNote?: NullableStringFieldUpdateOperationsInput | string | null
    shippingUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unitsCount?: NullableIntFieldUpdateOperationsInput | number | null
    unitLabel?: NullableStringFieldUpdateOperationsInput | string | null
    unitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    totalUnitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    retailerSku?: NullableStringFieldUpdateOperationsInput | string | null
    isManuallyOOS?: NullableBoolFieldUpdateOperationsInput | boolean | null
    oosReportCount?: NullableIntFieldUpdateOperationsInput | number | null
    lastStockChange?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    AlertDelivery?: AlertDeliveryUncheckedUpdateManyWithoutOfferNestedInput
  }

  export type OfferCreateManyInput = {
    id?: number
    itemId: string
    retailerId: number
    url: string
    inStock?: boolean | null
    price: number
    currency?: string | null
    shippingCost?: number | null
    total?: number | null
    freeShipping?: boolean | null
    shippingNote?: string | null
    shippingUpdatedAt?: Date | string | null
    unitsCount?: number | null
    unitLabel?: string | null
    unitPrice?: number | null
    totalUnitPrice?: number | null
    retailerSku?: string | null
    isManuallyOOS?: boolean | null
    oosReportCount?: number | null
    lastStockChange?: Date | string | null
    lastSeen?: Date | string | null
  }

  export type OfferUpdateManyMutationInput = {
    url?: StringFieldUpdateOperationsInput | string
    inStock?: NullableBoolFieldUpdateOperationsInput | boolean | null
    price?: FloatFieldUpdateOperationsInput | number
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    shippingCost?: NullableFloatFieldUpdateOperationsInput | number | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    freeShipping?: NullableBoolFieldUpdateOperationsInput | boolean | null
    shippingNote?: NullableStringFieldUpdateOperationsInput | string | null
    shippingUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unitsCount?: NullableIntFieldUpdateOperationsInput | number | null
    unitLabel?: NullableStringFieldUpdateOperationsInput | string | null
    unitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    totalUnitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    retailerSku?: NullableStringFieldUpdateOperationsInput | string | null
    isManuallyOOS?: NullableBoolFieldUpdateOperationsInput | boolean | null
    oosReportCount?: NullableIntFieldUpdateOperationsInput | number | null
    lastStockChange?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OfferUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemId?: StringFieldUpdateOperationsInput | string
    retailerId?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    inStock?: NullableBoolFieldUpdateOperationsInput | boolean | null
    price?: FloatFieldUpdateOperationsInput | number
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    shippingCost?: NullableFloatFieldUpdateOperationsInput | number | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    freeShipping?: NullableBoolFieldUpdateOperationsInput | boolean | null
    shippingNote?: NullableStringFieldUpdateOperationsInput | string | null
    shippingUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unitsCount?: NullableIntFieldUpdateOperationsInput | number | null
    unitLabel?: NullableStringFieldUpdateOperationsInput | string | null
    unitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    totalUnitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    retailerSku?: NullableStringFieldUpdateOperationsInput | string | null
    isManuallyOOS?: NullableBoolFieldUpdateOperationsInput | boolean | null
    oosReportCount?: NullableIntFieldUpdateOperationsInput | number | null
    lastStockChange?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RetailerCreateInput = {
    name: string
    domain?: string | null
    logo?: string | null
    rating?: number | null
    shippingRating?: number | null
    BlockedRetailer?: BlockedRetailerCreateNestedManyWithoutRetailerInput
    offers?: OfferCreateNestedManyWithoutRetailerInput
  }

  export type RetailerUncheckedCreateInput = {
    id?: number
    name: string
    domain?: string | null
    logo?: string | null
    rating?: number | null
    shippingRating?: number | null
    BlockedRetailer?: BlockedRetailerUncheckedCreateNestedManyWithoutRetailerInput
    offers?: OfferUncheckedCreateNestedManyWithoutRetailerInput
  }

  export type RetailerUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    shippingRating?: NullableIntFieldUpdateOperationsInput | number | null
    BlockedRetailer?: BlockedRetailerUpdateManyWithoutRetailerNestedInput
    offers?: OfferUpdateManyWithoutRetailerNestedInput
  }

  export type RetailerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    shippingRating?: NullableIntFieldUpdateOperationsInput | number | null
    BlockedRetailer?: BlockedRetailerUncheckedUpdateManyWithoutRetailerNestedInput
    offers?: OfferUncheckedUpdateManyWithoutRetailerNestedInput
  }

  export type RetailerCreateManyInput = {
    id?: number
    name: string
    domain?: string | null
    logo?: string | null
    rating?: number | null
    shippingRating?: number | null
  }

  export type RetailerUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    shippingRating?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RetailerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    shippingRating?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AccessoryFitmentCreateInput = {
    fitmentType: $Enums.FitmentType
    platform?: string | null
    note?: string | null
    AccessorySpecs: AccessorySpecsCreateNestedOneWithoutAccessoryFitmentInput
    CatalogItem?: CatalogItemCreateNestedOneWithoutAccessoryFitmentInput
  }

  export type AccessoryFitmentUncheckedCreateInput = {
    id?: number
    accessorySpecsId: number
    fitmentType: $Enums.FitmentType
    firearmItemId?: string | null
    platform?: string | null
    note?: string | null
  }

  export type AccessoryFitmentUpdateInput = {
    fitmentType?: EnumFitmentTypeFieldUpdateOperationsInput | $Enums.FitmentType
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    AccessorySpecs?: AccessorySpecsUpdateOneRequiredWithoutAccessoryFitmentNestedInput
    CatalogItem?: CatalogItemUpdateOneWithoutAccessoryFitmentNestedInput
  }

  export type AccessoryFitmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    accessorySpecsId?: IntFieldUpdateOperationsInput | number
    fitmentType?: EnumFitmentTypeFieldUpdateOperationsInput | $Enums.FitmentType
    firearmItemId?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccessoryFitmentCreateManyInput = {
    id?: number
    accessorySpecsId: number
    fitmentType: $Enums.FitmentType
    firearmItemId?: string | null
    platform?: string | null
    note?: string | null
  }

  export type AccessoryFitmentUpdateManyMutationInput = {
    fitmentType?: EnumFitmentTypeFieldUpdateOperationsInput | $Enums.FitmentType
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccessoryFitmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    accessorySpecsId?: IntFieldUpdateOperationsInput | number
    fitmentType?: EnumFitmentTypeFieldUpdateOperationsInput | $Enums.FitmentType
    firearmItemId?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccessorySpecsCreateInput = {
    material?: string | null
    color?: string | null
    notes?: string | null
    AccessoryFitment?: AccessoryFitmentCreateNestedManyWithoutAccessorySpecsInput
    AccessoryType?: AccessoryTypeCreateNestedOneWithoutAccessorySpecsInput
    CatalogItem: CatalogItemCreateNestedOneWithoutAccessorySpecsInput
  }

  export type AccessorySpecsUncheckedCreateInput = {
    id?: number
    itemId: string
    accessoryTypeId?: number | null
    material?: string | null
    color?: string | null
    notes?: string | null
    AccessoryFitment?: AccessoryFitmentUncheckedCreateNestedManyWithoutAccessorySpecsInput
  }

  export type AccessorySpecsUpdateInput = {
    material?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    AccessoryFitment?: AccessoryFitmentUpdateManyWithoutAccessorySpecsNestedInput
    AccessoryType?: AccessoryTypeUpdateOneWithoutAccessorySpecsNestedInput
    CatalogItem?: CatalogItemUpdateOneRequiredWithoutAccessorySpecsNestedInput
  }

  export type AccessorySpecsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemId?: StringFieldUpdateOperationsInput | string
    accessoryTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    AccessoryFitment?: AccessoryFitmentUncheckedUpdateManyWithoutAccessorySpecsNestedInput
  }

  export type AccessorySpecsCreateManyInput = {
    id?: number
    itemId: string
    accessoryTypeId?: number | null
    material?: string | null
    color?: string | null
    notes?: string | null
  }

  export type AccessorySpecsUpdateManyMutationInput = {
    material?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccessorySpecsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemId?: StringFieldUpdateOperationsInput | string
    accessoryTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccessoryTypeCreateInput = {
    name: string
    slug: string
    AccessorySpecs?: AccessorySpecsCreateNestedManyWithoutAccessoryTypeInput
  }

  export type AccessoryTypeUncheckedCreateInput = {
    id?: number
    name: string
    slug: string
    AccessorySpecs?: AccessorySpecsUncheckedCreateNestedManyWithoutAccessoryTypeInput
  }

  export type AccessoryTypeUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    AccessorySpecs?: AccessorySpecsUpdateManyWithoutAccessoryTypeNestedInput
  }

  export type AccessoryTypeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    AccessorySpecs?: AccessorySpecsUncheckedUpdateManyWithoutAccessoryTypeNestedInput
  }

  export type AccessoryTypeCreateManyInput = {
    id?: number
    name: string
    slug: string
  }

  export type AccessoryTypeUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type AccessoryTypeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type AlertCreateInput = {
    id: string
    type: $Enums.AlertType
    keyword?: string | null
    targetCpr?: number | null
    excludeSteel?: boolean | null
    excludeReman?: boolean | null
    lastTriggered?: Date | string | null
    isActive?: boolean | null
    createdAt?: Date | string | null
    Caliber?: CaliberCreateNestedOneWithoutAlertInput
    CatalogItem?: CatalogItemCreateNestedOneWithoutAlertInput
    User: UserCreateNestedOneWithoutAlertInput
    AlertDelivery?: AlertDeliveryCreateNestedManyWithoutAlertInput
  }

  export type AlertUncheckedCreateInput = {
    id: string
    userId: string
    type: $Enums.AlertType
    calId?: number | null
    itemId?: string | null
    keyword?: string | null
    targetCpr?: number | null
    excludeSteel?: boolean | null
    excludeReman?: boolean | null
    lastTriggered?: Date | string | null
    isActive?: boolean | null
    createdAt?: Date | string | null
    AlertDelivery?: AlertDeliveryUncheckedCreateNestedManyWithoutAlertInput
  }

  export type AlertUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAlertTypeFieldUpdateOperationsInput | $Enums.AlertType
    keyword?: NullableStringFieldUpdateOperationsInput | string | null
    targetCpr?: NullableFloatFieldUpdateOperationsInput | number | null
    excludeSteel?: NullableBoolFieldUpdateOperationsInput | boolean | null
    excludeReman?: NullableBoolFieldUpdateOperationsInput | boolean | null
    lastTriggered?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Caliber?: CaliberUpdateOneWithoutAlertNestedInput
    CatalogItem?: CatalogItemUpdateOneWithoutAlertNestedInput
    User?: UserUpdateOneRequiredWithoutAlertNestedInput
    AlertDelivery?: AlertDeliveryUpdateManyWithoutAlertNestedInput
  }

  export type AlertUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumAlertTypeFieldUpdateOperationsInput | $Enums.AlertType
    calId?: NullableIntFieldUpdateOperationsInput | number | null
    itemId?: NullableStringFieldUpdateOperationsInput | string | null
    keyword?: NullableStringFieldUpdateOperationsInput | string | null
    targetCpr?: NullableFloatFieldUpdateOperationsInput | number | null
    excludeSteel?: NullableBoolFieldUpdateOperationsInput | boolean | null
    excludeReman?: NullableBoolFieldUpdateOperationsInput | boolean | null
    lastTriggered?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    AlertDelivery?: AlertDeliveryUncheckedUpdateManyWithoutAlertNestedInput
  }

  export type AlertCreateManyInput = {
    id: string
    userId: string
    type: $Enums.AlertType
    calId?: number | null
    itemId?: string | null
    keyword?: string | null
    targetCpr?: number | null
    excludeSteel?: boolean | null
    excludeReman?: boolean | null
    lastTriggered?: Date | string | null
    isActive?: boolean | null
    createdAt?: Date | string | null
  }

  export type AlertUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAlertTypeFieldUpdateOperationsInput | $Enums.AlertType
    keyword?: NullableStringFieldUpdateOperationsInput | string | null
    targetCpr?: NullableFloatFieldUpdateOperationsInput | number | null
    excludeSteel?: NullableBoolFieldUpdateOperationsInput | boolean | null
    excludeReman?: NullableBoolFieldUpdateOperationsInput | boolean | null
    lastTriggered?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AlertUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumAlertTypeFieldUpdateOperationsInput | $Enums.AlertType
    calId?: NullableIntFieldUpdateOperationsInput | number | null
    itemId?: NullableStringFieldUpdateOperationsInput | string | null
    keyword?: NullableStringFieldUpdateOperationsInput | string | null
    targetCpr?: NullableFloatFieldUpdateOperationsInput | number | null
    excludeSteel?: NullableBoolFieldUpdateOperationsInput | boolean | null
    excludeReman?: NullableBoolFieldUpdateOperationsInput | boolean | null
    lastTriggered?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AlertDeliveryCreateInput = {
    id: string
    sentAt?: Date | string | null
    fingerprint: string
    Alert: AlertCreateNestedOneWithoutAlertDeliveryInput
    Offer?: OfferCreateNestedOneWithoutAlertDeliveryInput
    User: UserCreateNestedOneWithoutAlertDeliveryInput
  }

  export type AlertDeliveryUncheckedCreateInput = {
    id: string
    alertId: string
    offerId?: number | null
    sentAt?: Date | string | null
    fingerprint: string
    userId: string
  }

  export type AlertDeliveryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fingerprint?: StringFieldUpdateOperationsInput | string
    Alert?: AlertUpdateOneRequiredWithoutAlertDeliveryNestedInput
    Offer?: OfferUpdateOneWithoutAlertDeliveryNestedInput
    User?: UserUpdateOneRequiredWithoutAlertDeliveryNestedInput
  }

  export type AlertDeliveryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    alertId?: StringFieldUpdateOperationsInput | string
    offerId?: NullableIntFieldUpdateOperationsInput | number | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fingerprint?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type AlertDeliveryCreateManyInput = {
    id: string
    alertId: string
    offerId?: number | null
    sentAt?: Date | string | null
    fingerprint: string
    userId: string
  }

  export type AlertDeliveryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fingerprint?: StringFieldUpdateOperationsInput | string
  }

  export type AlertDeliveryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    alertId?: StringFieldUpdateOperationsInput | string
    offerId?: NullableIntFieldUpdateOperationsInput | number | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fingerprint?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type AmmoSpecsCreateInput = {
    grain?: number | null
    gauge?: string | null
    velocity?: number | null
    energy?: number | null
    casing?: string | null
    bulletType?: string | null
    restrictions?: AmmoSpecsCreaterestrictionsInput | string[]
    pressure?: $Enums.AmmoPressure | null
    isSteelCase?: boolean | null
    isRemanufactured?: boolean | null
    isSubsonic?: boolean | null
    Caliber: CaliberCreateNestedOneWithoutAmmoSpecsInput
    CatalogItem: CatalogItemCreateNestedOneWithoutAmmoSpecsInput
  }

  export type AmmoSpecsUncheckedCreateInput = {
    id?: number
    itemId: string
    caliberId: number
    grain?: number | null
    gauge?: string | null
    velocity?: number | null
    energy?: number | null
    casing?: string | null
    bulletType?: string | null
    restrictions?: AmmoSpecsCreaterestrictionsInput | string[]
    pressure?: $Enums.AmmoPressure | null
    isSteelCase?: boolean | null
    isRemanufactured?: boolean | null
    isSubsonic?: boolean | null
  }

  export type AmmoSpecsUpdateInput = {
    grain?: NullableIntFieldUpdateOperationsInput | number | null
    gauge?: NullableStringFieldUpdateOperationsInput | string | null
    velocity?: NullableIntFieldUpdateOperationsInput | number | null
    energy?: NullableIntFieldUpdateOperationsInput | number | null
    casing?: NullableStringFieldUpdateOperationsInput | string | null
    bulletType?: NullableStringFieldUpdateOperationsInput | string | null
    restrictions?: AmmoSpecsUpdaterestrictionsInput | string[]
    pressure?: NullableEnumAmmoPressureFieldUpdateOperationsInput | $Enums.AmmoPressure | null
    isSteelCase?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isRemanufactured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isSubsonic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Caliber?: CaliberUpdateOneRequiredWithoutAmmoSpecsNestedInput
    CatalogItem?: CatalogItemUpdateOneRequiredWithoutAmmoSpecsNestedInput
  }

  export type AmmoSpecsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemId?: StringFieldUpdateOperationsInput | string
    caliberId?: IntFieldUpdateOperationsInput | number
    grain?: NullableIntFieldUpdateOperationsInput | number | null
    gauge?: NullableStringFieldUpdateOperationsInput | string | null
    velocity?: NullableIntFieldUpdateOperationsInput | number | null
    energy?: NullableIntFieldUpdateOperationsInput | number | null
    casing?: NullableStringFieldUpdateOperationsInput | string | null
    bulletType?: NullableStringFieldUpdateOperationsInput | string | null
    restrictions?: AmmoSpecsUpdaterestrictionsInput | string[]
    pressure?: NullableEnumAmmoPressureFieldUpdateOperationsInput | $Enums.AmmoPressure | null
    isSteelCase?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isRemanufactured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isSubsonic?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type AmmoSpecsCreateManyInput = {
    id?: number
    itemId: string
    caliberId: number
    grain?: number | null
    gauge?: string | null
    velocity?: number | null
    energy?: number | null
    casing?: string | null
    bulletType?: string | null
    restrictions?: AmmoSpecsCreaterestrictionsInput | string[]
    pressure?: $Enums.AmmoPressure | null
    isSteelCase?: boolean | null
    isRemanufactured?: boolean | null
    isSubsonic?: boolean | null
  }

  export type AmmoSpecsUpdateManyMutationInput = {
    grain?: NullableIntFieldUpdateOperationsInput | number | null
    gauge?: NullableStringFieldUpdateOperationsInput | string | null
    velocity?: NullableIntFieldUpdateOperationsInput | number | null
    energy?: NullableIntFieldUpdateOperationsInput | number | null
    casing?: NullableStringFieldUpdateOperationsInput | string | null
    bulletType?: NullableStringFieldUpdateOperationsInput | string | null
    restrictions?: AmmoSpecsUpdaterestrictionsInput | string[]
    pressure?: NullableEnumAmmoPressureFieldUpdateOperationsInput | $Enums.AmmoPressure | null
    isSteelCase?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isRemanufactured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isSubsonic?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type AmmoSpecsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemId?: StringFieldUpdateOperationsInput | string
    caliberId?: IntFieldUpdateOperationsInput | number
    grain?: NullableIntFieldUpdateOperationsInput | number | null
    gauge?: NullableStringFieldUpdateOperationsInput | string | null
    velocity?: NullableIntFieldUpdateOperationsInput | number | null
    energy?: NullableIntFieldUpdateOperationsInput | number | null
    casing?: NullableStringFieldUpdateOperationsInput | string | null
    bulletType?: NullableStringFieldUpdateOperationsInput | string | null
    restrictions?: AmmoSpecsUpdaterestrictionsInput | string[]
    pressure?: NullableEnumAmmoPressureFieldUpdateOperationsInput | $Enums.AmmoPressure | null
    isSteelCase?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isRemanufactured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isSubsonic?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type BlockedRetailerCreateInput = {
    id: string
    createdAt?: Date | string | null
    Retailer: RetailerCreateNestedOneWithoutBlockedRetailerInput
    User: UserCreateNestedOneWithoutBlockedRetailerInput
  }

  export type BlockedRetailerUncheckedCreateInput = {
    id: string
    userId: string
    retailerId: number
    createdAt?: Date | string | null
  }

  export type BlockedRetailerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Retailer?: RetailerUpdateOneRequiredWithoutBlockedRetailerNestedInput
    User?: UserUpdateOneRequiredWithoutBlockedRetailerNestedInput
  }

  export type BlockedRetailerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    retailerId?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BlockedRetailerCreateManyInput = {
    id: string
    userId: string
    retailerId: number
    createdAt?: Date | string | null
  }

  export type BlockedRetailerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BlockedRetailerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    retailerId?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CaliberAliasCreateInput = {
    alias: string
    Caliber: CaliberCreateNestedOneWithoutCaliberAliasInput
  }

  export type CaliberAliasUncheckedCreateInput = {
    id?: number
    caliberId: number
    alias: string
  }

  export type CaliberAliasUpdateInput = {
    alias?: StringFieldUpdateOperationsInput | string
    Caliber?: CaliberUpdateOneRequiredWithoutCaliberAliasNestedInput
  }

  export type CaliberAliasUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    caliberId?: IntFieldUpdateOperationsInput | number
    alias?: StringFieldUpdateOperationsInput | string
  }

  export type CaliberAliasCreateManyInput = {
    id?: number
    caliberId: number
    alias: string
  }

  export type CaliberAliasUpdateManyMutationInput = {
    alias?: StringFieldUpdateOperationsInput | string
  }

  export type CaliberAliasUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    caliberId?: IntFieldUpdateOperationsInput | number
    alias?: StringFieldUpdateOperationsInput | string
  }

  export type CatalogItemCreateInput = {
    id: string
    kind: $Enums.CatalogKind
    slug: string
    upc?: string | null
    mpn?: string | null
    title: string
    image?: string | null
    description?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    bestPrice?: number | null
    bestRetailerId?: number | null
    bestRetailerName?: string | null
    offerCount?: number | null
    bestCpr?: number | null
    bestCprShipped?: number | null
    upvotes?: number | null
    downvotes?: number | null
    AccessoryFitment?: AccessoryFitmentCreateNestedManyWithoutCatalogItemInput
    AccessorySpecs?: AccessorySpecsCreateNestedOneWithoutCatalogItemInput
    Alert?: AlertCreateNestedManyWithoutCatalogItemInput
    AmmoSpecs?: AmmoSpecsCreateNestedOneWithoutCatalogItemInput
    Brand?: BrandCreateNestedOneWithoutCatalogItemInput
    FirearmSpecs?: FirearmSpecsCreateNestedOneWithoutCatalogItemInput
    Offer?: OfferCreateNestedManyWithoutCatalogItemInput
    OwnedFirearm?: OwnedFirearmCreateNestedManyWithoutCatalogItemInput
  }

  export type CatalogItemUncheckedCreateInput = {
    id: string
    kind: $Enums.CatalogKind
    slug: string
    upc?: string | null
    mpn?: string | null
    title: string
    image?: string | null
    description?: string | null
    brandId?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    bestPrice?: number | null
    bestRetailerId?: number | null
    bestRetailerName?: string | null
    offerCount?: number | null
    bestCpr?: number | null
    bestCprShipped?: number | null
    upvotes?: number | null
    downvotes?: number | null
    AccessoryFitment?: AccessoryFitmentUncheckedCreateNestedManyWithoutCatalogItemInput
    AccessorySpecs?: AccessorySpecsUncheckedCreateNestedOneWithoutCatalogItemInput
    Alert?: AlertUncheckedCreateNestedManyWithoutCatalogItemInput
    AmmoSpecs?: AmmoSpecsUncheckedCreateNestedOneWithoutCatalogItemInput
    FirearmSpecs?: FirearmSpecsUncheckedCreateNestedOneWithoutCatalogItemInput
    Offer?: OfferUncheckedCreateNestedManyWithoutCatalogItemInput
    OwnedFirearm?: OwnedFirearmUncheckedCreateNestedManyWithoutCatalogItemInput
  }

  export type CatalogItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    kind?: EnumCatalogKindFieldUpdateOperationsInput | $Enums.CatalogKind
    slug?: StringFieldUpdateOperationsInput | string
    upc?: NullableStringFieldUpdateOperationsInput | string | null
    mpn?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bestPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    bestRetailerId?: NullableIntFieldUpdateOperationsInput | number | null
    bestRetailerName?: NullableStringFieldUpdateOperationsInput | string | null
    offerCount?: NullableIntFieldUpdateOperationsInput | number | null
    bestCpr?: NullableFloatFieldUpdateOperationsInput | number | null
    bestCprShipped?: NullableFloatFieldUpdateOperationsInput | number | null
    upvotes?: NullableIntFieldUpdateOperationsInput | number | null
    downvotes?: NullableIntFieldUpdateOperationsInput | number | null
    AccessoryFitment?: AccessoryFitmentUpdateManyWithoutCatalogItemNestedInput
    AccessorySpecs?: AccessorySpecsUpdateOneWithoutCatalogItemNestedInput
    Alert?: AlertUpdateManyWithoutCatalogItemNestedInput
    AmmoSpecs?: AmmoSpecsUpdateOneWithoutCatalogItemNestedInput
    Brand?: BrandUpdateOneWithoutCatalogItemNestedInput
    FirearmSpecs?: FirearmSpecsUpdateOneWithoutCatalogItemNestedInput
    Offer?: OfferUpdateManyWithoutCatalogItemNestedInput
    OwnedFirearm?: OwnedFirearmUpdateManyWithoutCatalogItemNestedInput
  }

  export type CatalogItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    kind?: EnumCatalogKindFieldUpdateOperationsInput | $Enums.CatalogKind
    slug?: StringFieldUpdateOperationsInput | string
    upc?: NullableStringFieldUpdateOperationsInput | string | null
    mpn?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    brandId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bestPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    bestRetailerId?: NullableIntFieldUpdateOperationsInput | number | null
    bestRetailerName?: NullableStringFieldUpdateOperationsInput | string | null
    offerCount?: NullableIntFieldUpdateOperationsInput | number | null
    bestCpr?: NullableFloatFieldUpdateOperationsInput | number | null
    bestCprShipped?: NullableFloatFieldUpdateOperationsInput | number | null
    upvotes?: NullableIntFieldUpdateOperationsInput | number | null
    downvotes?: NullableIntFieldUpdateOperationsInput | number | null
    AccessoryFitment?: AccessoryFitmentUncheckedUpdateManyWithoutCatalogItemNestedInput
    AccessorySpecs?: AccessorySpecsUncheckedUpdateOneWithoutCatalogItemNestedInput
    Alert?: AlertUncheckedUpdateManyWithoutCatalogItemNestedInput
    AmmoSpecs?: AmmoSpecsUncheckedUpdateOneWithoutCatalogItemNestedInput
    FirearmSpecs?: FirearmSpecsUncheckedUpdateOneWithoutCatalogItemNestedInput
    Offer?: OfferUncheckedUpdateManyWithoutCatalogItemNestedInput
    OwnedFirearm?: OwnedFirearmUncheckedUpdateManyWithoutCatalogItemNestedInput
  }

  export type CatalogItemCreateManyInput = {
    id: string
    kind: $Enums.CatalogKind
    slug: string
    upc?: string | null
    mpn?: string | null
    title: string
    image?: string | null
    description?: string | null
    brandId?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    bestPrice?: number | null
    bestRetailerId?: number | null
    bestRetailerName?: string | null
    offerCount?: number | null
    bestCpr?: number | null
    bestCprShipped?: number | null
    upvotes?: number | null
    downvotes?: number | null
  }

  export type CatalogItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    kind?: EnumCatalogKindFieldUpdateOperationsInput | $Enums.CatalogKind
    slug?: StringFieldUpdateOperationsInput | string
    upc?: NullableStringFieldUpdateOperationsInput | string | null
    mpn?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bestPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    bestRetailerId?: NullableIntFieldUpdateOperationsInput | number | null
    bestRetailerName?: NullableStringFieldUpdateOperationsInput | string | null
    offerCount?: NullableIntFieldUpdateOperationsInput | number | null
    bestCpr?: NullableFloatFieldUpdateOperationsInput | number | null
    bestCprShipped?: NullableFloatFieldUpdateOperationsInput | number | null
    upvotes?: NullableIntFieldUpdateOperationsInput | number | null
    downvotes?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CatalogItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    kind?: EnumCatalogKindFieldUpdateOperationsInput | $Enums.CatalogKind
    slug?: StringFieldUpdateOperationsInput | string
    upc?: NullableStringFieldUpdateOperationsInput | string | null
    mpn?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    brandId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bestPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    bestRetailerId?: NullableIntFieldUpdateOperationsInput | number | null
    bestRetailerName?: NullableStringFieldUpdateOperationsInput | string | null
    offerCount?: NullableIntFieldUpdateOperationsInput | number | null
    bestCpr?: NullableFloatFieldUpdateOperationsInput | number | null
    bestCprShipped?: NullableFloatFieldUpdateOperationsInput | number | null
    upvotes?: NullableIntFieldUpdateOperationsInput | number | null
    downvotes?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type FirearmCategoryCreateInput = {
    name: string
    slug: string
    FirearmSpecs?: FirearmSpecsCreateNestedManyWithoutFirearmCategoryInput
  }

  export type FirearmCategoryUncheckedCreateInput = {
    id?: number
    name: string
    slug: string
    FirearmSpecs?: FirearmSpecsUncheckedCreateNestedManyWithoutFirearmCategoryInput
  }

  export type FirearmCategoryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    FirearmSpecs?: FirearmSpecsUpdateManyWithoutFirearmCategoryNestedInput
  }

  export type FirearmCategoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    FirearmSpecs?: FirearmSpecsUncheckedUpdateManyWithoutFirearmCategoryNestedInput
  }

  export type FirearmCategoryCreateManyInput = {
    id?: number
    name: string
    slug: string
  }

  export type FirearmCategoryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type FirearmCategoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type FirearmChamberCreateInput = {
    note?: string | null
    Caliber: CaliberCreateNestedOneWithoutFirearmChamberInput
    FirearmSpecs: FirearmSpecsCreateNestedOneWithoutFirearmChamberInput
  }

  export type FirearmChamberUncheckedCreateInput = {
    firearmSpecsId: number
    caliberId: number
    note?: string | null
  }

  export type FirearmChamberUpdateInput = {
    note?: NullableStringFieldUpdateOperationsInput | string | null
    Caliber?: CaliberUpdateOneRequiredWithoutFirearmChamberNestedInput
    FirearmSpecs?: FirearmSpecsUpdateOneRequiredWithoutFirearmChamberNestedInput
  }

  export type FirearmChamberUncheckedUpdateInput = {
    firearmSpecsId?: IntFieldUpdateOperationsInput | number
    caliberId?: IntFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FirearmChamberCreateManyInput = {
    firearmSpecsId: number
    caliberId: number
    note?: string | null
  }

  export type FirearmChamberUpdateManyMutationInput = {
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FirearmChamberUncheckedUpdateManyInput = {
    firearmSpecsId?: IntFieldUpdateOperationsInput | number
    caliberId?: IntFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FirearmSpecsCreateInput = {
    manufacturer?: string | null
    model?: string | null
    platform?: string | null
    barrelLengthIn?: number | null
    actionType?: string | null
    isThreaded?: boolean | null
    pressureRating?: $Enums.FirearmPressureRating | null
    firearmType?: string | null
    capacity?: string | null
    finish?: string | null
    weight?: string | null
    overallLength?: string | null
    features?: string | null
    sight?: string | null
    safety?: string | null
    FirearmChamber?: FirearmChamberCreateNestedManyWithoutFirearmSpecsInput
    FirearmCategory?: FirearmCategoryCreateNestedOneWithoutFirearmSpecsInput
    CatalogItem: CatalogItemCreateNestedOneWithoutFirearmSpecsInput
  }

  export type FirearmSpecsUncheckedCreateInput = {
    id?: number
    itemId: string
    manufacturer?: string | null
    model?: string | null
    platform?: string | null
    firearmCategoryId?: number | null
    barrelLengthIn?: number | null
    actionType?: string | null
    isThreaded?: boolean | null
    pressureRating?: $Enums.FirearmPressureRating | null
    firearmType?: string | null
    capacity?: string | null
    finish?: string | null
    weight?: string | null
    overallLength?: string | null
    features?: string | null
    sight?: string | null
    safety?: string | null
    FirearmChamber?: FirearmChamberUncheckedCreateNestedManyWithoutFirearmSpecsInput
  }

  export type FirearmSpecsUpdateInput = {
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    barrelLengthIn?: NullableFloatFieldUpdateOperationsInput | number | null
    actionType?: NullableStringFieldUpdateOperationsInput | string | null
    isThreaded?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pressureRating?: NullableEnumFirearmPressureRatingFieldUpdateOperationsInput | $Enums.FirearmPressureRating | null
    firearmType?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableStringFieldUpdateOperationsInput | string | null
    finish?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableStringFieldUpdateOperationsInput | string | null
    overallLength?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableStringFieldUpdateOperationsInput | string | null
    sight?: NullableStringFieldUpdateOperationsInput | string | null
    safety?: NullableStringFieldUpdateOperationsInput | string | null
    FirearmChamber?: FirearmChamberUpdateManyWithoutFirearmSpecsNestedInput
    FirearmCategory?: FirearmCategoryUpdateOneWithoutFirearmSpecsNestedInput
    CatalogItem?: CatalogItemUpdateOneRequiredWithoutFirearmSpecsNestedInput
  }

  export type FirearmSpecsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemId?: StringFieldUpdateOperationsInput | string
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    firearmCategoryId?: NullableIntFieldUpdateOperationsInput | number | null
    barrelLengthIn?: NullableFloatFieldUpdateOperationsInput | number | null
    actionType?: NullableStringFieldUpdateOperationsInput | string | null
    isThreaded?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pressureRating?: NullableEnumFirearmPressureRatingFieldUpdateOperationsInput | $Enums.FirearmPressureRating | null
    firearmType?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableStringFieldUpdateOperationsInput | string | null
    finish?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableStringFieldUpdateOperationsInput | string | null
    overallLength?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableStringFieldUpdateOperationsInput | string | null
    sight?: NullableStringFieldUpdateOperationsInput | string | null
    safety?: NullableStringFieldUpdateOperationsInput | string | null
    FirearmChamber?: FirearmChamberUncheckedUpdateManyWithoutFirearmSpecsNestedInput
  }

  export type FirearmSpecsCreateManyInput = {
    id?: number
    itemId: string
    manufacturer?: string | null
    model?: string | null
    platform?: string | null
    firearmCategoryId?: number | null
    barrelLengthIn?: number | null
    actionType?: string | null
    isThreaded?: boolean | null
    pressureRating?: $Enums.FirearmPressureRating | null
    firearmType?: string | null
    capacity?: string | null
    finish?: string | null
    weight?: string | null
    overallLength?: string | null
    features?: string | null
    sight?: string | null
    safety?: string | null
  }

  export type FirearmSpecsUpdateManyMutationInput = {
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    barrelLengthIn?: NullableFloatFieldUpdateOperationsInput | number | null
    actionType?: NullableStringFieldUpdateOperationsInput | string | null
    isThreaded?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pressureRating?: NullableEnumFirearmPressureRatingFieldUpdateOperationsInput | $Enums.FirearmPressureRating | null
    firearmType?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableStringFieldUpdateOperationsInput | string | null
    finish?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableStringFieldUpdateOperationsInput | string | null
    overallLength?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableStringFieldUpdateOperationsInput | string | null
    sight?: NullableStringFieldUpdateOperationsInput | string | null
    safety?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FirearmSpecsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemId?: StringFieldUpdateOperationsInput | string
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    firearmCategoryId?: NullableIntFieldUpdateOperationsInput | number | null
    barrelLengthIn?: NullableFloatFieldUpdateOperationsInput | number | null
    actionType?: NullableStringFieldUpdateOperationsInput | string | null
    isThreaded?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pressureRating?: NullableEnumFirearmPressureRatingFieldUpdateOperationsInput | $Enums.FirearmPressureRating | null
    firearmType?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableStringFieldUpdateOperationsInput | string | null
    finish?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableStringFieldUpdateOperationsInput | string | null
    overallLength?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableStringFieldUpdateOperationsInput | string | null
    sight?: NullableStringFieldUpdateOperationsInput | string | null
    safety?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OwnedFirearmCreateInput = {
    id: string
    nickname?: string | null
    createdAt?: Date | string | null
    CatalogItem: CatalogItemCreateNestedOneWithoutOwnedFirearmInput
    User: UserCreateNestedOneWithoutOwnedFirearmInput
  }

  export type OwnedFirearmUncheckedCreateInput = {
    id: string
    userId: string
    firearmItemId: string
    nickname?: string | null
    createdAt?: Date | string | null
  }

  export type OwnedFirearmUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CatalogItem?: CatalogItemUpdateOneRequiredWithoutOwnedFirearmNestedInput
    User?: UserUpdateOneRequiredWithoutOwnedFirearmNestedInput
  }

  export type OwnedFirearmUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firearmItemId?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OwnedFirearmCreateManyInput = {
    id: string
    userId: string
    firearmItemId: string
    nickname?: string | null
    createdAt?: Date | string | null
  }

  export type OwnedFirearmUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OwnedFirearmUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firearmItemId?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserCreateInput = {
    id: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    Alert?: AlertCreateNestedManyWithoutUserInput
    AlertDelivery?: AlertDeliveryCreateNestedManyWithoutUserInput
    BlockedRetailer?: BlockedRetailerCreateNestedManyWithoutUserInput
    OwnedFirearm?: OwnedFirearmCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    Alert?: AlertUncheckedCreateNestedManyWithoutUserInput
    AlertDelivery?: AlertDeliveryUncheckedCreateNestedManyWithoutUserInput
    BlockedRetailer?: BlockedRetailerUncheckedCreateNestedManyWithoutUserInput
    OwnedFirearm?: OwnedFirearmUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Alert?: AlertUpdateManyWithoutUserNestedInput
    AlertDelivery?: AlertDeliveryUpdateManyWithoutUserNestedInput
    BlockedRetailer?: BlockedRetailerUpdateManyWithoutUserNestedInput
    OwnedFirearm?: OwnedFirearmUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Alert?: AlertUncheckedUpdateManyWithoutUserNestedInput
    AlertDelivery?: AlertDeliveryUncheckedUpdateManyWithoutUserNestedInput
    BlockedRetailer?: BlockedRetailerUncheckedUpdateManyWithoutUserNestedInput
    OwnedFirearm?: OwnedFirearmUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type raw_offer_ingestCreateInput = {
    time: Date | string
    bucket_5m: Date | string
    group_id?: string | null
    item_url?: string | null
    item_type?: string | null
    retailer_name?: string | null
    offer_url?: string | null
    price?: number | null
    shipping_text?: string | null
    shipping_cost?: number | null
    total?: number | null
    in_stock?: boolean | null
    source?: string | null
    offer_fingerprint: string
  }

  export type raw_offer_ingestUncheckedCreateInput = {
    time: Date | string
    bucket_5m: Date | string
    group_id?: string | null
    item_url?: string | null
    item_type?: string | null
    retailer_name?: string | null
    offer_url?: string | null
    price?: number | null
    shipping_text?: string | null
    shipping_cost?: number | null
    total?: number | null
    in_stock?: boolean | null
    source?: string | null
    offer_fingerprint: string
  }

  export type raw_offer_ingestUpdateInput = {
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    bucket_5m?: DateTimeFieldUpdateOperationsInput | Date | string
    group_id?: NullableStringFieldUpdateOperationsInput | string | null
    item_url?: NullableStringFieldUpdateOperationsInput | string | null
    item_type?: NullableStringFieldUpdateOperationsInput | string | null
    retailer_name?: NullableStringFieldUpdateOperationsInput | string | null
    offer_url?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    shipping_text?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_cost?: NullableFloatFieldUpdateOperationsInput | number | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    in_stock?: NullableBoolFieldUpdateOperationsInput | boolean | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    offer_fingerprint?: StringFieldUpdateOperationsInput | string
  }

  export type raw_offer_ingestUncheckedUpdateInput = {
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    bucket_5m?: DateTimeFieldUpdateOperationsInput | Date | string
    group_id?: NullableStringFieldUpdateOperationsInput | string | null
    item_url?: NullableStringFieldUpdateOperationsInput | string | null
    item_type?: NullableStringFieldUpdateOperationsInput | string | null
    retailer_name?: NullableStringFieldUpdateOperationsInput | string | null
    offer_url?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    shipping_text?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_cost?: NullableFloatFieldUpdateOperationsInput | number | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    in_stock?: NullableBoolFieldUpdateOperationsInput | boolean | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    offer_fingerprint?: StringFieldUpdateOperationsInput | string
  }

  export type raw_offer_ingestCreateManyInput = {
    time: Date | string
    bucket_5m: Date | string
    group_id?: string | null
    item_url?: string | null
    item_type?: string | null
    retailer_name?: string | null
    offer_url?: string | null
    price?: number | null
    shipping_text?: string | null
    shipping_cost?: number | null
    total?: number | null
    in_stock?: boolean | null
    source?: string | null
    offer_fingerprint: string
  }

  export type raw_offer_ingestUpdateManyMutationInput = {
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    bucket_5m?: DateTimeFieldUpdateOperationsInput | Date | string
    group_id?: NullableStringFieldUpdateOperationsInput | string | null
    item_url?: NullableStringFieldUpdateOperationsInput | string | null
    item_type?: NullableStringFieldUpdateOperationsInput | string | null
    retailer_name?: NullableStringFieldUpdateOperationsInput | string | null
    offer_url?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    shipping_text?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_cost?: NullableFloatFieldUpdateOperationsInput | number | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    in_stock?: NullableBoolFieldUpdateOperationsInput | boolean | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    offer_fingerprint?: StringFieldUpdateOperationsInput | string
  }

  export type raw_offer_ingestUncheckedUpdateManyInput = {
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    bucket_5m?: DateTimeFieldUpdateOperationsInput | Date | string
    group_id?: NullableStringFieldUpdateOperationsInput | string | null
    item_url?: NullableStringFieldUpdateOperationsInput | string | null
    item_type?: NullableStringFieldUpdateOperationsInput | string | null
    retailer_name?: NullableStringFieldUpdateOperationsInput | string | null
    offer_url?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    shipping_text?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_cost?: NullableFloatFieldUpdateOperationsInput | number | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    in_stock?: NullableBoolFieldUpdateOperationsInput | boolean | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    offer_fingerprint?: StringFieldUpdateOperationsInput | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type CatalogItemListRelationFilter = {
    every?: CatalogItemWhereInput
    some?: CatalogItemWhereInput
    none?: CatalogItemWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type CatalogItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BrandCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    website?: SortOrder
    logo?: SortOrder
    description?: SortOrder
  }

  export type BrandAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BrandMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    website?: SortOrder
    logo?: SortOrder
    description?: SortOrder
  }

  export type BrandMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    website?: SortOrder
    logo?: SortOrder
    description?: SortOrder
  }

  export type BrandSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type AlertListRelationFilter = {
    every?: AlertWhereInput
    some?: AlertWhereInput
    none?: AlertWhereInput
  }

  export type AmmoSpecsListRelationFilter = {
    every?: AmmoSpecsWhereInput
    some?: AmmoSpecsWhereInput
    none?: AmmoSpecsWhereInput
  }

  export type CaliberAliasListRelationFilter = {
    every?: CaliberAliasWhereInput
    some?: CaliberAliasWhereInput
    none?: CaliberAliasWhereInput
  }

  export type FirearmChamberListRelationFilter = {
    every?: FirearmChamberWhereInput
    some?: FirearmChamberWhereInput
    none?: FirearmChamberWhereInput
  }

  export type AlertOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AmmoSpecsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CaliberAliasOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FirearmChamberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CaliberCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    type?: SortOrder
  }

  export type CaliberAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CaliberMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    type?: SortOrder
  }

  export type CaliberMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    type?: SortOrder
  }

  export type CaliberSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type AlertDeliveryListRelationFilter = {
    every?: AlertDeliveryWhereInput
    some?: AlertDeliveryWhereInput
    none?: AlertDeliveryWhereInput
  }

  export type CatalogItemScalarRelationFilter = {
    is?: CatalogItemWhereInput
    isNot?: CatalogItemWhereInput
  }

  export type RetailerScalarRelationFilter = {
    is?: RetailerWhereInput
    isNot?: RetailerWhereInput
  }

  export type AlertDeliveryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OfferItemIdRetailerIdUnitsCountCurrencyCompoundUniqueInput = {
    itemId: string
    retailerId: number
    unitsCount: number
    currency: string
  }

  export type OfferCountOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    retailerId?: SortOrder
    url?: SortOrder
    inStock?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    shippingCost?: SortOrder
    total?: SortOrder
    freeShipping?: SortOrder
    shippingNote?: SortOrder
    shippingUpdatedAt?: SortOrder
    unitsCount?: SortOrder
    unitLabel?: SortOrder
    unitPrice?: SortOrder
    totalUnitPrice?: SortOrder
    retailerSku?: SortOrder
    isManuallyOOS?: SortOrder
    oosReportCount?: SortOrder
    lastStockChange?: SortOrder
    lastSeen?: SortOrder
  }

  export type OfferAvgOrderByAggregateInput = {
    id?: SortOrder
    retailerId?: SortOrder
    price?: SortOrder
    shippingCost?: SortOrder
    total?: SortOrder
    unitsCount?: SortOrder
    unitPrice?: SortOrder
    totalUnitPrice?: SortOrder
    oosReportCount?: SortOrder
  }

  export type OfferMaxOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    retailerId?: SortOrder
    url?: SortOrder
    inStock?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    shippingCost?: SortOrder
    total?: SortOrder
    freeShipping?: SortOrder
    shippingNote?: SortOrder
    shippingUpdatedAt?: SortOrder
    unitsCount?: SortOrder
    unitLabel?: SortOrder
    unitPrice?: SortOrder
    totalUnitPrice?: SortOrder
    retailerSku?: SortOrder
    isManuallyOOS?: SortOrder
    oosReportCount?: SortOrder
    lastStockChange?: SortOrder
    lastSeen?: SortOrder
  }

  export type OfferMinOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    retailerId?: SortOrder
    url?: SortOrder
    inStock?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    shippingCost?: SortOrder
    total?: SortOrder
    freeShipping?: SortOrder
    shippingNote?: SortOrder
    shippingUpdatedAt?: SortOrder
    unitsCount?: SortOrder
    unitLabel?: SortOrder
    unitPrice?: SortOrder
    totalUnitPrice?: SortOrder
    retailerSku?: SortOrder
    isManuallyOOS?: SortOrder
    oosReportCount?: SortOrder
    lastStockChange?: SortOrder
    lastSeen?: SortOrder
  }

  export type OfferSumOrderByAggregateInput = {
    id?: SortOrder
    retailerId?: SortOrder
    price?: SortOrder
    shippingCost?: SortOrder
    total?: SortOrder
    unitsCount?: SortOrder
    unitPrice?: SortOrder
    totalUnitPrice?: SortOrder
    oosReportCount?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type BlockedRetailerListRelationFilter = {
    every?: BlockedRetailerWhereInput
    some?: BlockedRetailerWhereInput
    none?: BlockedRetailerWhereInput
  }

  export type OfferListRelationFilter = {
    every?: OfferWhereInput
    some?: OfferWhereInput
    none?: OfferWhereInput
  }

  export type BlockedRetailerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OfferOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RetailerCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    domain?: SortOrder
    logo?: SortOrder
    rating?: SortOrder
    shippingRating?: SortOrder
  }

  export type RetailerAvgOrderByAggregateInput = {
    id?: SortOrder
    rating?: SortOrder
    shippingRating?: SortOrder
  }

  export type RetailerMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    domain?: SortOrder
    logo?: SortOrder
    rating?: SortOrder
    shippingRating?: SortOrder
  }

  export type RetailerMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    domain?: SortOrder
    logo?: SortOrder
    rating?: SortOrder
    shippingRating?: SortOrder
  }

  export type RetailerSumOrderByAggregateInput = {
    id?: SortOrder
    rating?: SortOrder
    shippingRating?: SortOrder
  }

  export type EnumFitmentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FitmentType | EnumFitmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FitmentType[] | ListEnumFitmentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FitmentType[] | ListEnumFitmentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFitmentTypeFilter<$PrismaModel> | $Enums.FitmentType
  }

  export type AccessorySpecsScalarRelationFilter = {
    is?: AccessorySpecsWhereInput
    isNot?: AccessorySpecsWhereInput
  }

  export type CatalogItemNullableScalarRelationFilter = {
    is?: CatalogItemWhereInput | null
    isNot?: CatalogItemWhereInput | null
  }

  export type AccessoryFitmentCountOrderByAggregateInput = {
    id?: SortOrder
    accessorySpecsId?: SortOrder
    fitmentType?: SortOrder
    firearmItemId?: SortOrder
    platform?: SortOrder
    note?: SortOrder
  }

  export type AccessoryFitmentAvgOrderByAggregateInput = {
    id?: SortOrder
    accessorySpecsId?: SortOrder
  }

  export type AccessoryFitmentMaxOrderByAggregateInput = {
    id?: SortOrder
    accessorySpecsId?: SortOrder
    fitmentType?: SortOrder
    firearmItemId?: SortOrder
    platform?: SortOrder
    note?: SortOrder
  }

  export type AccessoryFitmentMinOrderByAggregateInput = {
    id?: SortOrder
    accessorySpecsId?: SortOrder
    fitmentType?: SortOrder
    firearmItemId?: SortOrder
    platform?: SortOrder
    note?: SortOrder
  }

  export type AccessoryFitmentSumOrderByAggregateInput = {
    id?: SortOrder
    accessorySpecsId?: SortOrder
  }

  export type EnumFitmentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FitmentType | EnumFitmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FitmentType[] | ListEnumFitmentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FitmentType[] | ListEnumFitmentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFitmentTypeWithAggregatesFilter<$PrismaModel> | $Enums.FitmentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFitmentTypeFilter<$PrismaModel>
    _max?: NestedEnumFitmentTypeFilter<$PrismaModel>
  }

  export type AccessoryFitmentListRelationFilter = {
    every?: AccessoryFitmentWhereInput
    some?: AccessoryFitmentWhereInput
    none?: AccessoryFitmentWhereInput
  }

  export type AccessoryTypeNullableScalarRelationFilter = {
    is?: AccessoryTypeWhereInput | null
    isNot?: AccessoryTypeWhereInput | null
  }

  export type AccessoryFitmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccessorySpecsCountOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    accessoryTypeId?: SortOrder
    material?: SortOrder
    color?: SortOrder
    notes?: SortOrder
  }

  export type AccessorySpecsAvgOrderByAggregateInput = {
    id?: SortOrder
    accessoryTypeId?: SortOrder
  }

  export type AccessorySpecsMaxOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    accessoryTypeId?: SortOrder
    material?: SortOrder
    color?: SortOrder
    notes?: SortOrder
  }

  export type AccessorySpecsMinOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    accessoryTypeId?: SortOrder
    material?: SortOrder
    color?: SortOrder
    notes?: SortOrder
  }

  export type AccessorySpecsSumOrderByAggregateInput = {
    id?: SortOrder
    accessoryTypeId?: SortOrder
  }

  export type AccessorySpecsListRelationFilter = {
    every?: AccessorySpecsWhereInput
    some?: AccessorySpecsWhereInput
    none?: AccessorySpecsWhereInput
  }

  export type AccessorySpecsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccessoryTypeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
  }

  export type AccessoryTypeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AccessoryTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
  }

  export type AccessoryTypeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
  }

  export type AccessoryTypeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumAlertTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AlertType | EnumAlertTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AlertType[] | ListEnumAlertTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AlertType[] | ListEnumAlertTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAlertTypeFilter<$PrismaModel> | $Enums.AlertType
  }

  export type CaliberNullableScalarRelationFilter = {
    is?: CaliberWhereInput | null
    isNot?: CaliberWhereInput | null
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type AlertCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    calId?: SortOrder
    itemId?: SortOrder
    keyword?: SortOrder
    targetCpr?: SortOrder
    excludeSteel?: SortOrder
    excludeReman?: SortOrder
    lastTriggered?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type AlertAvgOrderByAggregateInput = {
    calId?: SortOrder
    targetCpr?: SortOrder
  }

  export type AlertMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    calId?: SortOrder
    itemId?: SortOrder
    keyword?: SortOrder
    targetCpr?: SortOrder
    excludeSteel?: SortOrder
    excludeReman?: SortOrder
    lastTriggered?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type AlertMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    calId?: SortOrder
    itemId?: SortOrder
    keyword?: SortOrder
    targetCpr?: SortOrder
    excludeSteel?: SortOrder
    excludeReman?: SortOrder
    lastTriggered?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type AlertSumOrderByAggregateInput = {
    calId?: SortOrder
    targetCpr?: SortOrder
  }

  export type EnumAlertTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AlertType | EnumAlertTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AlertType[] | ListEnumAlertTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AlertType[] | ListEnumAlertTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAlertTypeWithAggregatesFilter<$PrismaModel> | $Enums.AlertType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAlertTypeFilter<$PrismaModel>
    _max?: NestedEnumAlertTypeFilter<$PrismaModel>
  }

  export type AlertScalarRelationFilter = {
    is?: AlertWhereInput
    isNot?: AlertWhereInput
  }

  export type OfferNullableScalarRelationFilter = {
    is?: OfferWhereInput | null
    isNot?: OfferWhereInput | null
  }

  export type AlertDeliveryAlertIdFingerprintCompoundUniqueInput = {
    alertId: string
    fingerprint: string
  }

  export type AlertDeliveryCountOrderByAggregateInput = {
    id?: SortOrder
    alertId?: SortOrder
    offerId?: SortOrder
    sentAt?: SortOrder
    fingerprint?: SortOrder
    userId?: SortOrder
  }

  export type AlertDeliveryAvgOrderByAggregateInput = {
    offerId?: SortOrder
  }

  export type AlertDeliveryMaxOrderByAggregateInput = {
    id?: SortOrder
    alertId?: SortOrder
    offerId?: SortOrder
    sentAt?: SortOrder
    fingerprint?: SortOrder
    userId?: SortOrder
  }

  export type AlertDeliveryMinOrderByAggregateInput = {
    id?: SortOrder
    alertId?: SortOrder
    offerId?: SortOrder
    sentAt?: SortOrder
    fingerprint?: SortOrder
    userId?: SortOrder
  }

  export type AlertDeliverySumOrderByAggregateInput = {
    offerId?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type EnumAmmoPressureNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.AmmoPressure | EnumAmmoPressureFieldRefInput<$PrismaModel> | null
    in?: $Enums.AmmoPressure[] | ListEnumAmmoPressureFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.AmmoPressure[] | ListEnumAmmoPressureFieldRefInput<$PrismaModel> | null
    not?: NestedEnumAmmoPressureNullableFilter<$PrismaModel> | $Enums.AmmoPressure | null
  }

  export type CaliberScalarRelationFilter = {
    is?: CaliberWhereInput
    isNot?: CaliberWhereInput
  }

  export type AmmoSpecsCountOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    caliberId?: SortOrder
    grain?: SortOrder
    gauge?: SortOrder
    velocity?: SortOrder
    energy?: SortOrder
    casing?: SortOrder
    bulletType?: SortOrder
    restrictions?: SortOrder
    pressure?: SortOrder
    isSteelCase?: SortOrder
    isRemanufactured?: SortOrder
    isSubsonic?: SortOrder
  }

  export type AmmoSpecsAvgOrderByAggregateInput = {
    id?: SortOrder
    caliberId?: SortOrder
    grain?: SortOrder
    velocity?: SortOrder
    energy?: SortOrder
  }

  export type AmmoSpecsMaxOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    caliberId?: SortOrder
    grain?: SortOrder
    gauge?: SortOrder
    velocity?: SortOrder
    energy?: SortOrder
    casing?: SortOrder
    bulletType?: SortOrder
    pressure?: SortOrder
    isSteelCase?: SortOrder
    isRemanufactured?: SortOrder
    isSubsonic?: SortOrder
  }

  export type AmmoSpecsMinOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    caliberId?: SortOrder
    grain?: SortOrder
    gauge?: SortOrder
    velocity?: SortOrder
    energy?: SortOrder
    casing?: SortOrder
    bulletType?: SortOrder
    pressure?: SortOrder
    isSteelCase?: SortOrder
    isRemanufactured?: SortOrder
    isSubsonic?: SortOrder
  }

  export type AmmoSpecsSumOrderByAggregateInput = {
    id?: SortOrder
    caliberId?: SortOrder
    grain?: SortOrder
    velocity?: SortOrder
    energy?: SortOrder
  }

  export type EnumAmmoPressureNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AmmoPressure | EnumAmmoPressureFieldRefInput<$PrismaModel> | null
    in?: $Enums.AmmoPressure[] | ListEnumAmmoPressureFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.AmmoPressure[] | ListEnumAmmoPressureFieldRefInput<$PrismaModel> | null
    not?: NestedEnumAmmoPressureNullableWithAggregatesFilter<$PrismaModel> | $Enums.AmmoPressure | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumAmmoPressureNullableFilter<$PrismaModel>
    _max?: NestedEnumAmmoPressureNullableFilter<$PrismaModel>
  }

  export type BlockedRetailerCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    retailerId?: SortOrder
    createdAt?: SortOrder
  }

  export type BlockedRetailerAvgOrderByAggregateInput = {
    retailerId?: SortOrder
  }

  export type BlockedRetailerMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    retailerId?: SortOrder
    createdAt?: SortOrder
  }

  export type BlockedRetailerMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    retailerId?: SortOrder
    createdAt?: SortOrder
  }

  export type BlockedRetailerSumOrderByAggregateInput = {
    retailerId?: SortOrder
  }

  export type CaliberAliasCountOrderByAggregateInput = {
    id?: SortOrder
    caliberId?: SortOrder
    alias?: SortOrder
  }

  export type CaliberAliasAvgOrderByAggregateInput = {
    id?: SortOrder
    caliberId?: SortOrder
  }

  export type CaliberAliasMaxOrderByAggregateInput = {
    id?: SortOrder
    caliberId?: SortOrder
    alias?: SortOrder
  }

  export type CaliberAliasMinOrderByAggregateInput = {
    id?: SortOrder
    caliberId?: SortOrder
    alias?: SortOrder
  }

  export type CaliberAliasSumOrderByAggregateInput = {
    id?: SortOrder
    caliberId?: SortOrder
  }

  export type EnumCatalogKindFilter<$PrismaModel = never> = {
    equals?: $Enums.CatalogKind | EnumCatalogKindFieldRefInput<$PrismaModel>
    in?: $Enums.CatalogKind[] | ListEnumCatalogKindFieldRefInput<$PrismaModel>
    notIn?: $Enums.CatalogKind[] | ListEnumCatalogKindFieldRefInput<$PrismaModel>
    not?: NestedEnumCatalogKindFilter<$PrismaModel> | $Enums.CatalogKind
  }

  export type AccessorySpecsNullableScalarRelationFilter = {
    is?: AccessorySpecsWhereInput | null
    isNot?: AccessorySpecsWhereInput | null
  }

  export type AmmoSpecsNullableScalarRelationFilter = {
    is?: AmmoSpecsWhereInput | null
    isNot?: AmmoSpecsWhereInput | null
  }

  export type BrandNullableScalarRelationFilter = {
    is?: BrandWhereInput | null
    isNot?: BrandWhereInput | null
  }

  export type FirearmSpecsNullableScalarRelationFilter = {
    is?: FirearmSpecsWhereInput | null
    isNot?: FirearmSpecsWhereInput | null
  }

  export type OwnedFirearmListRelationFilter = {
    every?: OwnedFirearmWhereInput
    some?: OwnedFirearmWhereInput
    none?: OwnedFirearmWhereInput
  }

  export type OwnedFirearmOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CatalogItemCountOrderByAggregateInput = {
    id?: SortOrder
    kind?: SortOrder
    slug?: SortOrder
    upc?: SortOrder
    mpn?: SortOrder
    title?: SortOrder
    image?: SortOrder
    description?: SortOrder
    brandId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bestPrice?: SortOrder
    bestRetailerId?: SortOrder
    bestRetailerName?: SortOrder
    offerCount?: SortOrder
    bestCpr?: SortOrder
    bestCprShipped?: SortOrder
    upvotes?: SortOrder
    downvotes?: SortOrder
  }

  export type CatalogItemAvgOrderByAggregateInput = {
    brandId?: SortOrder
    bestPrice?: SortOrder
    bestRetailerId?: SortOrder
    offerCount?: SortOrder
    bestCpr?: SortOrder
    bestCprShipped?: SortOrder
    upvotes?: SortOrder
    downvotes?: SortOrder
  }

  export type CatalogItemMaxOrderByAggregateInput = {
    id?: SortOrder
    kind?: SortOrder
    slug?: SortOrder
    upc?: SortOrder
    mpn?: SortOrder
    title?: SortOrder
    image?: SortOrder
    description?: SortOrder
    brandId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bestPrice?: SortOrder
    bestRetailerId?: SortOrder
    bestRetailerName?: SortOrder
    offerCount?: SortOrder
    bestCpr?: SortOrder
    bestCprShipped?: SortOrder
    upvotes?: SortOrder
    downvotes?: SortOrder
  }

  export type CatalogItemMinOrderByAggregateInput = {
    id?: SortOrder
    kind?: SortOrder
    slug?: SortOrder
    upc?: SortOrder
    mpn?: SortOrder
    title?: SortOrder
    image?: SortOrder
    description?: SortOrder
    brandId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bestPrice?: SortOrder
    bestRetailerId?: SortOrder
    bestRetailerName?: SortOrder
    offerCount?: SortOrder
    bestCpr?: SortOrder
    bestCprShipped?: SortOrder
    upvotes?: SortOrder
    downvotes?: SortOrder
  }

  export type CatalogItemSumOrderByAggregateInput = {
    brandId?: SortOrder
    bestPrice?: SortOrder
    bestRetailerId?: SortOrder
    offerCount?: SortOrder
    bestCpr?: SortOrder
    bestCprShipped?: SortOrder
    upvotes?: SortOrder
    downvotes?: SortOrder
  }

  export type EnumCatalogKindWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CatalogKind | EnumCatalogKindFieldRefInput<$PrismaModel>
    in?: $Enums.CatalogKind[] | ListEnumCatalogKindFieldRefInput<$PrismaModel>
    notIn?: $Enums.CatalogKind[] | ListEnumCatalogKindFieldRefInput<$PrismaModel>
    not?: NestedEnumCatalogKindWithAggregatesFilter<$PrismaModel> | $Enums.CatalogKind
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCatalogKindFilter<$PrismaModel>
    _max?: NestedEnumCatalogKindFilter<$PrismaModel>
  }

  export type FirearmSpecsListRelationFilter = {
    every?: FirearmSpecsWhereInput
    some?: FirearmSpecsWhereInput
    none?: FirearmSpecsWhereInput
  }

  export type FirearmSpecsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FirearmCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
  }

  export type FirearmCategoryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FirearmCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
  }

  export type FirearmCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
  }

  export type FirearmCategorySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FirearmSpecsScalarRelationFilter = {
    is?: FirearmSpecsWhereInput
    isNot?: FirearmSpecsWhereInput
  }

  export type FirearmChamberFirearmSpecsIdCaliberIdCompoundUniqueInput = {
    firearmSpecsId: number
    caliberId: number
  }

  export type FirearmChamberCountOrderByAggregateInput = {
    firearmSpecsId?: SortOrder
    caliberId?: SortOrder
    note?: SortOrder
  }

  export type FirearmChamberAvgOrderByAggregateInput = {
    firearmSpecsId?: SortOrder
    caliberId?: SortOrder
  }

  export type FirearmChamberMaxOrderByAggregateInput = {
    firearmSpecsId?: SortOrder
    caliberId?: SortOrder
    note?: SortOrder
  }

  export type FirearmChamberMinOrderByAggregateInput = {
    firearmSpecsId?: SortOrder
    caliberId?: SortOrder
    note?: SortOrder
  }

  export type FirearmChamberSumOrderByAggregateInput = {
    firearmSpecsId?: SortOrder
    caliberId?: SortOrder
  }

  export type EnumFirearmPressureRatingNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.FirearmPressureRating | EnumFirearmPressureRatingFieldRefInput<$PrismaModel> | null
    in?: $Enums.FirearmPressureRating[] | ListEnumFirearmPressureRatingFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.FirearmPressureRating[] | ListEnumFirearmPressureRatingFieldRefInput<$PrismaModel> | null
    not?: NestedEnumFirearmPressureRatingNullableFilter<$PrismaModel> | $Enums.FirearmPressureRating | null
  }

  export type FirearmCategoryNullableScalarRelationFilter = {
    is?: FirearmCategoryWhereInput | null
    isNot?: FirearmCategoryWhereInput | null
  }

  export type FirearmSpecsCountOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    manufacturer?: SortOrder
    model?: SortOrder
    platform?: SortOrder
    firearmCategoryId?: SortOrder
    barrelLengthIn?: SortOrder
    actionType?: SortOrder
    isThreaded?: SortOrder
    pressureRating?: SortOrder
    firearmType?: SortOrder
    capacity?: SortOrder
    finish?: SortOrder
    weight?: SortOrder
    overallLength?: SortOrder
    features?: SortOrder
    sight?: SortOrder
    safety?: SortOrder
  }

  export type FirearmSpecsAvgOrderByAggregateInput = {
    id?: SortOrder
    firearmCategoryId?: SortOrder
    barrelLengthIn?: SortOrder
  }

  export type FirearmSpecsMaxOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    manufacturer?: SortOrder
    model?: SortOrder
    platform?: SortOrder
    firearmCategoryId?: SortOrder
    barrelLengthIn?: SortOrder
    actionType?: SortOrder
    isThreaded?: SortOrder
    pressureRating?: SortOrder
    firearmType?: SortOrder
    capacity?: SortOrder
    finish?: SortOrder
    weight?: SortOrder
    overallLength?: SortOrder
    features?: SortOrder
    sight?: SortOrder
    safety?: SortOrder
  }

  export type FirearmSpecsMinOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    manufacturer?: SortOrder
    model?: SortOrder
    platform?: SortOrder
    firearmCategoryId?: SortOrder
    barrelLengthIn?: SortOrder
    actionType?: SortOrder
    isThreaded?: SortOrder
    pressureRating?: SortOrder
    firearmType?: SortOrder
    capacity?: SortOrder
    finish?: SortOrder
    weight?: SortOrder
    overallLength?: SortOrder
    features?: SortOrder
    sight?: SortOrder
    safety?: SortOrder
  }

  export type FirearmSpecsSumOrderByAggregateInput = {
    id?: SortOrder
    firearmCategoryId?: SortOrder
    barrelLengthIn?: SortOrder
  }

  export type EnumFirearmPressureRatingNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FirearmPressureRating | EnumFirearmPressureRatingFieldRefInput<$PrismaModel> | null
    in?: $Enums.FirearmPressureRating[] | ListEnumFirearmPressureRatingFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.FirearmPressureRating[] | ListEnumFirearmPressureRatingFieldRefInput<$PrismaModel> | null
    not?: NestedEnumFirearmPressureRatingNullableWithAggregatesFilter<$PrismaModel> | $Enums.FirearmPressureRating | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumFirearmPressureRatingNullableFilter<$PrismaModel>
    _max?: NestedEnumFirearmPressureRatingNullableFilter<$PrismaModel>
  }

  export type OwnedFirearmUserIdFirearmItemIdCompoundUniqueInput = {
    userId: string
    firearmItemId: string
  }

  export type OwnedFirearmCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    firearmItemId?: SortOrder
    nickname?: SortOrder
    createdAt?: SortOrder
  }

  export type OwnedFirearmMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    firearmItemId?: SortOrder
    nickname?: SortOrder
    createdAt?: SortOrder
  }

  export type OwnedFirearmMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    firearmItemId?: SortOrder
    nickname?: SortOrder
    createdAt?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type raw_offer_ingestOffer_fingerprintBucket_5mTimeCompoundUniqueInput = {
    offer_fingerprint: string
    bucket_5m: Date | string
    time: Date | string
  }

  export type raw_offer_ingestCountOrderByAggregateInput = {
    time?: SortOrder
    bucket_5m?: SortOrder
    group_id?: SortOrder
    item_url?: SortOrder
    item_type?: SortOrder
    retailer_name?: SortOrder
    offer_url?: SortOrder
    price?: SortOrder
    shipping_text?: SortOrder
    shipping_cost?: SortOrder
    total?: SortOrder
    in_stock?: SortOrder
    source?: SortOrder
    offer_fingerprint?: SortOrder
  }

  export type raw_offer_ingestAvgOrderByAggregateInput = {
    price?: SortOrder
    shipping_cost?: SortOrder
    total?: SortOrder
  }

  export type raw_offer_ingestMaxOrderByAggregateInput = {
    time?: SortOrder
    bucket_5m?: SortOrder
    group_id?: SortOrder
    item_url?: SortOrder
    item_type?: SortOrder
    retailer_name?: SortOrder
    offer_url?: SortOrder
    price?: SortOrder
    shipping_text?: SortOrder
    shipping_cost?: SortOrder
    total?: SortOrder
    in_stock?: SortOrder
    source?: SortOrder
    offer_fingerprint?: SortOrder
  }

  export type raw_offer_ingestMinOrderByAggregateInput = {
    time?: SortOrder
    bucket_5m?: SortOrder
    group_id?: SortOrder
    item_url?: SortOrder
    item_type?: SortOrder
    retailer_name?: SortOrder
    offer_url?: SortOrder
    price?: SortOrder
    shipping_text?: SortOrder
    shipping_cost?: SortOrder
    total?: SortOrder
    in_stock?: SortOrder
    source?: SortOrder
    offer_fingerprint?: SortOrder
  }

  export type raw_offer_ingestSumOrderByAggregateInput = {
    price?: SortOrder
    shipping_cost?: SortOrder
    total?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type CatalogItemCreateNestedManyWithoutBrandInput = {
    create?: XOR<CatalogItemCreateWithoutBrandInput, CatalogItemUncheckedCreateWithoutBrandInput> | CatalogItemCreateWithoutBrandInput[] | CatalogItemUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: CatalogItemCreateOrConnectWithoutBrandInput | CatalogItemCreateOrConnectWithoutBrandInput[]
    createMany?: CatalogItemCreateManyBrandInputEnvelope
    connect?: CatalogItemWhereUniqueInput | CatalogItemWhereUniqueInput[]
  }

  export type CatalogItemUncheckedCreateNestedManyWithoutBrandInput = {
    create?: XOR<CatalogItemCreateWithoutBrandInput, CatalogItemUncheckedCreateWithoutBrandInput> | CatalogItemCreateWithoutBrandInput[] | CatalogItemUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: CatalogItemCreateOrConnectWithoutBrandInput | CatalogItemCreateOrConnectWithoutBrandInput[]
    createMany?: CatalogItemCreateManyBrandInputEnvelope
    connect?: CatalogItemWhereUniqueInput | CatalogItemWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type CatalogItemUpdateManyWithoutBrandNestedInput = {
    create?: XOR<CatalogItemCreateWithoutBrandInput, CatalogItemUncheckedCreateWithoutBrandInput> | CatalogItemCreateWithoutBrandInput[] | CatalogItemUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: CatalogItemCreateOrConnectWithoutBrandInput | CatalogItemCreateOrConnectWithoutBrandInput[]
    upsert?: CatalogItemUpsertWithWhereUniqueWithoutBrandInput | CatalogItemUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: CatalogItemCreateManyBrandInputEnvelope
    set?: CatalogItemWhereUniqueInput | CatalogItemWhereUniqueInput[]
    disconnect?: CatalogItemWhereUniqueInput | CatalogItemWhereUniqueInput[]
    delete?: CatalogItemWhereUniqueInput | CatalogItemWhereUniqueInput[]
    connect?: CatalogItemWhereUniqueInput | CatalogItemWhereUniqueInput[]
    update?: CatalogItemUpdateWithWhereUniqueWithoutBrandInput | CatalogItemUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: CatalogItemUpdateManyWithWhereWithoutBrandInput | CatalogItemUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: CatalogItemScalarWhereInput | CatalogItemScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CatalogItemUncheckedUpdateManyWithoutBrandNestedInput = {
    create?: XOR<CatalogItemCreateWithoutBrandInput, CatalogItemUncheckedCreateWithoutBrandInput> | CatalogItemCreateWithoutBrandInput[] | CatalogItemUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: CatalogItemCreateOrConnectWithoutBrandInput | CatalogItemCreateOrConnectWithoutBrandInput[]
    upsert?: CatalogItemUpsertWithWhereUniqueWithoutBrandInput | CatalogItemUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: CatalogItemCreateManyBrandInputEnvelope
    set?: CatalogItemWhereUniqueInput | CatalogItemWhereUniqueInput[]
    disconnect?: CatalogItemWhereUniqueInput | CatalogItemWhereUniqueInput[]
    delete?: CatalogItemWhereUniqueInput | CatalogItemWhereUniqueInput[]
    connect?: CatalogItemWhereUniqueInput | CatalogItemWhereUniqueInput[]
    update?: CatalogItemUpdateWithWhereUniqueWithoutBrandInput | CatalogItemUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: CatalogItemUpdateManyWithWhereWithoutBrandInput | CatalogItemUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: CatalogItemScalarWhereInput | CatalogItemScalarWhereInput[]
  }

  export type AlertCreateNestedManyWithoutCaliberInput = {
    create?: XOR<AlertCreateWithoutCaliberInput, AlertUncheckedCreateWithoutCaliberInput> | AlertCreateWithoutCaliberInput[] | AlertUncheckedCreateWithoutCaliberInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutCaliberInput | AlertCreateOrConnectWithoutCaliberInput[]
    createMany?: AlertCreateManyCaliberInputEnvelope
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
  }

  export type AmmoSpecsCreateNestedManyWithoutCaliberInput = {
    create?: XOR<AmmoSpecsCreateWithoutCaliberInput, AmmoSpecsUncheckedCreateWithoutCaliberInput> | AmmoSpecsCreateWithoutCaliberInput[] | AmmoSpecsUncheckedCreateWithoutCaliberInput[]
    connectOrCreate?: AmmoSpecsCreateOrConnectWithoutCaliberInput | AmmoSpecsCreateOrConnectWithoutCaliberInput[]
    createMany?: AmmoSpecsCreateManyCaliberInputEnvelope
    connect?: AmmoSpecsWhereUniqueInput | AmmoSpecsWhereUniqueInput[]
  }

  export type CaliberAliasCreateNestedManyWithoutCaliberInput = {
    create?: XOR<CaliberAliasCreateWithoutCaliberInput, CaliberAliasUncheckedCreateWithoutCaliberInput> | CaliberAliasCreateWithoutCaliberInput[] | CaliberAliasUncheckedCreateWithoutCaliberInput[]
    connectOrCreate?: CaliberAliasCreateOrConnectWithoutCaliberInput | CaliberAliasCreateOrConnectWithoutCaliberInput[]
    createMany?: CaliberAliasCreateManyCaliberInputEnvelope
    connect?: CaliberAliasWhereUniqueInput | CaliberAliasWhereUniqueInput[]
  }

  export type FirearmChamberCreateNestedManyWithoutCaliberInput = {
    create?: XOR<FirearmChamberCreateWithoutCaliberInput, FirearmChamberUncheckedCreateWithoutCaliberInput> | FirearmChamberCreateWithoutCaliberInput[] | FirearmChamberUncheckedCreateWithoutCaliberInput[]
    connectOrCreate?: FirearmChamberCreateOrConnectWithoutCaliberInput | FirearmChamberCreateOrConnectWithoutCaliberInput[]
    createMany?: FirearmChamberCreateManyCaliberInputEnvelope
    connect?: FirearmChamberWhereUniqueInput | FirearmChamberWhereUniqueInput[]
  }

  export type AlertUncheckedCreateNestedManyWithoutCaliberInput = {
    create?: XOR<AlertCreateWithoutCaliberInput, AlertUncheckedCreateWithoutCaliberInput> | AlertCreateWithoutCaliberInput[] | AlertUncheckedCreateWithoutCaliberInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutCaliberInput | AlertCreateOrConnectWithoutCaliberInput[]
    createMany?: AlertCreateManyCaliberInputEnvelope
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
  }

  export type AmmoSpecsUncheckedCreateNestedManyWithoutCaliberInput = {
    create?: XOR<AmmoSpecsCreateWithoutCaliberInput, AmmoSpecsUncheckedCreateWithoutCaliberInput> | AmmoSpecsCreateWithoutCaliberInput[] | AmmoSpecsUncheckedCreateWithoutCaliberInput[]
    connectOrCreate?: AmmoSpecsCreateOrConnectWithoutCaliberInput | AmmoSpecsCreateOrConnectWithoutCaliberInput[]
    createMany?: AmmoSpecsCreateManyCaliberInputEnvelope
    connect?: AmmoSpecsWhereUniqueInput | AmmoSpecsWhereUniqueInput[]
  }

  export type CaliberAliasUncheckedCreateNestedManyWithoutCaliberInput = {
    create?: XOR<CaliberAliasCreateWithoutCaliberInput, CaliberAliasUncheckedCreateWithoutCaliberInput> | CaliberAliasCreateWithoutCaliberInput[] | CaliberAliasUncheckedCreateWithoutCaliberInput[]
    connectOrCreate?: CaliberAliasCreateOrConnectWithoutCaliberInput | CaliberAliasCreateOrConnectWithoutCaliberInput[]
    createMany?: CaliberAliasCreateManyCaliberInputEnvelope
    connect?: CaliberAliasWhereUniqueInput | CaliberAliasWhereUniqueInput[]
  }

  export type FirearmChamberUncheckedCreateNestedManyWithoutCaliberInput = {
    create?: XOR<FirearmChamberCreateWithoutCaliberInput, FirearmChamberUncheckedCreateWithoutCaliberInput> | FirearmChamberCreateWithoutCaliberInput[] | FirearmChamberUncheckedCreateWithoutCaliberInput[]
    connectOrCreate?: FirearmChamberCreateOrConnectWithoutCaliberInput | FirearmChamberCreateOrConnectWithoutCaliberInput[]
    createMany?: FirearmChamberCreateManyCaliberInputEnvelope
    connect?: FirearmChamberWhereUniqueInput | FirearmChamberWhereUniqueInput[]
  }

  export type AlertUpdateManyWithoutCaliberNestedInput = {
    create?: XOR<AlertCreateWithoutCaliberInput, AlertUncheckedCreateWithoutCaliberInput> | AlertCreateWithoutCaliberInput[] | AlertUncheckedCreateWithoutCaliberInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutCaliberInput | AlertCreateOrConnectWithoutCaliberInput[]
    upsert?: AlertUpsertWithWhereUniqueWithoutCaliberInput | AlertUpsertWithWhereUniqueWithoutCaliberInput[]
    createMany?: AlertCreateManyCaliberInputEnvelope
    set?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    disconnect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    delete?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    update?: AlertUpdateWithWhereUniqueWithoutCaliberInput | AlertUpdateWithWhereUniqueWithoutCaliberInput[]
    updateMany?: AlertUpdateManyWithWhereWithoutCaliberInput | AlertUpdateManyWithWhereWithoutCaliberInput[]
    deleteMany?: AlertScalarWhereInput | AlertScalarWhereInput[]
  }

  export type AmmoSpecsUpdateManyWithoutCaliberNestedInput = {
    create?: XOR<AmmoSpecsCreateWithoutCaliberInput, AmmoSpecsUncheckedCreateWithoutCaliberInput> | AmmoSpecsCreateWithoutCaliberInput[] | AmmoSpecsUncheckedCreateWithoutCaliberInput[]
    connectOrCreate?: AmmoSpecsCreateOrConnectWithoutCaliberInput | AmmoSpecsCreateOrConnectWithoutCaliberInput[]
    upsert?: AmmoSpecsUpsertWithWhereUniqueWithoutCaliberInput | AmmoSpecsUpsertWithWhereUniqueWithoutCaliberInput[]
    createMany?: AmmoSpecsCreateManyCaliberInputEnvelope
    set?: AmmoSpecsWhereUniqueInput | AmmoSpecsWhereUniqueInput[]
    disconnect?: AmmoSpecsWhereUniqueInput | AmmoSpecsWhereUniqueInput[]
    delete?: AmmoSpecsWhereUniqueInput | AmmoSpecsWhereUniqueInput[]
    connect?: AmmoSpecsWhereUniqueInput | AmmoSpecsWhereUniqueInput[]
    update?: AmmoSpecsUpdateWithWhereUniqueWithoutCaliberInput | AmmoSpecsUpdateWithWhereUniqueWithoutCaliberInput[]
    updateMany?: AmmoSpecsUpdateManyWithWhereWithoutCaliberInput | AmmoSpecsUpdateManyWithWhereWithoutCaliberInput[]
    deleteMany?: AmmoSpecsScalarWhereInput | AmmoSpecsScalarWhereInput[]
  }

  export type CaliberAliasUpdateManyWithoutCaliberNestedInput = {
    create?: XOR<CaliberAliasCreateWithoutCaliberInput, CaliberAliasUncheckedCreateWithoutCaliberInput> | CaliberAliasCreateWithoutCaliberInput[] | CaliberAliasUncheckedCreateWithoutCaliberInput[]
    connectOrCreate?: CaliberAliasCreateOrConnectWithoutCaliberInput | CaliberAliasCreateOrConnectWithoutCaliberInput[]
    upsert?: CaliberAliasUpsertWithWhereUniqueWithoutCaliberInput | CaliberAliasUpsertWithWhereUniqueWithoutCaliberInput[]
    createMany?: CaliberAliasCreateManyCaliberInputEnvelope
    set?: CaliberAliasWhereUniqueInput | CaliberAliasWhereUniqueInput[]
    disconnect?: CaliberAliasWhereUniqueInput | CaliberAliasWhereUniqueInput[]
    delete?: CaliberAliasWhereUniqueInput | CaliberAliasWhereUniqueInput[]
    connect?: CaliberAliasWhereUniqueInput | CaliberAliasWhereUniqueInput[]
    update?: CaliberAliasUpdateWithWhereUniqueWithoutCaliberInput | CaliberAliasUpdateWithWhereUniqueWithoutCaliberInput[]
    updateMany?: CaliberAliasUpdateManyWithWhereWithoutCaliberInput | CaliberAliasUpdateManyWithWhereWithoutCaliberInput[]
    deleteMany?: CaliberAliasScalarWhereInput | CaliberAliasScalarWhereInput[]
  }

  export type FirearmChamberUpdateManyWithoutCaliberNestedInput = {
    create?: XOR<FirearmChamberCreateWithoutCaliberInput, FirearmChamberUncheckedCreateWithoutCaliberInput> | FirearmChamberCreateWithoutCaliberInput[] | FirearmChamberUncheckedCreateWithoutCaliberInput[]
    connectOrCreate?: FirearmChamberCreateOrConnectWithoutCaliberInput | FirearmChamberCreateOrConnectWithoutCaliberInput[]
    upsert?: FirearmChamberUpsertWithWhereUniqueWithoutCaliberInput | FirearmChamberUpsertWithWhereUniqueWithoutCaliberInput[]
    createMany?: FirearmChamberCreateManyCaliberInputEnvelope
    set?: FirearmChamberWhereUniqueInput | FirearmChamberWhereUniqueInput[]
    disconnect?: FirearmChamberWhereUniqueInput | FirearmChamberWhereUniqueInput[]
    delete?: FirearmChamberWhereUniqueInput | FirearmChamberWhereUniqueInput[]
    connect?: FirearmChamberWhereUniqueInput | FirearmChamberWhereUniqueInput[]
    update?: FirearmChamberUpdateWithWhereUniqueWithoutCaliberInput | FirearmChamberUpdateWithWhereUniqueWithoutCaliberInput[]
    updateMany?: FirearmChamberUpdateManyWithWhereWithoutCaliberInput | FirearmChamberUpdateManyWithWhereWithoutCaliberInput[]
    deleteMany?: FirearmChamberScalarWhereInput | FirearmChamberScalarWhereInput[]
  }

  export type AlertUncheckedUpdateManyWithoutCaliberNestedInput = {
    create?: XOR<AlertCreateWithoutCaliberInput, AlertUncheckedCreateWithoutCaliberInput> | AlertCreateWithoutCaliberInput[] | AlertUncheckedCreateWithoutCaliberInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutCaliberInput | AlertCreateOrConnectWithoutCaliberInput[]
    upsert?: AlertUpsertWithWhereUniqueWithoutCaliberInput | AlertUpsertWithWhereUniqueWithoutCaliberInput[]
    createMany?: AlertCreateManyCaliberInputEnvelope
    set?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    disconnect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    delete?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    update?: AlertUpdateWithWhereUniqueWithoutCaliberInput | AlertUpdateWithWhereUniqueWithoutCaliberInput[]
    updateMany?: AlertUpdateManyWithWhereWithoutCaliberInput | AlertUpdateManyWithWhereWithoutCaliberInput[]
    deleteMany?: AlertScalarWhereInput | AlertScalarWhereInput[]
  }

  export type AmmoSpecsUncheckedUpdateManyWithoutCaliberNestedInput = {
    create?: XOR<AmmoSpecsCreateWithoutCaliberInput, AmmoSpecsUncheckedCreateWithoutCaliberInput> | AmmoSpecsCreateWithoutCaliberInput[] | AmmoSpecsUncheckedCreateWithoutCaliberInput[]
    connectOrCreate?: AmmoSpecsCreateOrConnectWithoutCaliberInput | AmmoSpecsCreateOrConnectWithoutCaliberInput[]
    upsert?: AmmoSpecsUpsertWithWhereUniqueWithoutCaliberInput | AmmoSpecsUpsertWithWhereUniqueWithoutCaliberInput[]
    createMany?: AmmoSpecsCreateManyCaliberInputEnvelope
    set?: AmmoSpecsWhereUniqueInput | AmmoSpecsWhereUniqueInput[]
    disconnect?: AmmoSpecsWhereUniqueInput | AmmoSpecsWhereUniqueInput[]
    delete?: AmmoSpecsWhereUniqueInput | AmmoSpecsWhereUniqueInput[]
    connect?: AmmoSpecsWhereUniqueInput | AmmoSpecsWhereUniqueInput[]
    update?: AmmoSpecsUpdateWithWhereUniqueWithoutCaliberInput | AmmoSpecsUpdateWithWhereUniqueWithoutCaliberInput[]
    updateMany?: AmmoSpecsUpdateManyWithWhereWithoutCaliberInput | AmmoSpecsUpdateManyWithWhereWithoutCaliberInput[]
    deleteMany?: AmmoSpecsScalarWhereInput | AmmoSpecsScalarWhereInput[]
  }

  export type CaliberAliasUncheckedUpdateManyWithoutCaliberNestedInput = {
    create?: XOR<CaliberAliasCreateWithoutCaliberInput, CaliberAliasUncheckedCreateWithoutCaliberInput> | CaliberAliasCreateWithoutCaliberInput[] | CaliberAliasUncheckedCreateWithoutCaliberInput[]
    connectOrCreate?: CaliberAliasCreateOrConnectWithoutCaliberInput | CaliberAliasCreateOrConnectWithoutCaliberInput[]
    upsert?: CaliberAliasUpsertWithWhereUniqueWithoutCaliberInput | CaliberAliasUpsertWithWhereUniqueWithoutCaliberInput[]
    createMany?: CaliberAliasCreateManyCaliberInputEnvelope
    set?: CaliberAliasWhereUniqueInput | CaliberAliasWhereUniqueInput[]
    disconnect?: CaliberAliasWhereUniqueInput | CaliberAliasWhereUniqueInput[]
    delete?: CaliberAliasWhereUniqueInput | CaliberAliasWhereUniqueInput[]
    connect?: CaliberAliasWhereUniqueInput | CaliberAliasWhereUniqueInput[]
    update?: CaliberAliasUpdateWithWhereUniqueWithoutCaliberInput | CaliberAliasUpdateWithWhereUniqueWithoutCaliberInput[]
    updateMany?: CaliberAliasUpdateManyWithWhereWithoutCaliberInput | CaliberAliasUpdateManyWithWhereWithoutCaliberInput[]
    deleteMany?: CaliberAliasScalarWhereInput | CaliberAliasScalarWhereInput[]
  }

  export type FirearmChamberUncheckedUpdateManyWithoutCaliberNestedInput = {
    create?: XOR<FirearmChamberCreateWithoutCaliberInput, FirearmChamberUncheckedCreateWithoutCaliberInput> | FirearmChamberCreateWithoutCaliberInput[] | FirearmChamberUncheckedCreateWithoutCaliberInput[]
    connectOrCreate?: FirearmChamberCreateOrConnectWithoutCaliberInput | FirearmChamberCreateOrConnectWithoutCaliberInput[]
    upsert?: FirearmChamberUpsertWithWhereUniqueWithoutCaliberInput | FirearmChamberUpsertWithWhereUniqueWithoutCaliberInput[]
    createMany?: FirearmChamberCreateManyCaliberInputEnvelope
    set?: FirearmChamberWhereUniqueInput | FirearmChamberWhereUniqueInput[]
    disconnect?: FirearmChamberWhereUniqueInput | FirearmChamberWhereUniqueInput[]
    delete?: FirearmChamberWhereUniqueInput | FirearmChamberWhereUniqueInput[]
    connect?: FirearmChamberWhereUniqueInput | FirearmChamberWhereUniqueInput[]
    update?: FirearmChamberUpdateWithWhereUniqueWithoutCaliberInput | FirearmChamberUpdateWithWhereUniqueWithoutCaliberInput[]
    updateMany?: FirearmChamberUpdateManyWithWhereWithoutCaliberInput | FirearmChamberUpdateManyWithWhereWithoutCaliberInput[]
    deleteMany?: FirearmChamberScalarWhereInput | FirearmChamberScalarWhereInput[]
  }

  export type AlertDeliveryCreateNestedManyWithoutOfferInput = {
    create?: XOR<AlertDeliveryCreateWithoutOfferInput, AlertDeliveryUncheckedCreateWithoutOfferInput> | AlertDeliveryCreateWithoutOfferInput[] | AlertDeliveryUncheckedCreateWithoutOfferInput[]
    connectOrCreate?: AlertDeliveryCreateOrConnectWithoutOfferInput | AlertDeliveryCreateOrConnectWithoutOfferInput[]
    createMany?: AlertDeliveryCreateManyOfferInputEnvelope
    connect?: AlertDeliveryWhereUniqueInput | AlertDeliveryWhereUniqueInput[]
  }

  export type CatalogItemCreateNestedOneWithoutOfferInput = {
    create?: XOR<CatalogItemCreateWithoutOfferInput, CatalogItemUncheckedCreateWithoutOfferInput>
    connectOrCreate?: CatalogItemCreateOrConnectWithoutOfferInput
    connect?: CatalogItemWhereUniqueInput
  }

  export type RetailerCreateNestedOneWithoutOffersInput = {
    create?: XOR<RetailerCreateWithoutOffersInput, RetailerUncheckedCreateWithoutOffersInput>
    connectOrCreate?: RetailerCreateOrConnectWithoutOffersInput
    connect?: RetailerWhereUniqueInput
  }

  export type AlertDeliveryUncheckedCreateNestedManyWithoutOfferInput = {
    create?: XOR<AlertDeliveryCreateWithoutOfferInput, AlertDeliveryUncheckedCreateWithoutOfferInput> | AlertDeliveryCreateWithoutOfferInput[] | AlertDeliveryUncheckedCreateWithoutOfferInput[]
    connectOrCreate?: AlertDeliveryCreateOrConnectWithoutOfferInput | AlertDeliveryCreateOrConnectWithoutOfferInput[]
    createMany?: AlertDeliveryCreateManyOfferInputEnvelope
    connect?: AlertDeliveryWhereUniqueInput | AlertDeliveryWhereUniqueInput[]
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AlertDeliveryUpdateManyWithoutOfferNestedInput = {
    create?: XOR<AlertDeliveryCreateWithoutOfferInput, AlertDeliveryUncheckedCreateWithoutOfferInput> | AlertDeliveryCreateWithoutOfferInput[] | AlertDeliveryUncheckedCreateWithoutOfferInput[]
    connectOrCreate?: AlertDeliveryCreateOrConnectWithoutOfferInput | AlertDeliveryCreateOrConnectWithoutOfferInput[]
    upsert?: AlertDeliveryUpsertWithWhereUniqueWithoutOfferInput | AlertDeliveryUpsertWithWhereUniqueWithoutOfferInput[]
    createMany?: AlertDeliveryCreateManyOfferInputEnvelope
    set?: AlertDeliveryWhereUniqueInput | AlertDeliveryWhereUniqueInput[]
    disconnect?: AlertDeliveryWhereUniqueInput | AlertDeliveryWhereUniqueInput[]
    delete?: AlertDeliveryWhereUniqueInput | AlertDeliveryWhereUniqueInput[]
    connect?: AlertDeliveryWhereUniqueInput | AlertDeliveryWhereUniqueInput[]
    update?: AlertDeliveryUpdateWithWhereUniqueWithoutOfferInput | AlertDeliveryUpdateWithWhereUniqueWithoutOfferInput[]
    updateMany?: AlertDeliveryUpdateManyWithWhereWithoutOfferInput | AlertDeliveryUpdateManyWithWhereWithoutOfferInput[]
    deleteMany?: AlertDeliveryScalarWhereInput | AlertDeliveryScalarWhereInput[]
  }

  export type CatalogItemUpdateOneRequiredWithoutOfferNestedInput = {
    create?: XOR<CatalogItemCreateWithoutOfferInput, CatalogItemUncheckedCreateWithoutOfferInput>
    connectOrCreate?: CatalogItemCreateOrConnectWithoutOfferInput
    upsert?: CatalogItemUpsertWithoutOfferInput
    connect?: CatalogItemWhereUniqueInput
    update?: XOR<XOR<CatalogItemUpdateToOneWithWhereWithoutOfferInput, CatalogItemUpdateWithoutOfferInput>, CatalogItemUncheckedUpdateWithoutOfferInput>
  }

  export type RetailerUpdateOneRequiredWithoutOffersNestedInput = {
    create?: XOR<RetailerCreateWithoutOffersInput, RetailerUncheckedCreateWithoutOffersInput>
    connectOrCreate?: RetailerCreateOrConnectWithoutOffersInput
    upsert?: RetailerUpsertWithoutOffersInput
    connect?: RetailerWhereUniqueInput
    update?: XOR<XOR<RetailerUpdateToOneWithWhereWithoutOffersInput, RetailerUpdateWithoutOffersInput>, RetailerUncheckedUpdateWithoutOffersInput>
  }

  export type AlertDeliveryUncheckedUpdateManyWithoutOfferNestedInput = {
    create?: XOR<AlertDeliveryCreateWithoutOfferInput, AlertDeliveryUncheckedCreateWithoutOfferInput> | AlertDeliveryCreateWithoutOfferInput[] | AlertDeliveryUncheckedCreateWithoutOfferInput[]
    connectOrCreate?: AlertDeliveryCreateOrConnectWithoutOfferInput | AlertDeliveryCreateOrConnectWithoutOfferInput[]
    upsert?: AlertDeliveryUpsertWithWhereUniqueWithoutOfferInput | AlertDeliveryUpsertWithWhereUniqueWithoutOfferInput[]
    createMany?: AlertDeliveryCreateManyOfferInputEnvelope
    set?: AlertDeliveryWhereUniqueInput | AlertDeliveryWhereUniqueInput[]
    disconnect?: AlertDeliveryWhereUniqueInput | AlertDeliveryWhereUniqueInput[]
    delete?: AlertDeliveryWhereUniqueInput | AlertDeliveryWhereUniqueInput[]
    connect?: AlertDeliveryWhereUniqueInput | AlertDeliveryWhereUniqueInput[]
    update?: AlertDeliveryUpdateWithWhereUniqueWithoutOfferInput | AlertDeliveryUpdateWithWhereUniqueWithoutOfferInput[]
    updateMany?: AlertDeliveryUpdateManyWithWhereWithoutOfferInput | AlertDeliveryUpdateManyWithWhereWithoutOfferInput[]
    deleteMany?: AlertDeliveryScalarWhereInput | AlertDeliveryScalarWhereInput[]
  }

  export type BlockedRetailerCreateNestedManyWithoutRetailerInput = {
    create?: XOR<BlockedRetailerCreateWithoutRetailerInput, BlockedRetailerUncheckedCreateWithoutRetailerInput> | BlockedRetailerCreateWithoutRetailerInput[] | BlockedRetailerUncheckedCreateWithoutRetailerInput[]
    connectOrCreate?: BlockedRetailerCreateOrConnectWithoutRetailerInput | BlockedRetailerCreateOrConnectWithoutRetailerInput[]
    createMany?: BlockedRetailerCreateManyRetailerInputEnvelope
    connect?: BlockedRetailerWhereUniqueInput | BlockedRetailerWhereUniqueInput[]
  }

  export type OfferCreateNestedManyWithoutRetailerInput = {
    create?: XOR<OfferCreateWithoutRetailerInput, OfferUncheckedCreateWithoutRetailerInput> | OfferCreateWithoutRetailerInput[] | OfferUncheckedCreateWithoutRetailerInput[]
    connectOrCreate?: OfferCreateOrConnectWithoutRetailerInput | OfferCreateOrConnectWithoutRetailerInput[]
    createMany?: OfferCreateManyRetailerInputEnvelope
    connect?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
  }

  export type BlockedRetailerUncheckedCreateNestedManyWithoutRetailerInput = {
    create?: XOR<BlockedRetailerCreateWithoutRetailerInput, BlockedRetailerUncheckedCreateWithoutRetailerInput> | BlockedRetailerCreateWithoutRetailerInput[] | BlockedRetailerUncheckedCreateWithoutRetailerInput[]
    connectOrCreate?: BlockedRetailerCreateOrConnectWithoutRetailerInput | BlockedRetailerCreateOrConnectWithoutRetailerInput[]
    createMany?: BlockedRetailerCreateManyRetailerInputEnvelope
    connect?: BlockedRetailerWhereUniqueInput | BlockedRetailerWhereUniqueInput[]
  }

  export type OfferUncheckedCreateNestedManyWithoutRetailerInput = {
    create?: XOR<OfferCreateWithoutRetailerInput, OfferUncheckedCreateWithoutRetailerInput> | OfferCreateWithoutRetailerInput[] | OfferUncheckedCreateWithoutRetailerInput[]
    connectOrCreate?: OfferCreateOrConnectWithoutRetailerInput | OfferCreateOrConnectWithoutRetailerInput[]
    createMany?: OfferCreateManyRetailerInputEnvelope
    connect?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
  }

  export type BlockedRetailerUpdateManyWithoutRetailerNestedInput = {
    create?: XOR<BlockedRetailerCreateWithoutRetailerInput, BlockedRetailerUncheckedCreateWithoutRetailerInput> | BlockedRetailerCreateWithoutRetailerInput[] | BlockedRetailerUncheckedCreateWithoutRetailerInput[]
    connectOrCreate?: BlockedRetailerCreateOrConnectWithoutRetailerInput | BlockedRetailerCreateOrConnectWithoutRetailerInput[]
    upsert?: BlockedRetailerUpsertWithWhereUniqueWithoutRetailerInput | BlockedRetailerUpsertWithWhereUniqueWithoutRetailerInput[]
    createMany?: BlockedRetailerCreateManyRetailerInputEnvelope
    set?: BlockedRetailerWhereUniqueInput | BlockedRetailerWhereUniqueInput[]
    disconnect?: BlockedRetailerWhereUniqueInput | BlockedRetailerWhereUniqueInput[]
    delete?: BlockedRetailerWhereUniqueInput | BlockedRetailerWhereUniqueInput[]
    connect?: BlockedRetailerWhereUniqueInput | BlockedRetailerWhereUniqueInput[]
    update?: BlockedRetailerUpdateWithWhereUniqueWithoutRetailerInput | BlockedRetailerUpdateWithWhereUniqueWithoutRetailerInput[]
    updateMany?: BlockedRetailerUpdateManyWithWhereWithoutRetailerInput | BlockedRetailerUpdateManyWithWhereWithoutRetailerInput[]
    deleteMany?: BlockedRetailerScalarWhereInput | BlockedRetailerScalarWhereInput[]
  }

  export type OfferUpdateManyWithoutRetailerNestedInput = {
    create?: XOR<OfferCreateWithoutRetailerInput, OfferUncheckedCreateWithoutRetailerInput> | OfferCreateWithoutRetailerInput[] | OfferUncheckedCreateWithoutRetailerInput[]
    connectOrCreate?: OfferCreateOrConnectWithoutRetailerInput | OfferCreateOrConnectWithoutRetailerInput[]
    upsert?: OfferUpsertWithWhereUniqueWithoutRetailerInput | OfferUpsertWithWhereUniqueWithoutRetailerInput[]
    createMany?: OfferCreateManyRetailerInputEnvelope
    set?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
    disconnect?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
    delete?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
    connect?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
    update?: OfferUpdateWithWhereUniqueWithoutRetailerInput | OfferUpdateWithWhereUniqueWithoutRetailerInput[]
    updateMany?: OfferUpdateManyWithWhereWithoutRetailerInput | OfferUpdateManyWithWhereWithoutRetailerInput[]
    deleteMany?: OfferScalarWhereInput | OfferScalarWhereInput[]
  }

  export type BlockedRetailerUncheckedUpdateManyWithoutRetailerNestedInput = {
    create?: XOR<BlockedRetailerCreateWithoutRetailerInput, BlockedRetailerUncheckedCreateWithoutRetailerInput> | BlockedRetailerCreateWithoutRetailerInput[] | BlockedRetailerUncheckedCreateWithoutRetailerInput[]
    connectOrCreate?: BlockedRetailerCreateOrConnectWithoutRetailerInput | BlockedRetailerCreateOrConnectWithoutRetailerInput[]
    upsert?: BlockedRetailerUpsertWithWhereUniqueWithoutRetailerInput | BlockedRetailerUpsertWithWhereUniqueWithoutRetailerInput[]
    createMany?: BlockedRetailerCreateManyRetailerInputEnvelope
    set?: BlockedRetailerWhereUniqueInput | BlockedRetailerWhereUniqueInput[]
    disconnect?: BlockedRetailerWhereUniqueInput | BlockedRetailerWhereUniqueInput[]
    delete?: BlockedRetailerWhereUniqueInput | BlockedRetailerWhereUniqueInput[]
    connect?: BlockedRetailerWhereUniqueInput | BlockedRetailerWhereUniqueInput[]
    update?: BlockedRetailerUpdateWithWhereUniqueWithoutRetailerInput | BlockedRetailerUpdateWithWhereUniqueWithoutRetailerInput[]
    updateMany?: BlockedRetailerUpdateManyWithWhereWithoutRetailerInput | BlockedRetailerUpdateManyWithWhereWithoutRetailerInput[]
    deleteMany?: BlockedRetailerScalarWhereInput | BlockedRetailerScalarWhereInput[]
  }

  export type OfferUncheckedUpdateManyWithoutRetailerNestedInput = {
    create?: XOR<OfferCreateWithoutRetailerInput, OfferUncheckedCreateWithoutRetailerInput> | OfferCreateWithoutRetailerInput[] | OfferUncheckedCreateWithoutRetailerInput[]
    connectOrCreate?: OfferCreateOrConnectWithoutRetailerInput | OfferCreateOrConnectWithoutRetailerInput[]
    upsert?: OfferUpsertWithWhereUniqueWithoutRetailerInput | OfferUpsertWithWhereUniqueWithoutRetailerInput[]
    createMany?: OfferCreateManyRetailerInputEnvelope
    set?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
    disconnect?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
    delete?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
    connect?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
    update?: OfferUpdateWithWhereUniqueWithoutRetailerInput | OfferUpdateWithWhereUniqueWithoutRetailerInput[]
    updateMany?: OfferUpdateManyWithWhereWithoutRetailerInput | OfferUpdateManyWithWhereWithoutRetailerInput[]
    deleteMany?: OfferScalarWhereInput | OfferScalarWhereInput[]
  }

  export type AccessorySpecsCreateNestedOneWithoutAccessoryFitmentInput = {
    create?: XOR<AccessorySpecsCreateWithoutAccessoryFitmentInput, AccessorySpecsUncheckedCreateWithoutAccessoryFitmentInput>
    connectOrCreate?: AccessorySpecsCreateOrConnectWithoutAccessoryFitmentInput
    connect?: AccessorySpecsWhereUniqueInput
  }

  export type CatalogItemCreateNestedOneWithoutAccessoryFitmentInput = {
    create?: XOR<CatalogItemCreateWithoutAccessoryFitmentInput, CatalogItemUncheckedCreateWithoutAccessoryFitmentInput>
    connectOrCreate?: CatalogItemCreateOrConnectWithoutAccessoryFitmentInput
    connect?: CatalogItemWhereUniqueInput
  }

  export type EnumFitmentTypeFieldUpdateOperationsInput = {
    set?: $Enums.FitmentType
  }

  export type AccessorySpecsUpdateOneRequiredWithoutAccessoryFitmentNestedInput = {
    create?: XOR<AccessorySpecsCreateWithoutAccessoryFitmentInput, AccessorySpecsUncheckedCreateWithoutAccessoryFitmentInput>
    connectOrCreate?: AccessorySpecsCreateOrConnectWithoutAccessoryFitmentInput
    upsert?: AccessorySpecsUpsertWithoutAccessoryFitmentInput
    connect?: AccessorySpecsWhereUniqueInput
    update?: XOR<XOR<AccessorySpecsUpdateToOneWithWhereWithoutAccessoryFitmentInput, AccessorySpecsUpdateWithoutAccessoryFitmentInput>, AccessorySpecsUncheckedUpdateWithoutAccessoryFitmentInput>
  }

  export type CatalogItemUpdateOneWithoutAccessoryFitmentNestedInput = {
    create?: XOR<CatalogItemCreateWithoutAccessoryFitmentInput, CatalogItemUncheckedCreateWithoutAccessoryFitmentInput>
    connectOrCreate?: CatalogItemCreateOrConnectWithoutAccessoryFitmentInput
    upsert?: CatalogItemUpsertWithoutAccessoryFitmentInput
    disconnect?: CatalogItemWhereInput | boolean
    delete?: CatalogItemWhereInput | boolean
    connect?: CatalogItemWhereUniqueInput
    update?: XOR<XOR<CatalogItemUpdateToOneWithWhereWithoutAccessoryFitmentInput, CatalogItemUpdateWithoutAccessoryFitmentInput>, CatalogItemUncheckedUpdateWithoutAccessoryFitmentInput>
  }

  export type AccessoryFitmentCreateNestedManyWithoutAccessorySpecsInput = {
    create?: XOR<AccessoryFitmentCreateWithoutAccessorySpecsInput, AccessoryFitmentUncheckedCreateWithoutAccessorySpecsInput> | AccessoryFitmentCreateWithoutAccessorySpecsInput[] | AccessoryFitmentUncheckedCreateWithoutAccessorySpecsInput[]
    connectOrCreate?: AccessoryFitmentCreateOrConnectWithoutAccessorySpecsInput | AccessoryFitmentCreateOrConnectWithoutAccessorySpecsInput[]
    createMany?: AccessoryFitmentCreateManyAccessorySpecsInputEnvelope
    connect?: AccessoryFitmentWhereUniqueInput | AccessoryFitmentWhereUniqueInput[]
  }

  export type AccessoryTypeCreateNestedOneWithoutAccessorySpecsInput = {
    create?: XOR<AccessoryTypeCreateWithoutAccessorySpecsInput, AccessoryTypeUncheckedCreateWithoutAccessorySpecsInput>
    connectOrCreate?: AccessoryTypeCreateOrConnectWithoutAccessorySpecsInput
    connect?: AccessoryTypeWhereUniqueInput
  }

  export type CatalogItemCreateNestedOneWithoutAccessorySpecsInput = {
    create?: XOR<CatalogItemCreateWithoutAccessorySpecsInput, CatalogItemUncheckedCreateWithoutAccessorySpecsInput>
    connectOrCreate?: CatalogItemCreateOrConnectWithoutAccessorySpecsInput
    connect?: CatalogItemWhereUniqueInput
  }

  export type AccessoryFitmentUncheckedCreateNestedManyWithoutAccessorySpecsInput = {
    create?: XOR<AccessoryFitmentCreateWithoutAccessorySpecsInput, AccessoryFitmentUncheckedCreateWithoutAccessorySpecsInput> | AccessoryFitmentCreateWithoutAccessorySpecsInput[] | AccessoryFitmentUncheckedCreateWithoutAccessorySpecsInput[]
    connectOrCreate?: AccessoryFitmentCreateOrConnectWithoutAccessorySpecsInput | AccessoryFitmentCreateOrConnectWithoutAccessorySpecsInput[]
    createMany?: AccessoryFitmentCreateManyAccessorySpecsInputEnvelope
    connect?: AccessoryFitmentWhereUniqueInput | AccessoryFitmentWhereUniqueInput[]
  }

  export type AccessoryFitmentUpdateManyWithoutAccessorySpecsNestedInput = {
    create?: XOR<AccessoryFitmentCreateWithoutAccessorySpecsInput, AccessoryFitmentUncheckedCreateWithoutAccessorySpecsInput> | AccessoryFitmentCreateWithoutAccessorySpecsInput[] | AccessoryFitmentUncheckedCreateWithoutAccessorySpecsInput[]
    connectOrCreate?: AccessoryFitmentCreateOrConnectWithoutAccessorySpecsInput | AccessoryFitmentCreateOrConnectWithoutAccessorySpecsInput[]
    upsert?: AccessoryFitmentUpsertWithWhereUniqueWithoutAccessorySpecsInput | AccessoryFitmentUpsertWithWhereUniqueWithoutAccessorySpecsInput[]
    createMany?: AccessoryFitmentCreateManyAccessorySpecsInputEnvelope
    set?: AccessoryFitmentWhereUniqueInput | AccessoryFitmentWhereUniqueInput[]
    disconnect?: AccessoryFitmentWhereUniqueInput | AccessoryFitmentWhereUniqueInput[]
    delete?: AccessoryFitmentWhereUniqueInput | AccessoryFitmentWhereUniqueInput[]
    connect?: AccessoryFitmentWhereUniqueInput | AccessoryFitmentWhereUniqueInput[]
    update?: AccessoryFitmentUpdateWithWhereUniqueWithoutAccessorySpecsInput | AccessoryFitmentUpdateWithWhereUniqueWithoutAccessorySpecsInput[]
    updateMany?: AccessoryFitmentUpdateManyWithWhereWithoutAccessorySpecsInput | AccessoryFitmentUpdateManyWithWhereWithoutAccessorySpecsInput[]
    deleteMany?: AccessoryFitmentScalarWhereInput | AccessoryFitmentScalarWhereInput[]
  }

  export type AccessoryTypeUpdateOneWithoutAccessorySpecsNestedInput = {
    create?: XOR<AccessoryTypeCreateWithoutAccessorySpecsInput, AccessoryTypeUncheckedCreateWithoutAccessorySpecsInput>
    connectOrCreate?: AccessoryTypeCreateOrConnectWithoutAccessorySpecsInput
    upsert?: AccessoryTypeUpsertWithoutAccessorySpecsInput
    disconnect?: AccessoryTypeWhereInput | boolean
    delete?: AccessoryTypeWhereInput | boolean
    connect?: AccessoryTypeWhereUniqueInput
    update?: XOR<XOR<AccessoryTypeUpdateToOneWithWhereWithoutAccessorySpecsInput, AccessoryTypeUpdateWithoutAccessorySpecsInput>, AccessoryTypeUncheckedUpdateWithoutAccessorySpecsInput>
  }

  export type CatalogItemUpdateOneRequiredWithoutAccessorySpecsNestedInput = {
    create?: XOR<CatalogItemCreateWithoutAccessorySpecsInput, CatalogItemUncheckedCreateWithoutAccessorySpecsInput>
    connectOrCreate?: CatalogItemCreateOrConnectWithoutAccessorySpecsInput
    upsert?: CatalogItemUpsertWithoutAccessorySpecsInput
    connect?: CatalogItemWhereUniqueInput
    update?: XOR<XOR<CatalogItemUpdateToOneWithWhereWithoutAccessorySpecsInput, CatalogItemUpdateWithoutAccessorySpecsInput>, CatalogItemUncheckedUpdateWithoutAccessorySpecsInput>
  }

  export type AccessoryFitmentUncheckedUpdateManyWithoutAccessorySpecsNestedInput = {
    create?: XOR<AccessoryFitmentCreateWithoutAccessorySpecsInput, AccessoryFitmentUncheckedCreateWithoutAccessorySpecsInput> | AccessoryFitmentCreateWithoutAccessorySpecsInput[] | AccessoryFitmentUncheckedCreateWithoutAccessorySpecsInput[]
    connectOrCreate?: AccessoryFitmentCreateOrConnectWithoutAccessorySpecsInput | AccessoryFitmentCreateOrConnectWithoutAccessorySpecsInput[]
    upsert?: AccessoryFitmentUpsertWithWhereUniqueWithoutAccessorySpecsInput | AccessoryFitmentUpsertWithWhereUniqueWithoutAccessorySpecsInput[]
    createMany?: AccessoryFitmentCreateManyAccessorySpecsInputEnvelope
    set?: AccessoryFitmentWhereUniqueInput | AccessoryFitmentWhereUniqueInput[]
    disconnect?: AccessoryFitmentWhereUniqueInput | AccessoryFitmentWhereUniqueInput[]
    delete?: AccessoryFitmentWhereUniqueInput | AccessoryFitmentWhereUniqueInput[]
    connect?: AccessoryFitmentWhereUniqueInput | AccessoryFitmentWhereUniqueInput[]
    update?: AccessoryFitmentUpdateWithWhereUniqueWithoutAccessorySpecsInput | AccessoryFitmentUpdateWithWhereUniqueWithoutAccessorySpecsInput[]
    updateMany?: AccessoryFitmentUpdateManyWithWhereWithoutAccessorySpecsInput | AccessoryFitmentUpdateManyWithWhereWithoutAccessorySpecsInput[]
    deleteMany?: AccessoryFitmentScalarWhereInput | AccessoryFitmentScalarWhereInput[]
  }

  export type AccessorySpecsCreateNestedManyWithoutAccessoryTypeInput = {
    create?: XOR<AccessorySpecsCreateWithoutAccessoryTypeInput, AccessorySpecsUncheckedCreateWithoutAccessoryTypeInput> | AccessorySpecsCreateWithoutAccessoryTypeInput[] | AccessorySpecsUncheckedCreateWithoutAccessoryTypeInput[]
    connectOrCreate?: AccessorySpecsCreateOrConnectWithoutAccessoryTypeInput | AccessorySpecsCreateOrConnectWithoutAccessoryTypeInput[]
    createMany?: AccessorySpecsCreateManyAccessoryTypeInputEnvelope
    connect?: AccessorySpecsWhereUniqueInput | AccessorySpecsWhereUniqueInput[]
  }

  export type AccessorySpecsUncheckedCreateNestedManyWithoutAccessoryTypeInput = {
    create?: XOR<AccessorySpecsCreateWithoutAccessoryTypeInput, AccessorySpecsUncheckedCreateWithoutAccessoryTypeInput> | AccessorySpecsCreateWithoutAccessoryTypeInput[] | AccessorySpecsUncheckedCreateWithoutAccessoryTypeInput[]
    connectOrCreate?: AccessorySpecsCreateOrConnectWithoutAccessoryTypeInput | AccessorySpecsCreateOrConnectWithoutAccessoryTypeInput[]
    createMany?: AccessorySpecsCreateManyAccessoryTypeInputEnvelope
    connect?: AccessorySpecsWhereUniqueInput | AccessorySpecsWhereUniqueInput[]
  }

  export type AccessorySpecsUpdateManyWithoutAccessoryTypeNestedInput = {
    create?: XOR<AccessorySpecsCreateWithoutAccessoryTypeInput, AccessorySpecsUncheckedCreateWithoutAccessoryTypeInput> | AccessorySpecsCreateWithoutAccessoryTypeInput[] | AccessorySpecsUncheckedCreateWithoutAccessoryTypeInput[]
    connectOrCreate?: AccessorySpecsCreateOrConnectWithoutAccessoryTypeInput | AccessorySpecsCreateOrConnectWithoutAccessoryTypeInput[]
    upsert?: AccessorySpecsUpsertWithWhereUniqueWithoutAccessoryTypeInput | AccessorySpecsUpsertWithWhereUniqueWithoutAccessoryTypeInput[]
    createMany?: AccessorySpecsCreateManyAccessoryTypeInputEnvelope
    set?: AccessorySpecsWhereUniqueInput | AccessorySpecsWhereUniqueInput[]
    disconnect?: AccessorySpecsWhereUniqueInput | AccessorySpecsWhereUniqueInput[]
    delete?: AccessorySpecsWhereUniqueInput | AccessorySpecsWhereUniqueInput[]
    connect?: AccessorySpecsWhereUniqueInput | AccessorySpecsWhereUniqueInput[]
    update?: AccessorySpecsUpdateWithWhereUniqueWithoutAccessoryTypeInput | AccessorySpecsUpdateWithWhereUniqueWithoutAccessoryTypeInput[]
    updateMany?: AccessorySpecsUpdateManyWithWhereWithoutAccessoryTypeInput | AccessorySpecsUpdateManyWithWhereWithoutAccessoryTypeInput[]
    deleteMany?: AccessorySpecsScalarWhereInput | AccessorySpecsScalarWhereInput[]
  }

  export type AccessorySpecsUncheckedUpdateManyWithoutAccessoryTypeNestedInput = {
    create?: XOR<AccessorySpecsCreateWithoutAccessoryTypeInput, AccessorySpecsUncheckedCreateWithoutAccessoryTypeInput> | AccessorySpecsCreateWithoutAccessoryTypeInput[] | AccessorySpecsUncheckedCreateWithoutAccessoryTypeInput[]
    connectOrCreate?: AccessorySpecsCreateOrConnectWithoutAccessoryTypeInput | AccessorySpecsCreateOrConnectWithoutAccessoryTypeInput[]
    upsert?: AccessorySpecsUpsertWithWhereUniqueWithoutAccessoryTypeInput | AccessorySpecsUpsertWithWhereUniqueWithoutAccessoryTypeInput[]
    createMany?: AccessorySpecsCreateManyAccessoryTypeInputEnvelope
    set?: AccessorySpecsWhereUniqueInput | AccessorySpecsWhereUniqueInput[]
    disconnect?: AccessorySpecsWhereUniqueInput | AccessorySpecsWhereUniqueInput[]
    delete?: AccessorySpecsWhereUniqueInput | AccessorySpecsWhereUniqueInput[]
    connect?: AccessorySpecsWhereUniqueInput | AccessorySpecsWhereUniqueInput[]
    update?: AccessorySpecsUpdateWithWhereUniqueWithoutAccessoryTypeInput | AccessorySpecsUpdateWithWhereUniqueWithoutAccessoryTypeInput[]
    updateMany?: AccessorySpecsUpdateManyWithWhereWithoutAccessoryTypeInput | AccessorySpecsUpdateManyWithWhereWithoutAccessoryTypeInput[]
    deleteMany?: AccessorySpecsScalarWhereInput | AccessorySpecsScalarWhereInput[]
  }

  export type CaliberCreateNestedOneWithoutAlertInput = {
    create?: XOR<CaliberCreateWithoutAlertInput, CaliberUncheckedCreateWithoutAlertInput>
    connectOrCreate?: CaliberCreateOrConnectWithoutAlertInput
    connect?: CaliberWhereUniqueInput
  }

  export type CatalogItemCreateNestedOneWithoutAlertInput = {
    create?: XOR<CatalogItemCreateWithoutAlertInput, CatalogItemUncheckedCreateWithoutAlertInput>
    connectOrCreate?: CatalogItemCreateOrConnectWithoutAlertInput
    connect?: CatalogItemWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAlertInput = {
    create?: XOR<UserCreateWithoutAlertInput, UserUncheckedCreateWithoutAlertInput>
    connectOrCreate?: UserCreateOrConnectWithoutAlertInput
    connect?: UserWhereUniqueInput
  }

  export type AlertDeliveryCreateNestedManyWithoutAlertInput = {
    create?: XOR<AlertDeliveryCreateWithoutAlertInput, AlertDeliveryUncheckedCreateWithoutAlertInput> | AlertDeliveryCreateWithoutAlertInput[] | AlertDeliveryUncheckedCreateWithoutAlertInput[]
    connectOrCreate?: AlertDeliveryCreateOrConnectWithoutAlertInput | AlertDeliveryCreateOrConnectWithoutAlertInput[]
    createMany?: AlertDeliveryCreateManyAlertInputEnvelope
    connect?: AlertDeliveryWhereUniqueInput | AlertDeliveryWhereUniqueInput[]
  }

  export type AlertDeliveryUncheckedCreateNestedManyWithoutAlertInput = {
    create?: XOR<AlertDeliveryCreateWithoutAlertInput, AlertDeliveryUncheckedCreateWithoutAlertInput> | AlertDeliveryCreateWithoutAlertInput[] | AlertDeliveryUncheckedCreateWithoutAlertInput[]
    connectOrCreate?: AlertDeliveryCreateOrConnectWithoutAlertInput | AlertDeliveryCreateOrConnectWithoutAlertInput[]
    createMany?: AlertDeliveryCreateManyAlertInputEnvelope
    connect?: AlertDeliveryWhereUniqueInput | AlertDeliveryWhereUniqueInput[]
  }

  export type EnumAlertTypeFieldUpdateOperationsInput = {
    set?: $Enums.AlertType
  }

  export type CaliberUpdateOneWithoutAlertNestedInput = {
    create?: XOR<CaliberCreateWithoutAlertInput, CaliberUncheckedCreateWithoutAlertInput>
    connectOrCreate?: CaliberCreateOrConnectWithoutAlertInput
    upsert?: CaliberUpsertWithoutAlertInput
    disconnect?: CaliberWhereInput | boolean
    delete?: CaliberWhereInput | boolean
    connect?: CaliberWhereUniqueInput
    update?: XOR<XOR<CaliberUpdateToOneWithWhereWithoutAlertInput, CaliberUpdateWithoutAlertInput>, CaliberUncheckedUpdateWithoutAlertInput>
  }

  export type CatalogItemUpdateOneWithoutAlertNestedInput = {
    create?: XOR<CatalogItemCreateWithoutAlertInput, CatalogItemUncheckedCreateWithoutAlertInput>
    connectOrCreate?: CatalogItemCreateOrConnectWithoutAlertInput
    upsert?: CatalogItemUpsertWithoutAlertInput
    disconnect?: CatalogItemWhereInput | boolean
    delete?: CatalogItemWhereInput | boolean
    connect?: CatalogItemWhereUniqueInput
    update?: XOR<XOR<CatalogItemUpdateToOneWithWhereWithoutAlertInput, CatalogItemUpdateWithoutAlertInput>, CatalogItemUncheckedUpdateWithoutAlertInput>
  }

  export type UserUpdateOneRequiredWithoutAlertNestedInput = {
    create?: XOR<UserCreateWithoutAlertInput, UserUncheckedCreateWithoutAlertInput>
    connectOrCreate?: UserCreateOrConnectWithoutAlertInput
    upsert?: UserUpsertWithoutAlertInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAlertInput, UserUpdateWithoutAlertInput>, UserUncheckedUpdateWithoutAlertInput>
  }

  export type AlertDeliveryUpdateManyWithoutAlertNestedInput = {
    create?: XOR<AlertDeliveryCreateWithoutAlertInput, AlertDeliveryUncheckedCreateWithoutAlertInput> | AlertDeliveryCreateWithoutAlertInput[] | AlertDeliveryUncheckedCreateWithoutAlertInput[]
    connectOrCreate?: AlertDeliveryCreateOrConnectWithoutAlertInput | AlertDeliveryCreateOrConnectWithoutAlertInput[]
    upsert?: AlertDeliveryUpsertWithWhereUniqueWithoutAlertInput | AlertDeliveryUpsertWithWhereUniqueWithoutAlertInput[]
    createMany?: AlertDeliveryCreateManyAlertInputEnvelope
    set?: AlertDeliveryWhereUniqueInput | AlertDeliveryWhereUniqueInput[]
    disconnect?: AlertDeliveryWhereUniqueInput | AlertDeliveryWhereUniqueInput[]
    delete?: AlertDeliveryWhereUniqueInput | AlertDeliveryWhereUniqueInput[]
    connect?: AlertDeliveryWhereUniqueInput | AlertDeliveryWhereUniqueInput[]
    update?: AlertDeliveryUpdateWithWhereUniqueWithoutAlertInput | AlertDeliveryUpdateWithWhereUniqueWithoutAlertInput[]
    updateMany?: AlertDeliveryUpdateManyWithWhereWithoutAlertInput | AlertDeliveryUpdateManyWithWhereWithoutAlertInput[]
    deleteMany?: AlertDeliveryScalarWhereInput | AlertDeliveryScalarWhereInput[]
  }

  export type AlertDeliveryUncheckedUpdateManyWithoutAlertNestedInput = {
    create?: XOR<AlertDeliveryCreateWithoutAlertInput, AlertDeliveryUncheckedCreateWithoutAlertInput> | AlertDeliveryCreateWithoutAlertInput[] | AlertDeliveryUncheckedCreateWithoutAlertInput[]
    connectOrCreate?: AlertDeliveryCreateOrConnectWithoutAlertInput | AlertDeliveryCreateOrConnectWithoutAlertInput[]
    upsert?: AlertDeliveryUpsertWithWhereUniqueWithoutAlertInput | AlertDeliveryUpsertWithWhereUniqueWithoutAlertInput[]
    createMany?: AlertDeliveryCreateManyAlertInputEnvelope
    set?: AlertDeliveryWhereUniqueInput | AlertDeliveryWhereUniqueInput[]
    disconnect?: AlertDeliveryWhereUniqueInput | AlertDeliveryWhereUniqueInput[]
    delete?: AlertDeliveryWhereUniqueInput | AlertDeliveryWhereUniqueInput[]
    connect?: AlertDeliveryWhereUniqueInput | AlertDeliveryWhereUniqueInput[]
    update?: AlertDeliveryUpdateWithWhereUniqueWithoutAlertInput | AlertDeliveryUpdateWithWhereUniqueWithoutAlertInput[]
    updateMany?: AlertDeliveryUpdateManyWithWhereWithoutAlertInput | AlertDeliveryUpdateManyWithWhereWithoutAlertInput[]
    deleteMany?: AlertDeliveryScalarWhereInput | AlertDeliveryScalarWhereInput[]
  }

  export type AlertCreateNestedOneWithoutAlertDeliveryInput = {
    create?: XOR<AlertCreateWithoutAlertDeliveryInput, AlertUncheckedCreateWithoutAlertDeliveryInput>
    connectOrCreate?: AlertCreateOrConnectWithoutAlertDeliveryInput
    connect?: AlertWhereUniqueInput
  }

  export type OfferCreateNestedOneWithoutAlertDeliveryInput = {
    create?: XOR<OfferCreateWithoutAlertDeliveryInput, OfferUncheckedCreateWithoutAlertDeliveryInput>
    connectOrCreate?: OfferCreateOrConnectWithoutAlertDeliveryInput
    connect?: OfferWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAlertDeliveryInput = {
    create?: XOR<UserCreateWithoutAlertDeliveryInput, UserUncheckedCreateWithoutAlertDeliveryInput>
    connectOrCreate?: UserCreateOrConnectWithoutAlertDeliveryInput
    connect?: UserWhereUniqueInput
  }

  export type AlertUpdateOneRequiredWithoutAlertDeliveryNestedInput = {
    create?: XOR<AlertCreateWithoutAlertDeliveryInput, AlertUncheckedCreateWithoutAlertDeliveryInput>
    connectOrCreate?: AlertCreateOrConnectWithoutAlertDeliveryInput
    upsert?: AlertUpsertWithoutAlertDeliveryInput
    connect?: AlertWhereUniqueInput
    update?: XOR<XOR<AlertUpdateToOneWithWhereWithoutAlertDeliveryInput, AlertUpdateWithoutAlertDeliveryInput>, AlertUncheckedUpdateWithoutAlertDeliveryInput>
  }

  export type OfferUpdateOneWithoutAlertDeliveryNestedInput = {
    create?: XOR<OfferCreateWithoutAlertDeliveryInput, OfferUncheckedCreateWithoutAlertDeliveryInput>
    connectOrCreate?: OfferCreateOrConnectWithoutAlertDeliveryInput
    upsert?: OfferUpsertWithoutAlertDeliveryInput
    disconnect?: OfferWhereInput | boolean
    delete?: OfferWhereInput | boolean
    connect?: OfferWhereUniqueInput
    update?: XOR<XOR<OfferUpdateToOneWithWhereWithoutAlertDeliveryInput, OfferUpdateWithoutAlertDeliveryInput>, OfferUncheckedUpdateWithoutAlertDeliveryInput>
  }

  export type UserUpdateOneRequiredWithoutAlertDeliveryNestedInput = {
    create?: XOR<UserCreateWithoutAlertDeliveryInput, UserUncheckedCreateWithoutAlertDeliveryInput>
    connectOrCreate?: UserCreateOrConnectWithoutAlertDeliveryInput
    upsert?: UserUpsertWithoutAlertDeliveryInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAlertDeliveryInput, UserUpdateWithoutAlertDeliveryInput>, UserUncheckedUpdateWithoutAlertDeliveryInput>
  }

  export type AmmoSpecsCreaterestrictionsInput = {
    set: string[]
  }

  export type CaliberCreateNestedOneWithoutAmmoSpecsInput = {
    create?: XOR<CaliberCreateWithoutAmmoSpecsInput, CaliberUncheckedCreateWithoutAmmoSpecsInput>
    connectOrCreate?: CaliberCreateOrConnectWithoutAmmoSpecsInput
    connect?: CaliberWhereUniqueInput
  }

  export type CatalogItemCreateNestedOneWithoutAmmoSpecsInput = {
    create?: XOR<CatalogItemCreateWithoutAmmoSpecsInput, CatalogItemUncheckedCreateWithoutAmmoSpecsInput>
    connectOrCreate?: CatalogItemCreateOrConnectWithoutAmmoSpecsInput
    connect?: CatalogItemWhereUniqueInput
  }

  export type AmmoSpecsUpdaterestrictionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableEnumAmmoPressureFieldUpdateOperationsInput = {
    set?: $Enums.AmmoPressure | null
  }

  export type CaliberUpdateOneRequiredWithoutAmmoSpecsNestedInput = {
    create?: XOR<CaliberCreateWithoutAmmoSpecsInput, CaliberUncheckedCreateWithoutAmmoSpecsInput>
    connectOrCreate?: CaliberCreateOrConnectWithoutAmmoSpecsInput
    upsert?: CaliberUpsertWithoutAmmoSpecsInput
    connect?: CaliberWhereUniqueInput
    update?: XOR<XOR<CaliberUpdateToOneWithWhereWithoutAmmoSpecsInput, CaliberUpdateWithoutAmmoSpecsInput>, CaliberUncheckedUpdateWithoutAmmoSpecsInput>
  }

  export type CatalogItemUpdateOneRequiredWithoutAmmoSpecsNestedInput = {
    create?: XOR<CatalogItemCreateWithoutAmmoSpecsInput, CatalogItemUncheckedCreateWithoutAmmoSpecsInput>
    connectOrCreate?: CatalogItemCreateOrConnectWithoutAmmoSpecsInput
    upsert?: CatalogItemUpsertWithoutAmmoSpecsInput
    connect?: CatalogItemWhereUniqueInput
    update?: XOR<XOR<CatalogItemUpdateToOneWithWhereWithoutAmmoSpecsInput, CatalogItemUpdateWithoutAmmoSpecsInput>, CatalogItemUncheckedUpdateWithoutAmmoSpecsInput>
  }

  export type RetailerCreateNestedOneWithoutBlockedRetailerInput = {
    create?: XOR<RetailerCreateWithoutBlockedRetailerInput, RetailerUncheckedCreateWithoutBlockedRetailerInput>
    connectOrCreate?: RetailerCreateOrConnectWithoutBlockedRetailerInput
    connect?: RetailerWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutBlockedRetailerInput = {
    create?: XOR<UserCreateWithoutBlockedRetailerInput, UserUncheckedCreateWithoutBlockedRetailerInput>
    connectOrCreate?: UserCreateOrConnectWithoutBlockedRetailerInput
    connect?: UserWhereUniqueInput
  }

  export type RetailerUpdateOneRequiredWithoutBlockedRetailerNestedInput = {
    create?: XOR<RetailerCreateWithoutBlockedRetailerInput, RetailerUncheckedCreateWithoutBlockedRetailerInput>
    connectOrCreate?: RetailerCreateOrConnectWithoutBlockedRetailerInput
    upsert?: RetailerUpsertWithoutBlockedRetailerInput
    connect?: RetailerWhereUniqueInput
    update?: XOR<XOR<RetailerUpdateToOneWithWhereWithoutBlockedRetailerInput, RetailerUpdateWithoutBlockedRetailerInput>, RetailerUncheckedUpdateWithoutBlockedRetailerInput>
  }

  export type UserUpdateOneRequiredWithoutBlockedRetailerNestedInput = {
    create?: XOR<UserCreateWithoutBlockedRetailerInput, UserUncheckedCreateWithoutBlockedRetailerInput>
    connectOrCreate?: UserCreateOrConnectWithoutBlockedRetailerInput
    upsert?: UserUpsertWithoutBlockedRetailerInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBlockedRetailerInput, UserUpdateWithoutBlockedRetailerInput>, UserUncheckedUpdateWithoutBlockedRetailerInput>
  }

  export type CaliberCreateNestedOneWithoutCaliberAliasInput = {
    create?: XOR<CaliberCreateWithoutCaliberAliasInput, CaliberUncheckedCreateWithoutCaliberAliasInput>
    connectOrCreate?: CaliberCreateOrConnectWithoutCaliberAliasInput
    connect?: CaliberWhereUniqueInput
  }

  export type CaliberUpdateOneRequiredWithoutCaliberAliasNestedInput = {
    create?: XOR<CaliberCreateWithoutCaliberAliasInput, CaliberUncheckedCreateWithoutCaliberAliasInput>
    connectOrCreate?: CaliberCreateOrConnectWithoutCaliberAliasInput
    upsert?: CaliberUpsertWithoutCaliberAliasInput
    connect?: CaliberWhereUniqueInput
    update?: XOR<XOR<CaliberUpdateToOneWithWhereWithoutCaliberAliasInput, CaliberUpdateWithoutCaliberAliasInput>, CaliberUncheckedUpdateWithoutCaliberAliasInput>
  }

  export type AccessoryFitmentCreateNestedManyWithoutCatalogItemInput = {
    create?: XOR<AccessoryFitmentCreateWithoutCatalogItemInput, AccessoryFitmentUncheckedCreateWithoutCatalogItemInput> | AccessoryFitmentCreateWithoutCatalogItemInput[] | AccessoryFitmentUncheckedCreateWithoutCatalogItemInput[]
    connectOrCreate?: AccessoryFitmentCreateOrConnectWithoutCatalogItemInput | AccessoryFitmentCreateOrConnectWithoutCatalogItemInput[]
    createMany?: AccessoryFitmentCreateManyCatalogItemInputEnvelope
    connect?: AccessoryFitmentWhereUniqueInput | AccessoryFitmentWhereUniqueInput[]
  }

  export type AccessorySpecsCreateNestedOneWithoutCatalogItemInput = {
    create?: XOR<AccessorySpecsCreateWithoutCatalogItemInput, AccessorySpecsUncheckedCreateWithoutCatalogItemInput>
    connectOrCreate?: AccessorySpecsCreateOrConnectWithoutCatalogItemInput
    connect?: AccessorySpecsWhereUniqueInput
  }

  export type AlertCreateNestedManyWithoutCatalogItemInput = {
    create?: XOR<AlertCreateWithoutCatalogItemInput, AlertUncheckedCreateWithoutCatalogItemInput> | AlertCreateWithoutCatalogItemInput[] | AlertUncheckedCreateWithoutCatalogItemInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutCatalogItemInput | AlertCreateOrConnectWithoutCatalogItemInput[]
    createMany?: AlertCreateManyCatalogItemInputEnvelope
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
  }

  export type AmmoSpecsCreateNestedOneWithoutCatalogItemInput = {
    create?: XOR<AmmoSpecsCreateWithoutCatalogItemInput, AmmoSpecsUncheckedCreateWithoutCatalogItemInput>
    connectOrCreate?: AmmoSpecsCreateOrConnectWithoutCatalogItemInput
    connect?: AmmoSpecsWhereUniqueInput
  }

  export type BrandCreateNestedOneWithoutCatalogItemInput = {
    create?: XOR<BrandCreateWithoutCatalogItemInput, BrandUncheckedCreateWithoutCatalogItemInput>
    connectOrCreate?: BrandCreateOrConnectWithoutCatalogItemInput
    connect?: BrandWhereUniqueInput
  }

  export type FirearmSpecsCreateNestedOneWithoutCatalogItemInput = {
    create?: XOR<FirearmSpecsCreateWithoutCatalogItemInput, FirearmSpecsUncheckedCreateWithoutCatalogItemInput>
    connectOrCreate?: FirearmSpecsCreateOrConnectWithoutCatalogItemInput
    connect?: FirearmSpecsWhereUniqueInput
  }

  export type OfferCreateNestedManyWithoutCatalogItemInput = {
    create?: XOR<OfferCreateWithoutCatalogItemInput, OfferUncheckedCreateWithoutCatalogItemInput> | OfferCreateWithoutCatalogItemInput[] | OfferUncheckedCreateWithoutCatalogItemInput[]
    connectOrCreate?: OfferCreateOrConnectWithoutCatalogItemInput | OfferCreateOrConnectWithoutCatalogItemInput[]
    createMany?: OfferCreateManyCatalogItemInputEnvelope
    connect?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
  }

  export type OwnedFirearmCreateNestedManyWithoutCatalogItemInput = {
    create?: XOR<OwnedFirearmCreateWithoutCatalogItemInput, OwnedFirearmUncheckedCreateWithoutCatalogItemInput> | OwnedFirearmCreateWithoutCatalogItemInput[] | OwnedFirearmUncheckedCreateWithoutCatalogItemInput[]
    connectOrCreate?: OwnedFirearmCreateOrConnectWithoutCatalogItemInput | OwnedFirearmCreateOrConnectWithoutCatalogItemInput[]
    createMany?: OwnedFirearmCreateManyCatalogItemInputEnvelope
    connect?: OwnedFirearmWhereUniqueInput | OwnedFirearmWhereUniqueInput[]
  }

  export type AccessoryFitmentUncheckedCreateNestedManyWithoutCatalogItemInput = {
    create?: XOR<AccessoryFitmentCreateWithoutCatalogItemInput, AccessoryFitmentUncheckedCreateWithoutCatalogItemInput> | AccessoryFitmentCreateWithoutCatalogItemInput[] | AccessoryFitmentUncheckedCreateWithoutCatalogItemInput[]
    connectOrCreate?: AccessoryFitmentCreateOrConnectWithoutCatalogItemInput | AccessoryFitmentCreateOrConnectWithoutCatalogItemInput[]
    createMany?: AccessoryFitmentCreateManyCatalogItemInputEnvelope
    connect?: AccessoryFitmentWhereUniqueInput | AccessoryFitmentWhereUniqueInput[]
  }

  export type AccessorySpecsUncheckedCreateNestedOneWithoutCatalogItemInput = {
    create?: XOR<AccessorySpecsCreateWithoutCatalogItemInput, AccessorySpecsUncheckedCreateWithoutCatalogItemInput>
    connectOrCreate?: AccessorySpecsCreateOrConnectWithoutCatalogItemInput
    connect?: AccessorySpecsWhereUniqueInput
  }

  export type AlertUncheckedCreateNestedManyWithoutCatalogItemInput = {
    create?: XOR<AlertCreateWithoutCatalogItemInput, AlertUncheckedCreateWithoutCatalogItemInput> | AlertCreateWithoutCatalogItemInput[] | AlertUncheckedCreateWithoutCatalogItemInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutCatalogItemInput | AlertCreateOrConnectWithoutCatalogItemInput[]
    createMany?: AlertCreateManyCatalogItemInputEnvelope
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
  }

  export type AmmoSpecsUncheckedCreateNestedOneWithoutCatalogItemInput = {
    create?: XOR<AmmoSpecsCreateWithoutCatalogItemInput, AmmoSpecsUncheckedCreateWithoutCatalogItemInput>
    connectOrCreate?: AmmoSpecsCreateOrConnectWithoutCatalogItemInput
    connect?: AmmoSpecsWhereUniqueInput
  }

  export type FirearmSpecsUncheckedCreateNestedOneWithoutCatalogItemInput = {
    create?: XOR<FirearmSpecsCreateWithoutCatalogItemInput, FirearmSpecsUncheckedCreateWithoutCatalogItemInput>
    connectOrCreate?: FirearmSpecsCreateOrConnectWithoutCatalogItemInput
    connect?: FirearmSpecsWhereUniqueInput
  }

  export type OfferUncheckedCreateNestedManyWithoutCatalogItemInput = {
    create?: XOR<OfferCreateWithoutCatalogItemInput, OfferUncheckedCreateWithoutCatalogItemInput> | OfferCreateWithoutCatalogItemInput[] | OfferUncheckedCreateWithoutCatalogItemInput[]
    connectOrCreate?: OfferCreateOrConnectWithoutCatalogItemInput | OfferCreateOrConnectWithoutCatalogItemInput[]
    createMany?: OfferCreateManyCatalogItemInputEnvelope
    connect?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
  }

  export type OwnedFirearmUncheckedCreateNestedManyWithoutCatalogItemInput = {
    create?: XOR<OwnedFirearmCreateWithoutCatalogItemInput, OwnedFirearmUncheckedCreateWithoutCatalogItemInput> | OwnedFirearmCreateWithoutCatalogItemInput[] | OwnedFirearmUncheckedCreateWithoutCatalogItemInput[]
    connectOrCreate?: OwnedFirearmCreateOrConnectWithoutCatalogItemInput | OwnedFirearmCreateOrConnectWithoutCatalogItemInput[]
    createMany?: OwnedFirearmCreateManyCatalogItemInputEnvelope
    connect?: OwnedFirearmWhereUniqueInput | OwnedFirearmWhereUniqueInput[]
  }

  export type EnumCatalogKindFieldUpdateOperationsInput = {
    set?: $Enums.CatalogKind
  }

  export type AccessoryFitmentUpdateManyWithoutCatalogItemNestedInput = {
    create?: XOR<AccessoryFitmentCreateWithoutCatalogItemInput, AccessoryFitmentUncheckedCreateWithoutCatalogItemInput> | AccessoryFitmentCreateWithoutCatalogItemInput[] | AccessoryFitmentUncheckedCreateWithoutCatalogItemInput[]
    connectOrCreate?: AccessoryFitmentCreateOrConnectWithoutCatalogItemInput | AccessoryFitmentCreateOrConnectWithoutCatalogItemInput[]
    upsert?: AccessoryFitmentUpsertWithWhereUniqueWithoutCatalogItemInput | AccessoryFitmentUpsertWithWhereUniqueWithoutCatalogItemInput[]
    createMany?: AccessoryFitmentCreateManyCatalogItemInputEnvelope
    set?: AccessoryFitmentWhereUniqueInput | AccessoryFitmentWhereUniqueInput[]
    disconnect?: AccessoryFitmentWhereUniqueInput | AccessoryFitmentWhereUniqueInput[]
    delete?: AccessoryFitmentWhereUniqueInput | AccessoryFitmentWhereUniqueInput[]
    connect?: AccessoryFitmentWhereUniqueInput | AccessoryFitmentWhereUniqueInput[]
    update?: AccessoryFitmentUpdateWithWhereUniqueWithoutCatalogItemInput | AccessoryFitmentUpdateWithWhereUniqueWithoutCatalogItemInput[]
    updateMany?: AccessoryFitmentUpdateManyWithWhereWithoutCatalogItemInput | AccessoryFitmentUpdateManyWithWhereWithoutCatalogItemInput[]
    deleteMany?: AccessoryFitmentScalarWhereInput | AccessoryFitmentScalarWhereInput[]
  }

  export type AccessorySpecsUpdateOneWithoutCatalogItemNestedInput = {
    create?: XOR<AccessorySpecsCreateWithoutCatalogItemInput, AccessorySpecsUncheckedCreateWithoutCatalogItemInput>
    connectOrCreate?: AccessorySpecsCreateOrConnectWithoutCatalogItemInput
    upsert?: AccessorySpecsUpsertWithoutCatalogItemInput
    disconnect?: AccessorySpecsWhereInput | boolean
    delete?: AccessorySpecsWhereInput | boolean
    connect?: AccessorySpecsWhereUniqueInput
    update?: XOR<XOR<AccessorySpecsUpdateToOneWithWhereWithoutCatalogItemInput, AccessorySpecsUpdateWithoutCatalogItemInput>, AccessorySpecsUncheckedUpdateWithoutCatalogItemInput>
  }

  export type AlertUpdateManyWithoutCatalogItemNestedInput = {
    create?: XOR<AlertCreateWithoutCatalogItemInput, AlertUncheckedCreateWithoutCatalogItemInput> | AlertCreateWithoutCatalogItemInput[] | AlertUncheckedCreateWithoutCatalogItemInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutCatalogItemInput | AlertCreateOrConnectWithoutCatalogItemInput[]
    upsert?: AlertUpsertWithWhereUniqueWithoutCatalogItemInput | AlertUpsertWithWhereUniqueWithoutCatalogItemInput[]
    createMany?: AlertCreateManyCatalogItemInputEnvelope
    set?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    disconnect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    delete?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    update?: AlertUpdateWithWhereUniqueWithoutCatalogItemInput | AlertUpdateWithWhereUniqueWithoutCatalogItemInput[]
    updateMany?: AlertUpdateManyWithWhereWithoutCatalogItemInput | AlertUpdateManyWithWhereWithoutCatalogItemInput[]
    deleteMany?: AlertScalarWhereInput | AlertScalarWhereInput[]
  }

  export type AmmoSpecsUpdateOneWithoutCatalogItemNestedInput = {
    create?: XOR<AmmoSpecsCreateWithoutCatalogItemInput, AmmoSpecsUncheckedCreateWithoutCatalogItemInput>
    connectOrCreate?: AmmoSpecsCreateOrConnectWithoutCatalogItemInput
    upsert?: AmmoSpecsUpsertWithoutCatalogItemInput
    disconnect?: AmmoSpecsWhereInput | boolean
    delete?: AmmoSpecsWhereInput | boolean
    connect?: AmmoSpecsWhereUniqueInput
    update?: XOR<XOR<AmmoSpecsUpdateToOneWithWhereWithoutCatalogItemInput, AmmoSpecsUpdateWithoutCatalogItemInput>, AmmoSpecsUncheckedUpdateWithoutCatalogItemInput>
  }

  export type BrandUpdateOneWithoutCatalogItemNestedInput = {
    create?: XOR<BrandCreateWithoutCatalogItemInput, BrandUncheckedCreateWithoutCatalogItemInput>
    connectOrCreate?: BrandCreateOrConnectWithoutCatalogItemInput
    upsert?: BrandUpsertWithoutCatalogItemInput
    disconnect?: BrandWhereInput | boolean
    delete?: BrandWhereInput | boolean
    connect?: BrandWhereUniqueInput
    update?: XOR<XOR<BrandUpdateToOneWithWhereWithoutCatalogItemInput, BrandUpdateWithoutCatalogItemInput>, BrandUncheckedUpdateWithoutCatalogItemInput>
  }

  export type FirearmSpecsUpdateOneWithoutCatalogItemNestedInput = {
    create?: XOR<FirearmSpecsCreateWithoutCatalogItemInput, FirearmSpecsUncheckedCreateWithoutCatalogItemInput>
    connectOrCreate?: FirearmSpecsCreateOrConnectWithoutCatalogItemInput
    upsert?: FirearmSpecsUpsertWithoutCatalogItemInput
    disconnect?: FirearmSpecsWhereInput | boolean
    delete?: FirearmSpecsWhereInput | boolean
    connect?: FirearmSpecsWhereUniqueInput
    update?: XOR<XOR<FirearmSpecsUpdateToOneWithWhereWithoutCatalogItemInput, FirearmSpecsUpdateWithoutCatalogItemInput>, FirearmSpecsUncheckedUpdateWithoutCatalogItemInput>
  }

  export type OfferUpdateManyWithoutCatalogItemNestedInput = {
    create?: XOR<OfferCreateWithoutCatalogItemInput, OfferUncheckedCreateWithoutCatalogItemInput> | OfferCreateWithoutCatalogItemInput[] | OfferUncheckedCreateWithoutCatalogItemInput[]
    connectOrCreate?: OfferCreateOrConnectWithoutCatalogItemInput | OfferCreateOrConnectWithoutCatalogItemInput[]
    upsert?: OfferUpsertWithWhereUniqueWithoutCatalogItemInput | OfferUpsertWithWhereUniqueWithoutCatalogItemInput[]
    createMany?: OfferCreateManyCatalogItemInputEnvelope
    set?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
    disconnect?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
    delete?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
    connect?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
    update?: OfferUpdateWithWhereUniqueWithoutCatalogItemInput | OfferUpdateWithWhereUniqueWithoutCatalogItemInput[]
    updateMany?: OfferUpdateManyWithWhereWithoutCatalogItemInput | OfferUpdateManyWithWhereWithoutCatalogItemInput[]
    deleteMany?: OfferScalarWhereInput | OfferScalarWhereInput[]
  }

  export type OwnedFirearmUpdateManyWithoutCatalogItemNestedInput = {
    create?: XOR<OwnedFirearmCreateWithoutCatalogItemInput, OwnedFirearmUncheckedCreateWithoutCatalogItemInput> | OwnedFirearmCreateWithoutCatalogItemInput[] | OwnedFirearmUncheckedCreateWithoutCatalogItemInput[]
    connectOrCreate?: OwnedFirearmCreateOrConnectWithoutCatalogItemInput | OwnedFirearmCreateOrConnectWithoutCatalogItemInput[]
    upsert?: OwnedFirearmUpsertWithWhereUniqueWithoutCatalogItemInput | OwnedFirearmUpsertWithWhereUniqueWithoutCatalogItemInput[]
    createMany?: OwnedFirearmCreateManyCatalogItemInputEnvelope
    set?: OwnedFirearmWhereUniqueInput | OwnedFirearmWhereUniqueInput[]
    disconnect?: OwnedFirearmWhereUniqueInput | OwnedFirearmWhereUniqueInput[]
    delete?: OwnedFirearmWhereUniqueInput | OwnedFirearmWhereUniqueInput[]
    connect?: OwnedFirearmWhereUniqueInput | OwnedFirearmWhereUniqueInput[]
    update?: OwnedFirearmUpdateWithWhereUniqueWithoutCatalogItemInput | OwnedFirearmUpdateWithWhereUniqueWithoutCatalogItemInput[]
    updateMany?: OwnedFirearmUpdateManyWithWhereWithoutCatalogItemInput | OwnedFirearmUpdateManyWithWhereWithoutCatalogItemInput[]
    deleteMany?: OwnedFirearmScalarWhereInput | OwnedFirearmScalarWhereInput[]
  }

  export type AccessoryFitmentUncheckedUpdateManyWithoutCatalogItemNestedInput = {
    create?: XOR<AccessoryFitmentCreateWithoutCatalogItemInput, AccessoryFitmentUncheckedCreateWithoutCatalogItemInput> | AccessoryFitmentCreateWithoutCatalogItemInput[] | AccessoryFitmentUncheckedCreateWithoutCatalogItemInput[]
    connectOrCreate?: AccessoryFitmentCreateOrConnectWithoutCatalogItemInput | AccessoryFitmentCreateOrConnectWithoutCatalogItemInput[]
    upsert?: AccessoryFitmentUpsertWithWhereUniqueWithoutCatalogItemInput | AccessoryFitmentUpsertWithWhereUniqueWithoutCatalogItemInput[]
    createMany?: AccessoryFitmentCreateManyCatalogItemInputEnvelope
    set?: AccessoryFitmentWhereUniqueInput | AccessoryFitmentWhereUniqueInput[]
    disconnect?: AccessoryFitmentWhereUniqueInput | AccessoryFitmentWhereUniqueInput[]
    delete?: AccessoryFitmentWhereUniqueInput | AccessoryFitmentWhereUniqueInput[]
    connect?: AccessoryFitmentWhereUniqueInput | AccessoryFitmentWhereUniqueInput[]
    update?: AccessoryFitmentUpdateWithWhereUniqueWithoutCatalogItemInput | AccessoryFitmentUpdateWithWhereUniqueWithoutCatalogItemInput[]
    updateMany?: AccessoryFitmentUpdateManyWithWhereWithoutCatalogItemInput | AccessoryFitmentUpdateManyWithWhereWithoutCatalogItemInput[]
    deleteMany?: AccessoryFitmentScalarWhereInput | AccessoryFitmentScalarWhereInput[]
  }

  export type AccessorySpecsUncheckedUpdateOneWithoutCatalogItemNestedInput = {
    create?: XOR<AccessorySpecsCreateWithoutCatalogItemInput, AccessorySpecsUncheckedCreateWithoutCatalogItemInput>
    connectOrCreate?: AccessorySpecsCreateOrConnectWithoutCatalogItemInput
    upsert?: AccessorySpecsUpsertWithoutCatalogItemInput
    disconnect?: AccessorySpecsWhereInput | boolean
    delete?: AccessorySpecsWhereInput | boolean
    connect?: AccessorySpecsWhereUniqueInput
    update?: XOR<XOR<AccessorySpecsUpdateToOneWithWhereWithoutCatalogItemInput, AccessorySpecsUpdateWithoutCatalogItemInput>, AccessorySpecsUncheckedUpdateWithoutCatalogItemInput>
  }

  export type AlertUncheckedUpdateManyWithoutCatalogItemNestedInput = {
    create?: XOR<AlertCreateWithoutCatalogItemInput, AlertUncheckedCreateWithoutCatalogItemInput> | AlertCreateWithoutCatalogItemInput[] | AlertUncheckedCreateWithoutCatalogItemInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutCatalogItemInput | AlertCreateOrConnectWithoutCatalogItemInput[]
    upsert?: AlertUpsertWithWhereUniqueWithoutCatalogItemInput | AlertUpsertWithWhereUniqueWithoutCatalogItemInput[]
    createMany?: AlertCreateManyCatalogItemInputEnvelope
    set?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    disconnect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    delete?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    update?: AlertUpdateWithWhereUniqueWithoutCatalogItemInput | AlertUpdateWithWhereUniqueWithoutCatalogItemInput[]
    updateMany?: AlertUpdateManyWithWhereWithoutCatalogItemInput | AlertUpdateManyWithWhereWithoutCatalogItemInput[]
    deleteMany?: AlertScalarWhereInput | AlertScalarWhereInput[]
  }

  export type AmmoSpecsUncheckedUpdateOneWithoutCatalogItemNestedInput = {
    create?: XOR<AmmoSpecsCreateWithoutCatalogItemInput, AmmoSpecsUncheckedCreateWithoutCatalogItemInput>
    connectOrCreate?: AmmoSpecsCreateOrConnectWithoutCatalogItemInput
    upsert?: AmmoSpecsUpsertWithoutCatalogItemInput
    disconnect?: AmmoSpecsWhereInput | boolean
    delete?: AmmoSpecsWhereInput | boolean
    connect?: AmmoSpecsWhereUniqueInput
    update?: XOR<XOR<AmmoSpecsUpdateToOneWithWhereWithoutCatalogItemInput, AmmoSpecsUpdateWithoutCatalogItemInput>, AmmoSpecsUncheckedUpdateWithoutCatalogItemInput>
  }

  export type FirearmSpecsUncheckedUpdateOneWithoutCatalogItemNestedInput = {
    create?: XOR<FirearmSpecsCreateWithoutCatalogItemInput, FirearmSpecsUncheckedCreateWithoutCatalogItemInput>
    connectOrCreate?: FirearmSpecsCreateOrConnectWithoutCatalogItemInput
    upsert?: FirearmSpecsUpsertWithoutCatalogItemInput
    disconnect?: FirearmSpecsWhereInput | boolean
    delete?: FirearmSpecsWhereInput | boolean
    connect?: FirearmSpecsWhereUniqueInput
    update?: XOR<XOR<FirearmSpecsUpdateToOneWithWhereWithoutCatalogItemInput, FirearmSpecsUpdateWithoutCatalogItemInput>, FirearmSpecsUncheckedUpdateWithoutCatalogItemInput>
  }

  export type OfferUncheckedUpdateManyWithoutCatalogItemNestedInput = {
    create?: XOR<OfferCreateWithoutCatalogItemInput, OfferUncheckedCreateWithoutCatalogItemInput> | OfferCreateWithoutCatalogItemInput[] | OfferUncheckedCreateWithoutCatalogItemInput[]
    connectOrCreate?: OfferCreateOrConnectWithoutCatalogItemInput | OfferCreateOrConnectWithoutCatalogItemInput[]
    upsert?: OfferUpsertWithWhereUniqueWithoutCatalogItemInput | OfferUpsertWithWhereUniqueWithoutCatalogItemInput[]
    createMany?: OfferCreateManyCatalogItemInputEnvelope
    set?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
    disconnect?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
    delete?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
    connect?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
    update?: OfferUpdateWithWhereUniqueWithoutCatalogItemInput | OfferUpdateWithWhereUniqueWithoutCatalogItemInput[]
    updateMany?: OfferUpdateManyWithWhereWithoutCatalogItemInput | OfferUpdateManyWithWhereWithoutCatalogItemInput[]
    deleteMany?: OfferScalarWhereInput | OfferScalarWhereInput[]
  }

  export type OwnedFirearmUncheckedUpdateManyWithoutCatalogItemNestedInput = {
    create?: XOR<OwnedFirearmCreateWithoutCatalogItemInput, OwnedFirearmUncheckedCreateWithoutCatalogItemInput> | OwnedFirearmCreateWithoutCatalogItemInput[] | OwnedFirearmUncheckedCreateWithoutCatalogItemInput[]
    connectOrCreate?: OwnedFirearmCreateOrConnectWithoutCatalogItemInput | OwnedFirearmCreateOrConnectWithoutCatalogItemInput[]
    upsert?: OwnedFirearmUpsertWithWhereUniqueWithoutCatalogItemInput | OwnedFirearmUpsertWithWhereUniqueWithoutCatalogItemInput[]
    createMany?: OwnedFirearmCreateManyCatalogItemInputEnvelope
    set?: OwnedFirearmWhereUniqueInput | OwnedFirearmWhereUniqueInput[]
    disconnect?: OwnedFirearmWhereUniqueInput | OwnedFirearmWhereUniqueInput[]
    delete?: OwnedFirearmWhereUniqueInput | OwnedFirearmWhereUniqueInput[]
    connect?: OwnedFirearmWhereUniqueInput | OwnedFirearmWhereUniqueInput[]
    update?: OwnedFirearmUpdateWithWhereUniqueWithoutCatalogItemInput | OwnedFirearmUpdateWithWhereUniqueWithoutCatalogItemInput[]
    updateMany?: OwnedFirearmUpdateManyWithWhereWithoutCatalogItemInput | OwnedFirearmUpdateManyWithWhereWithoutCatalogItemInput[]
    deleteMany?: OwnedFirearmScalarWhereInput | OwnedFirearmScalarWhereInput[]
  }

  export type FirearmSpecsCreateNestedManyWithoutFirearmCategoryInput = {
    create?: XOR<FirearmSpecsCreateWithoutFirearmCategoryInput, FirearmSpecsUncheckedCreateWithoutFirearmCategoryInput> | FirearmSpecsCreateWithoutFirearmCategoryInput[] | FirearmSpecsUncheckedCreateWithoutFirearmCategoryInput[]
    connectOrCreate?: FirearmSpecsCreateOrConnectWithoutFirearmCategoryInput | FirearmSpecsCreateOrConnectWithoutFirearmCategoryInput[]
    createMany?: FirearmSpecsCreateManyFirearmCategoryInputEnvelope
    connect?: FirearmSpecsWhereUniqueInput | FirearmSpecsWhereUniqueInput[]
  }

  export type FirearmSpecsUncheckedCreateNestedManyWithoutFirearmCategoryInput = {
    create?: XOR<FirearmSpecsCreateWithoutFirearmCategoryInput, FirearmSpecsUncheckedCreateWithoutFirearmCategoryInput> | FirearmSpecsCreateWithoutFirearmCategoryInput[] | FirearmSpecsUncheckedCreateWithoutFirearmCategoryInput[]
    connectOrCreate?: FirearmSpecsCreateOrConnectWithoutFirearmCategoryInput | FirearmSpecsCreateOrConnectWithoutFirearmCategoryInput[]
    createMany?: FirearmSpecsCreateManyFirearmCategoryInputEnvelope
    connect?: FirearmSpecsWhereUniqueInput | FirearmSpecsWhereUniqueInput[]
  }

  export type FirearmSpecsUpdateManyWithoutFirearmCategoryNestedInput = {
    create?: XOR<FirearmSpecsCreateWithoutFirearmCategoryInput, FirearmSpecsUncheckedCreateWithoutFirearmCategoryInput> | FirearmSpecsCreateWithoutFirearmCategoryInput[] | FirearmSpecsUncheckedCreateWithoutFirearmCategoryInput[]
    connectOrCreate?: FirearmSpecsCreateOrConnectWithoutFirearmCategoryInput | FirearmSpecsCreateOrConnectWithoutFirearmCategoryInput[]
    upsert?: FirearmSpecsUpsertWithWhereUniqueWithoutFirearmCategoryInput | FirearmSpecsUpsertWithWhereUniqueWithoutFirearmCategoryInput[]
    createMany?: FirearmSpecsCreateManyFirearmCategoryInputEnvelope
    set?: FirearmSpecsWhereUniqueInput | FirearmSpecsWhereUniqueInput[]
    disconnect?: FirearmSpecsWhereUniqueInput | FirearmSpecsWhereUniqueInput[]
    delete?: FirearmSpecsWhereUniqueInput | FirearmSpecsWhereUniqueInput[]
    connect?: FirearmSpecsWhereUniqueInput | FirearmSpecsWhereUniqueInput[]
    update?: FirearmSpecsUpdateWithWhereUniqueWithoutFirearmCategoryInput | FirearmSpecsUpdateWithWhereUniqueWithoutFirearmCategoryInput[]
    updateMany?: FirearmSpecsUpdateManyWithWhereWithoutFirearmCategoryInput | FirearmSpecsUpdateManyWithWhereWithoutFirearmCategoryInput[]
    deleteMany?: FirearmSpecsScalarWhereInput | FirearmSpecsScalarWhereInput[]
  }

  export type FirearmSpecsUncheckedUpdateManyWithoutFirearmCategoryNestedInput = {
    create?: XOR<FirearmSpecsCreateWithoutFirearmCategoryInput, FirearmSpecsUncheckedCreateWithoutFirearmCategoryInput> | FirearmSpecsCreateWithoutFirearmCategoryInput[] | FirearmSpecsUncheckedCreateWithoutFirearmCategoryInput[]
    connectOrCreate?: FirearmSpecsCreateOrConnectWithoutFirearmCategoryInput | FirearmSpecsCreateOrConnectWithoutFirearmCategoryInput[]
    upsert?: FirearmSpecsUpsertWithWhereUniqueWithoutFirearmCategoryInput | FirearmSpecsUpsertWithWhereUniqueWithoutFirearmCategoryInput[]
    createMany?: FirearmSpecsCreateManyFirearmCategoryInputEnvelope
    set?: FirearmSpecsWhereUniqueInput | FirearmSpecsWhereUniqueInput[]
    disconnect?: FirearmSpecsWhereUniqueInput | FirearmSpecsWhereUniqueInput[]
    delete?: FirearmSpecsWhereUniqueInput | FirearmSpecsWhereUniqueInput[]
    connect?: FirearmSpecsWhereUniqueInput | FirearmSpecsWhereUniqueInput[]
    update?: FirearmSpecsUpdateWithWhereUniqueWithoutFirearmCategoryInput | FirearmSpecsUpdateWithWhereUniqueWithoutFirearmCategoryInput[]
    updateMany?: FirearmSpecsUpdateManyWithWhereWithoutFirearmCategoryInput | FirearmSpecsUpdateManyWithWhereWithoutFirearmCategoryInput[]
    deleteMany?: FirearmSpecsScalarWhereInput | FirearmSpecsScalarWhereInput[]
  }

  export type CaliberCreateNestedOneWithoutFirearmChamberInput = {
    create?: XOR<CaliberCreateWithoutFirearmChamberInput, CaliberUncheckedCreateWithoutFirearmChamberInput>
    connectOrCreate?: CaliberCreateOrConnectWithoutFirearmChamberInput
    connect?: CaliberWhereUniqueInput
  }

  export type FirearmSpecsCreateNestedOneWithoutFirearmChamberInput = {
    create?: XOR<FirearmSpecsCreateWithoutFirearmChamberInput, FirearmSpecsUncheckedCreateWithoutFirearmChamberInput>
    connectOrCreate?: FirearmSpecsCreateOrConnectWithoutFirearmChamberInput
    connect?: FirearmSpecsWhereUniqueInput
  }

  export type CaliberUpdateOneRequiredWithoutFirearmChamberNestedInput = {
    create?: XOR<CaliberCreateWithoutFirearmChamberInput, CaliberUncheckedCreateWithoutFirearmChamberInput>
    connectOrCreate?: CaliberCreateOrConnectWithoutFirearmChamberInput
    upsert?: CaliberUpsertWithoutFirearmChamberInput
    connect?: CaliberWhereUniqueInput
    update?: XOR<XOR<CaliberUpdateToOneWithWhereWithoutFirearmChamberInput, CaliberUpdateWithoutFirearmChamberInput>, CaliberUncheckedUpdateWithoutFirearmChamberInput>
  }

  export type FirearmSpecsUpdateOneRequiredWithoutFirearmChamberNestedInput = {
    create?: XOR<FirearmSpecsCreateWithoutFirearmChamberInput, FirearmSpecsUncheckedCreateWithoutFirearmChamberInput>
    connectOrCreate?: FirearmSpecsCreateOrConnectWithoutFirearmChamberInput
    upsert?: FirearmSpecsUpsertWithoutFirearmChamberInput
    connect?: FirearmSpecsWhereUniqueInput
    update?: XOR<XOR<FirearmSpecsUpdateToOneWithWhereWithoutFirearmChamberInput, FirearmSpecsUpdateWithoutFirearmChamberInput>, FirearmSpecsUncheckedUpdateWithoutFirearmChamberInput>
  }

  export type FirearmChamberCreateNestedManyWithoutFirearmSpecsInput = {
    create?: XOR<FirearmChamberCreateWithoutFirearmSpecsInput, FirearmChamberUncheckedCreateWithoutFirearmSpecsInput> | FirearmChamberCreateWithoutFirearmSpecsInput[] | FirearmChamberUncheckedCreateWithoutFirearmSpecsInput[]
    connectOrCreate?: FirearmChamberCreateOrConnectWithoutFirearmSpecsInput | FirearmChamberCreateOrConnectWithoutFirearmSpecsInput[]
    createMany?: FirearmChamberCreateManyFirearmSpecsInputEnvelope
    connect?: FirearmChamberWhereUniqueInput | FirearmChamberWhereUniqueInput[]
  }

  export type FirearmCategoryCreateNestedOneWithoutFirearmSpecsInput = {
    create?: XOR<FirearmCategoryCreateWithoutFirearmSpecsInput, FirearmCategoryUncheckedCreateWithoutFirearmSpecsInput>
    connectOrCreate?: FirearmCategoryCreateOrConnectWithoutFirearmSpecsInput
    connect?: FirearmCategoryWhereUniqueInput
  }

  export type CatalogItemCreateNestedOneWithoutFirearmSpecsInput = {
    create?: XOR<CatalogItemCreateWithoutFirearmSpecsInput, CatalogItemUncheckedCreateWithoutFirearmSpecsInput>
    connectOrCreate?: CatalogItemCreateOrConnectWithoutFirearmSpecsInput
    connect?: CatalogItemWhereUniqueInput
  }

  export type FirearmChamberUncheckedCreateNestedManyWithoutFirearmSpecsInput = {
    create?: XOR<FirearmChamberCreateWithoutFirearmSpecsInput, FirearmChamberUncheckedCreateWithoutFirearmSpecsInput> | FirearmChamberCreateWithoutFirearmSpecsInput[] | FirearmChamberUncheckedCreateWithoutFirearmSpecsInput[]
    connectOrCreate?: FirearmChamberCreateOrConnectWithoutFirearmSpecsInput | FirearmChamberCreateOrConnectWithoutFirearmSpecsInput[]
    createMany?: FirearmChamberCreateManyFirearmSpecsInputEnvelope
    connect?: FirearmChamberWhereUniqueInput | FirearmChamberWhereUniqueInput[]
  }

  export type NullableEnumFirearmPressureRatingFieldUpdateOperationsInput = {
    set?: $Enums.FirearmPressureRating | null
  }

  export type FirearmChamberUpdateManyWithoutFirearmSpecsNestedInput = {
    create?: XOR<FirearmChamberCreateWithoutFirearmSpecsInput, FirearmChamberUncheckedCreateWithoutFirearmSpecsInput> | FirearmChamberCreateWithoutFirearmSpecsInput[] | FirearmChamberUncheckedCreateWithoutFirearmSpecsInput[]
    connectOrCreate?: FirearmChamberCreateOrConnectWithoutFirearmSpecsInput | FirearmChamberCreateOrConnectWithoutFirearmSpecsInput[]
    upsert?: FirearmChamberUpsertWithWhereUniqueWithoutFirearmSpecsInput | FirearmChamberUpsertWithWhereUniqueWithoutFirearmSpecsInput[]
    createMany?: FirearmChamberCreateManyFirearmSpecsInputEnvelope
    set?: FirearmChamberWhereUniqueInput | FirearmChamberWhereUniqueInput[]
    disconnect?: FirearmChamberWhereUniqueInput | FirearmChamberWhereUniqueInput[]
    delete?: FirearmChamberWhereUniqueInput | FirearmChamberWhereUniqueInput[]
    connect?: FirearmChamberWhereUniqueInput | FirearmChamberWhereUniqueInput[]
    update?: FirearmChamberUpdateWithWhereUniqueWithoutFirearmSpecsInput | FirearmChamberUpdateWithWhereUniqueWithoutFirearmSpecsInput[]
    updateMany?: FirearmChamberUpdateManyWithWhereWithoutFirearmSpecsInput | FirearmChamberUpdateManyWithWhereWithoutFirearmSpecsInput[]
    deleteMany?: FirearmChamberScalarWhereInput | FirearmChamberScalarWhereInput[]
  }

  export type FirearmCategoryUpdateOneWithoutFirearmSpecsNestedInput = {
    create?: XOR<FirearmCategoryCreateWithoutFirearmSpecsInput, FirearmCategoryUncheckedCreateWithoutFirearmSpecsInput>
    connectOrCreate?: FirearmCategoryCreateOrConnectWithoutFirearmSpecsInput
    upsert?: FirearmCategoryUpsertWithoutFirearmSpecsInput
    disconnect?: FirearmCategoryWhereInput | boolean
    delete?: FirearmCategoryWhereInput | boolean
    connect?: FirearmCategoryWhereUniqueInput
    update?: XOR<XOR<FirearmCategoryUpdateToOneWithWhereWithoutFirearmSpecsInput, FirearmCategoryUpdateWithoutFirearmSpecsInput>, FirearmCategoryUncheckedUpdateWithoutFirearmSpecsInput>
  }

  export type CatalogItemUpdateOneRequiredWithoutFirearmSpecsNestedInput = {
    create?: XOR<CatalogItemCreateWithoutFirearmSpecsInput, CatalogItemUncheckedCreateWithoutFirearmSpecsInput>
    connectOrCreate?: CatalogItemCreateOrConnectWithoutFirearmSpecsInput
    upsert?: CatalogItemUpsertWithoutFirearmSpecsInput
    connect?: CatalogItemWhereUniqueInput
    update?: XOR<XOR<CatalogItemUpdateToOneWithWhereWithoutFirearmSpecsInput, CatalogItemUpdateWithoutFirearmSpecsInput>, CatalogItemUncheckedUpdateWithoutFirearmSpecsInput>
  }

  export type FirearmChamberUncheckedUpdateManyWithoutFirearmSpecsNestedInput = {
    create?: XOR<FirearmChamberCreateWithoutFirearmSpecsInput, FirearmChamberUncheckedCreateWithoutFirearmSpecsInput> | FirearmChamberCreateWithoutFirearmSpecsInput[] | FirearmChamberUncheckedCreateWithoutFirearmSpecsInput[]
    connectOrCreate?: FirearmChamberCreateOrConnectWithoutFirearmSpecsInput | FirearmChamberCreateOrConnectWithoutFirearmSpecsInput[]
    upsert?: FirearmChamberUpsertWithWhereUniqueWithoutFirearmSpecsInput | FirearmChamberUpsertWithWhereUniqueWithoutFirearmSpecsInput[]
    createMany?: FirearmChamberCreateManyFirearmSpecsInputEnvelope
    set?: FirearmChamberWhereUniqueInput | FirearmChamberWhereUniqueInput[]
    disconnect?: FirearmChamberWhereUniqueInput | FirearmChamberWhereUniqueInput[]
    delete?: FirearmChamberWhereUniqueInput | FirearmChamberWhereUniqueInput[]
    connect?: FirearmChamberWhereUniqueInput | FirearmChamberWhereUniqueInput[]
    update?: FirearmChamberUpdateWithWhereUniqueWithoutFirearmSpecsInput | FirearmChamberUpdateWithWhereUniqueWithoutFirearmSpecsInput[]
    updateMany?: FirearmChamberUpdateManyWithWhereWithoutFirearmSpecsInput | FirearmChamberUpdateManyWithWhereWithoutFirearmSpecsInput[]
    deleteMany?: FirearmChamberScalarWhereInput | FirearmChamberScalarWhereInput[]
  }

  export type CatalogItemCreateNestedOneWithoutOwnedFirearmInput = {
    create?: XOR<CatalogItemCreateWithoutOwnedFirearmInput, CatalogItemUncheckedCreateWithoutOwnedFirearmInput>
    connectOrCreate?: CatalogItemCreateOrConnectWithoutOwnedFirearmInput
    connect?: CatalogItemWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutOwnedFirearmInput = {
    create?: XOR<UserCreateWithoutOwnedFirearmInput, UserUncheckedCreateWithoutOwnedFirearmInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedFirearmInput
    connect?: UserWhereUniqueInput
  }

  export type CatalogItemUpdateOneRequiredWithoutOwnedFirearmNestedInput = {
    create?: XOR<CatalogItemCreateWithoutOwnedFirearmInput, CatalogItemUncheckedCreateWithoutOwnedFirearmInput>
    connectOrCreate?: CatalogItemCreateOrConnectWithoutOwnedFirearmInput
    upsert?: CatalogItemUpsertWithoutOwnedFirearmInput
    connect?: CatalogItemWhereUniqueInput
    update?: XOR<XOR<CatalogItemUpdateToOneWithWhereWithoutOwnedFirearmInput, CatalogItemUpdateWithoutOwnedFirearmInput>, CatalogItemUncheckedUpdateWithoutOwnedFirearmInput>
  }

  export type UserUpdateOneRequiredWithoutOwnedFirearmNestedInput = {
    create?: XOR<UserCreateWithoutOwnedFirearmInput, UserUncheckedCreateWithoutOwnedFirearmInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedFirearmInput
    upsert?: UserUpsertWithoutOwnedFirearmInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOwnedFirearmInput, UserUpdateWithoutOwnedFirearmInput>, UserUncheckedUpdateWithoutOwnedFirearmInput>
  }

  export type AlertCreateNestedManyWithoutUserInput = {
    create?: XOR<AlertCreateWithoutUserInput, AlertUncheckedCreateWithoutUserInput> | AlertCreateWithoutUserInput[] | AlertUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutUserInput | AlertCreateOrConnectWithoutUserInput[]
    createMany?: AlertCreateManyUserInputEnvelope
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
  }

  export type AlertDeliveryCreateNestedManyWithoutUserInput = {
    create?: XOR<AlertDeliveryCreateWithoutUserInput, AlertDeliveryUncheckedCreateWithoutUserInput> | AlertDeliveryCreateWithoutUserInput[] | AlertDeliveryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AlertDeliveryCreateOrConnectWithoutUserInput | AlertDeliveryCreateOrConnectWithoutUserInput[]
    createMany?: AlertDeliveryCreateManyUserInputEnvelope
    connect?: AlertDeliveryWhereUniqueInput | AlertDeliveryWhereUniqueInput[]
  }

  export type BlockedRetailerCreateNestedManyWithoutUserInput = {
    create?: XOR<BlockedRetailerCreateWithoutUserInput, BlockedRetailerUncheckedCreateWithoutUserInput> | BlockedRetailerCreateWithoutUserInput[] | BlockedRetailerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BlockedRetailerCreateOrConnectWithoutUserInput | BlockedRetailerCreateOrConnectWithoutUserInput[]
    createMany?: BlockedRetailerCreateManyUserInputEnvelope
    connect?: BlockedRetailerWhereUniqueInput | BlockedRetailerWhereUniqueInput[]
  }

  export type OwnedFirearmCreateNestedManyWithoutUserInput = {
    create?: XOR<OwnedFirearmCreateWithoutUserInput, OwnedFirearmUncheckedCreateWithoutUserInput> | OwnedFirearmCreateWithoutUserInput[] | OwnedFirearmUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OwnedFirearmCreateOrConnectWithoutUserInput | OwnedFirearmCreateOrConnectWithoutUserInput[]
    createMany?: OwnedFirearmCreateManyUserInputEnvelope
    connect?: OwnedFirearmWhereUniqueInput | OwnedFirearmWhereUniqueInput[]
  }

  export type AlertUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AlertCreateWithoutUserInput, AlertUncheckedCreateWithoutUserInput> | AlertCreateWithoutUserInput[] | AlertUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutUserInput | AlertCreateOrConnectWithoutUserInput[]
    createMany?: AlertCreateManyUserInputEnvelope
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
  }

  export type AlertDeliveryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AlertDeliveryCreateWithoutUserInput, AlertDeliveryUncheckedCreateWithoutUserInput> | AlertDeliveryCreateWithoutUserInput[] | AlertDeliveryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AlertDeliveryCreateOrConnectWithoutUserInput | AlertDeliveryCreateOrConnectWithoutUserInput[]
    createMany?: AlertDeliveryCreateManyUserInputEnvelope
    connect?: AlertDeliveryWhereUniqueInput | AlertDeliveryWhereUniqueInput[]
  }

  export type BlockedRetailerUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BlockedRetailerCreateWithoutUserInput, BlockedRetailerUncheckedCreateWithoutUserInput> | BlockedRetailerCreateWithoutUserInput[] | BlockedRetailerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BlockedRetailerCreateOrConnectWithoutUserInput | BlockedRetailerCreateOrConnectWithoutUserInput[]
    createMany?: BlockedRetailerCreateManyUserInputEnvelope
    connect?: BlockedRetailerWhereUniqueInput | BlockedRetailerWhereUniqueInput[]
  }

  export type OwnedFirearmUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<OwnedFirearmCreateWithoutUserInput, OwnedFirearmUncheckedCreateWithoutUserInput> | OwnedFirearmCreateWithoutUserInput[] | OwnedFirearmUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OwnedFirearmCreateOrConnectWithoutUserInput | OwnedFirearmCreateOrConnectWithoutUserInput[]
    createMany?: OwnedFirearmCreateManyUserInputEnvelope
    connect?: OwnedFirearmWhereUniqueInput | OwnedFirearmWhereUniqueInput[]
  }

  export type AlertUpdateManyWithoutUserNestedInput = {
    create?: XOR<AlertCreateWithoutUserInput, AlertUncheckedCreateWithoutUserInput> | AlertCreateWithoutUserInput[] | AlertUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutUserInput | AlertCreateOrConnectWithoutUserInput[]
    upsert?: AlertUpsertWithWhereUniqueWithoutUserInput | AlertUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AlertCreateManyUserInputEnvelope
    set?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    disconnect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    delete?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    update?: AlertUpdateWithWhereUniqueWithoutUserInput | AlertUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AlertUpdateManyWithWhereWithoutUserInput | AlertUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AlertScalarWhereInput | AlertScalarWhereInput[]
  }

  export type AlertDeliveryUpdateManyWithoutUserNestedInput = {
    create?: XOR<AlertDeliveryCreateWithoutUserInput, AlertDeliveryUncheckedCreateWithoutUserInput> | AlertDeliveryCreateWithoutUserInput[] | AlertDeliveryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AlertDeliveryCreateOrConnectWithoutUserInput | AlertDeliveryCreateOrConnectWithoutUserInput[]
    upsert?: AlertDeliveryUpsertWithWhereUniqueWithoutUserInput | AlertDeliveryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AlertDeliveryCreateManyUserInputEnvelope
    set?: AlertDeliveryWhereUniqueInput | AlertDeliveryWhereUniqueInput[]
    disconnect?: AlertDeliveryWhereUniqueInput | AlertDeliveryWhereUniqueInput[]
    delete?: AlertDeliveryWhereUniqueInput | AlertDeliveryWhereUniqueInput[]
    connect?: AlertDeliveryWhereUniqueInput | AlertDeliveryWhereUniqueInput[]
    update?: AlertDeliveryUpdateWithWhereUniqueWithoutUserInput | AlertDeliveryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AlertDeliveryUpdateManyWithWhereWithoutUserInput | AlertDeliveryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AlertDeliveryScalarWhereInput | AlertDeliveryScalarWhereInput[]
  }

  export type BlockedRetailerUpdateManyWithoutUserNestedInput = {
    create?: XOR<BlockedRetailerCreateWithoutUserInput, BlockedRetailerUncheckedCreateWithoutUserInput> | BlockedRetailerCreateWithoutUserInput[] | BlockedRetailerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BlockedRetailerCreateOrConnectWithoutUserInput | BlockedRetailerCreateOrConnectWithoutUserInput[]
    upsert?: BlockedRetailerUpsertWithWhereUniqueWithoutUserInput | BlockedRetailerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BlockedRetailerCreateManyUserInputEnvelope
    set?: BlockedRetailerWhereUniqueInput | BlockedRetailerWhereUniqueInput[]
    disconnect?: BlockedRetailerWhereUniqueInput | BlockedRetailerWhereUniqueInput[]
    delete?: BlockedRetailerWhereUniqueInput | BlockedRetailerWhereUniqueInput[]
    connect?: BlockedRetailerWhereUniqueInput | BlockedRetailerWhereUniqueInput[]
    update?: BlockedRetailerUpdateWithWhereUniqueWithoutUserInput | BlockedRetailerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BlockedRetailerUpdateManyWithWhereWithoutUserInput | BlockedRetailerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BlockedRetailerScalarWhereInput | BlockedRetailerScalarWhereInput[]
  }

  export type OwnedFirearmUpdateManyWithoutUserNestedInput = {
    create?: XOR<OwnedFirearmCreateWithoutUserInput, OwnedFirearmUncheckedCreateWithoutUserInput> | OwnedFirearmCreateWithoutUserInput[] | OwnedFirearmUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OwnedFirearmCreateOrConnectWithoutUserInput | OwnedFirearmCreateOrConnectWithoutUserInput[]
    upsert?: OwnedFirearmUpsertWithWhereUniqueWithoutUserInput | OwnedFirearmUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OwnedFirearmCreateManyUserInputEnvelope
    set?: OwnedFirearmWhereUniqueInput | OwnedFirearmWhereUniqueInput[]
    disconnect?: OwnedFirearmWhereUniqueInput | OwnedFirearmWhereUniqueInput[]
    delete?: OwnedFirearmWhereUniqueInput | OwnedFirearmWhereUniqueInput[]
    connect?: OwnedFirearmWhereUniqueInput | OwnedFirearmWhereUniqueInput[]
    update?: OwnedFirearmUpdateWithWhereUniqueWithoutUserInput | OwnedFirearmUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OwnedFirearmUpdateManyWithWhereWithoutUserInput | OwnedFirearmUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OwnedFirearmScalarWhereInput | OwnedFirearmScalarWhereInput[]
  }

  export type AlertUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AlertCreateWithoutUserInput, AlertUncheckedCreateWithoutUserInput> | AlertCreateWithoutUserInput[] | AlertUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutUserInput | AlertCreateOrConnectWithoutUserInput[]
    upsert?: AlertUpsertWithWhereUniqueWithoutUserInput | AlertUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AlertCreateManyUserInputEnvelope
    set?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    disconnect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    delete?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    update?: AlertUpdateWithWhereUniqueWithoutUserInput | AlertUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AlertUpdateManyWithWhereWithoutUserInput | AlertUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AlertScalarWhereInput | AlertScalarWhereInput[]
  }

  export type AlertDeliveryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AlertDeliveryCreateWithoutUserInput, AlertDeliveryUncheckedCreateWithoutUserInput> | AlertDeliveryCreateWithoutUserInput[] | AlertDeliveryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AlertDeliveryCreateOrConnectWithoutUserInput | AlertDeliveryCreateOrConnectWithoutUserInput[]
    upsert?: AlertDeliveryUpsertWithWhereUniqueWithoutUserInput | AlertDeliveryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AlertDeliveryCreateManyUserInputEnvelope
    set?: AlertDeliveryWhereUniqueInput | AlertDeliveryWhereUniqueInput[]
    disconnect?: AlertDeliveryWhereUniqueInput | AlertDeliveryWhereUniqueInput[]
    delete?: AlertDeliveryWhereUniqueInput | AlertDeliveryWhereUniqueInput[]
    connect?: AlertDeliveryWhereUniqueInput | AlertDeliveryWhereUniqueInput[]
    update?: AlertDeliveryUpdateWithWhereUniqueWithoutUserInput | AlertDeliveryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AlertDeliveryUpdateManyWithWhereWithoutUserInput | AlertDeliveryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AlertDeliveryScalarWhereInput | AlertDeliveryScalarWhereInput[]
  }

  export type BlockedRetailerUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BlockedRetailerCreateWithoutUserInput, BlockedRetailerUncheckedCreateWithoutUserInput> | BlockedRetailerCreateWithoutUserInput[] | BlockedRetailerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BlockedRetailerCreateOrConnectWithoutUserInput | BlockedRetailerCreateOrConnectWithoutUserInput[]
    upsert?: BlockedRetailerUpsertWithWhereUniqueWithoutUserInput | BlockedRetailerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BlockedRetailerCreateManyUserInputEnvelope
    set?: BlockedRetailerWhereUniqueInput | BlockedRetailerWhereUniqueInput[]
    disconnect?: BlockedRetailerWhereUniqueInput | BlockedRetailerWhereUniqueInput[]
    delete?: BlockedRetailerWhereUniqueInput | BlockedRetailerWhereUniqueInput[]
    connect?: BlockedRetailerWhereUniqueInput | BlockedRetailerWhereUniqueInput[]
    update?: BlockedRetailerUpdateWithWhereUniqueWithoutUserInput | BlockedRetailerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BlockedRetailerUpdateManyWithWhereWithoutUserInput | BlockedRetailerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BlockedRetailerScalarWhereInput | BlockedRetailerScalarWhereInput[]
  }

  export type OwnedFirearmUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<OwnedFirearmCreateWithoutUserInput, OwnedFirearmUncheckedCreateWithoutUserInput> | OwnedFirearmCreateWithoutUserInput[] | OwnedFirearmUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OwnedFirearmCreateOrConnectWithoutUserInput | OwnedFirearmCreateOrConnectWithoutUserInput[]
    upsert?: OwnedFirearmUpsertWithWhereUniqueWithoutUserInput | OwnedFirearmUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OwnedFirearmCreateManyUserInputEnvelope
    set?: OwnedFirearmWhereUniqueInput | OwnedFirearmWhereUniqueInput[]
    disconnect?: OwnedFirearmWhereUniqueInput | OwnedFirearmWhereUniqueInput[]
    delete?: OwnedFirearmWhereUniqueInput | OwnedFirearmWhereUniqueInput[]
    connect?: OwnedFirearmWhereUniqueInput | OwnedFirearmWhereUniqueInput[]
    update?: OwnedFirearmUpdateWithWhereUniqueWithoutUserInput | OwnedFirearmUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OwnedFirearmUpdateManyWithWhereWithoutUserInput | OwnedFirearmUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OwnedFirearmScalarWhereInput | OwnedFirearmScalarWhereInput[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedEnumFitmentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FitmentType | EnumFitmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FitmentType[] | ListEnumFitmentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FitmentType[] | ListEnumFitmentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFitmentTypeFilter<$PrismaModel> | $Enums.FitmentType
  }

  export type NestedEnumFitmentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FitmentType | EnumFitmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FitmentType[] | ListEnumFitmentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FitmentType[] | ListEnumFitmentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFitmentTypeWithAggregatesFilter<$PrismaModel> | $Enums.FitmentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFitmentTypeFilter<$PrismaModel>
    _max?: NestedEnumFitmentTypeFilter<$PrismaModel>
  }

  export type NestedEnumAlertTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AlertType | EnumAlertTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AlertType[] | ListEnumAlertTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AlertType[] | ListEnumAlertTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAlertTypeFilter<$PrismaModel> | $Enums.AlertType
  }

  export type NestedEnumAlertTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AlertType | EnumAlertTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AlertType[] | ListEnumAlertTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AlertType[] | ListEnumAlertTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAlertTypeWithAggregatesFilter<$PrismaModel> | $Enums.AlertType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAlertTypeFilter<$PrismaModel>
    _max?: NestedEnumAlertTypeFilter<$PrismaModel>
  }

  export type NestedEnumAmmoPressureNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.AmmoPressure | EnumAmmoPressureFieldRefInput<$PrismaModel> | null
    in?: $Enums.AmmoPressure[] | ListEnumAmmoPressureFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.AmmoPressure[] | ListEnumAmmoPressureFieldRefInput<$PrismaModel> | null
    not?: NestedEnumAmmoPressureNullableFilter<$PrismaModel> | $Enums.AmmoPressure | null
  }

  export type NestedEnumAmmoPressureNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AmmoPressure | EnumAmmoPressureFieldRefInput<$PrismaModel> | null
    in?: $Enums.AmmoPressure[] | ListEnumAmmoPressureFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.AmmoPressure[] | ListEnumAmmoPressureFieldRefInput<$PrismaModel> | null
    not?: NestedEnumAmmoPressureNullableWithAggregatesFilter<$PrismaModel> | $Enums.AmmoPressure | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumAmmoPressureNullableFilter<$PrismaModel>
    _max?: NestedEnumAmmoPressureNullableFilter<$PrismaModel>
  }

  export type NestedEnumCatalogKindFilter<$PrismaModel = never> = {
    equals?: $Enums.CatalogKind | EnumCatalogKindFieldRefInput<$PrismaModel>
    in?: $Enums.CatalogKind[] | ListEnumCatalogKindFieldRefInput<$PrismaModel>
    notIn?: $Enums.CatalogKind[] | ListEnumCatalogKindFieldRefInput<$PrismaModel>
    not?: NestedEnumCatalogKindFilter<$PrismaModel> | $Enums.CatalogKind
  }

  export type NestedEnumCatalogKindWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CatalogKind | EnumCatalogKindFieldRefInput<$PrismaModel>
    in?: $Enums.CatalogKind[] | ListEnumCatalogKindFieldRefInput<$PrismaModel>
    notIn?: $Enums.CatalogKind[] | ListEnumCatalogKindFieldRefInput<$PrismaModel>
    not?: NestedEnumCatalogKindWithAggregatesFilter<$PrismaModel> | $Enums.CatalogKind
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCatalogKindFilter<$PrismaModel>
    _max?: NestedEnumCatalogKindFilter<$PrismaModel>
  }

  export type NestedEnumFirearmPressureRatingNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.FirearmPressureRating | EnumFirearmPressureRatingFieldRefInput<$PrismaModel> | null
    in?: $Enums.FirearmPressureRating[] | ListEnumFirearmPressureRatingFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.FirearmPressureRating[] | ListEnumFirearmPressureRatingFieldRefInput<$PrismaModel> | null
    not?: NestedEnumFirearmPressureRatingNullableFilter<$PrismaModel> | $Enums.FirearmPressureRating | null
  }

  export type NestedEnumFirearmPressureRatingNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FirearmPressureRating | EnumFirearmPressureRatingFieldRefInput<$PrismaModel> | null
    in?: $Enums.FirearmPressureRating[] | ListEnumFirearmPressureRatingFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.FirearmPressureRating[] | ListEnumFirearmPressureRatingFieldRefInput<$PrismaModel> | null
    not?: NestedEnumFirearmPressureRatingNullableWithAggregatesFilter<$PrismaModel> | $Enums.FirearmPressureRating | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumFirearmPressureRatingNullableFilter<$PrismaModel>
    _max?: NestedEnumFirearmPressureRatingNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type CatalogItemCreateWithoutBrandInput = {
    id: string
    kind: $Enums.CatalogKind
    slug: string
    upc?: string | null
    mpn?: string | null
    title: string
    image?: string | null
    description?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    bestPrice?: number | null
    bestRetailerId?: number | null
    bestRetailerName?: string | null
    offerCount?: number | null
    bestCpr?: number | null
    bestCprShipped?: number | null
    upvotes?: number | null
    downvotes?: number | null
    AccessoryFitment?: AccessoryFitmentCreateNestedManyWithoutCatalogItemInput
    AccessorySpecs?: AccessorySpecsCreateNestedOneWithoutCatalogItemInput
    Alert?: AlertCreateNestedManyWithoutCatalogItemInput
    AmmoSpecs?: AmmoSpecsCreateNestedOneWithoutCatalogItemInput
    FirearmSpecs?: FirearmSpecsCreateNestedOneWithoutCatalogItemInput
    Offer?: OfferCreateNestedManyWithoutCatalogItemInput
    OwnedFirearm?: OwnedFirearmCreateNestedManyWithoutCatalogItemInput
  }

  export type CatalogItemUncheckedCreateWithoutBrandInput = {
    id: string
    kind: $Enums.CatalogKind
    slug: string
    upc?: string | null
    mpn?: string | null
    title: string
    image?: string | null
    description?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    bestPrice?: number | null
    bestRetailerId?: number | null
    bestRetailerName?: string | null
    offerCount?: number | null
    bestCpr?: number | null
    bestCprShipped?: number | null
    upvotes?: number | null
    downvotes?: number | null
    AccessoryFitment?: AccessoryFitmentUncheckedCreateNestedManyWithoutCatalogItemInput
    AccessorySpecs?: AccessorySpecsUncheckedCreateNestedOneWithoutCatalogItemInput
    Alert?: AlertUncheckedCreateNestedManyWithoutCatalogItemInput
    AmmoSpecs?: AmmoSpecsUncheckedCreateNestedOneWithoutCatalogItemInput
    FirearmSpecs?: FirearmSpecsUncheckedCreateNestedOneWithoutCatalogItemInput
    Offer?: OfferUncheckedCreateNestedManyWithoutCatalogItemInput
    OwnedFirearm?: OwnedFirearmUncheckedCreateNestedManyWithoutCatalogItemInput
  }

  export type CatalogItemCreateOrConnectWithoutBrandInput = {
    where: CatalogItemWhereUniqueInput
    create: XOR<CatalogItemCreateWithoutBrandInput, CatalogItemUncheckedCreateWithoutBrandInput>
  }

  export type CatalogItemCreateManyBrandInputEnvelope = {
    data: CatalogItemCreateManyBrandInput | CatalogItemCreateManyBrandInput[]
    skipDuplicates?: boolean
  }

  export type CatalogItemUpsertWithWhereUniqueWithoutBrandInput = {
    where: CatalogItemWhereUniqueInput
    update: XOR<CatalogItemUpdateWithoutBrandInput, CatalogItemUncheckedUpdateWithoutBrandInput>
    create: XOR<CatalogItemCreateWithoutBrandInput, CatalogItemUncheckedCreateWithoutBrandInput>
  }

  export type CatalogItemUpdateWithWhereUniqueWithoutBrandInput = {
    where: CatalogItemWhereUniqueInput
    data: XOR<CatalogItemUpdateWithoutBrandInput, CatalogItemUncheckedUpdateWithoutBrandInput>
  }

  export type CatalogItemUpdateManyWithWhereWithoutBrandInput = {
    where: CatalogItemScalarWhereInput
    data: XOR<CatalogItemUpdateManyMutationInput, CatalogItemUncheckedUpdateManyWithoutBrandInput>
  }

  export type CatalogItemScalarWhereInput = {
    AND?: CatalogItemScalarWhereInput | CatalogItemScalarWhereInput[]
    OR?: CatalogItemScalarWhereInput[]
    NOT?: CatalogItemScalarWhereInput | CatalogItemScalarWhereInput[]
    id?: StringFilter<"CatalogItem"> | string
    kind?: EnumCatalogKindFilter<"CatalogItem"> | $Enums.CatalogKind
    slug?: StringFilter<"CatalogItem"> | string
    upc?: StringNullableFilter<"CatalogItem"> | string | null
    mpn?: StringNullableFilter<"CatalogItem"> | string | null
    title?: StringFilter<"CatalogItem"> | string
    image?: StringNullableFilter<"CatalogItem"> | string | null
    description?: StringNullableFilter<"CatalogItem"> | string | null
    brandId?: IntNullableFilter<"CatalogItem"> | number | null
    createdAt?: DateTimeNullableFilter<"CatalogItem"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"CatalogItem"> | Date | string | null
    bestPrice?: FloatNullableFilter<"CatalogItem"> | number | null
    bestRetailerId?: IntNullableFilter<"CatalogItem"> | number | null
    bestRetailerName?: StringNullableFilter<"CatalogItem"> | string | null
    offerCount?: IntNullableFilter<"CatalogItem"> | number | null
    bestCpr?: FloatNullableFilter<"CatalogItem"> | number | null
    bestCprShipped?: FloatNullableFilter<"CatalogItem"> | number | null
    upvotes?: IntNullableFilter<"CatalogItem"> | number | null
    downvotes?: IntNullableFilter<"CatalogItem"> | number | null
  }

  export type AlertCreateWithoutCaliberInput = {
    id: string
    type: $Enums.AlertType
    keyword?: string | null
    targetCpr?: number | null
    excludeSteel?: boolean | null
    excludeReman?: boolean | null
    lastTriggered?: Date | string | null
    isActive?: boolean | null
    createdAt?: Date | string | null
    CatalogItem?: CatalogItemCreateNestedOneWithoutAlertInput
    User: UserCreateNestedOneWithoutAlertInput
    AlertDelivery?: AlertDeliveryCreateNestedManyWithoutAlertInput
  }

  export type AlertUncheckedCreateWithoutCaliberInput = {
    id: string
    userId: string
    type: $Enums.AlertType
    itemId?: string | null
    keyword?: string | null
    targetCpr?: number | null
    excludeSteel?: boolean | null
    excludeReman?: boolean | null
    lastTriggered?: Date | string | null
    isActive?: boolean | null
    createdAt?: Date | string | null
    AlertDelivery?: AlertDeliveryUncheckedCreateNestedManyWithoutAlertInput
  }

  export type AlertCreateOrConnectWithoutCaliberInput = {
    where: AlertWhereUniqueInput
    create: XOR<AlertCreateWithoutCaliberInput, AlertUncheckedCreateWithoutCaliberInput>
  }

  export type AlertCreateManyCaliberInputEnvelope = {
    data: AlertCreateManyCaliberInput | AlertCreateManyCaliberInput[]
    skipDuplicates?: boolean
  }

  export type AmmoSpecsCreateWithoutCaliberInput = {
    grain?: number | null
    gauge?: string | null
    velocity?: number | null
    energy?: number | null
    casing?: string | null
    bulletType?: string | null
    restrictions?: AmmoSpecsCreaterestrictionsInput | string[]
    pressure?: $Enums.AmmoPressure | null
    isSteelCase?: boolean | null
    isRemanufactured?: boolean | null
    isSubsonic?: boolean | null
    CatalogItem: CatalogItemCreateNestedOneWithoutAmmoSpecsInput
  }

  export type AmmoSpecsUncheckedCreateWithoutCaliberInput = {
    id?: number
    itemId: string
    grain?: number | null
    gauge?: string | null
    velocity?: number | null
    energy?: number | null
    casing?: string | null
    bulletType?: string | null
    restrictions?: AmmoSpecsCreaterestrictionsInput | string[]
    pressure?: $Enums.AmmoPressure | null
    isSteelCase?: boolean | null
    isRemanufactured?: boolean | null
    isSubsonic?: boolean | null
  }

  export type AmmoSpecsCreateOrConnectWithoutCaliberInput = {
    where: AmmoSpecsWhereUniqueInput
    create: XOR<AmmoSpecsCreateWithoutCaliberInput, AmmoSpecsUncheckedCreateWithoutCaliberInput>
  }

  export type AmmoSpecsCreateManyCaliberInputEnvelope = {
    data: AmmoSpecsCreateManyCaliberInput | AmmoSpecsCreateManyCaliberInput[]
    skipDuplicates?: boolean
  }

  export type CaliberAliasCreateWithoutCaliberInput = {
    alias: string
  }

  export type CaliberAliasUncheckedCreateWithoutCaliberInput = {
    id?: number
    alias: string
  }

  export type CaliberAliasCreateOrConnectWithoutCaliberInput = {
    where: CaliberAliasWhereUniqueInput
    create: XOR<CaliberAliasCreateWithoutCaliberInput, CaliberAliasUncheckedCreateWithoutCaliberInput>
  }

  export type CaliberAliasCreateManyCaliberInputEnvelope = {
    data: CaliberAliasCreateManyCaliberInput | CaliberAliasCreateManyCaliberInput[]
    skipDuplicates?: boolean
  }

  export type FirearmChamberCreateWithoutCaliberInput = {
    note?: string | null
    FirearmSpecs: FirearmSpecsCreateNestedOneWithoutFirearmChamberInput
  }

  export type FirearmChamberUncheckedCreateWithoutCaliberInput = {
    firearmSpecsId: number
    note?: string | null
  }

  export type FirearmChamberCreateOrConnectWithoutCaliberInput = {
    where: FirearmChamberWhereUniqueInput
    create: XOR<FirearmChamberCreateWithoutCaliberInput, FirearmChamberUncheckedCreateWithoutCaliberInput>
  }

  export type FirearmChamberCreateManyCaliberInputEnvelope = {
    data: FirearmChamberCreateManyCaliberInput | FirearmChamberCreateManyCaliberInput[]
    skipDuplicates?: boolean
  }

  export type AlertUpsertWithWhereUniqueWithoutCaliberInput = {
    where: AlertWhereUniqueInput
    update: XOR<AlertUpdateWithoutCaliberInput, AlertUncheckedUpdateWithoutCaliberInput>
    create: XOR<AlertCreateWithoutCaliberInput, AlertUncheckedCreateWithoutCaliberInput>
  }

  export type AlertUpdateWithWhereUniqueWithoutCaliberInput = {
    where: AlertWhereUniqueInput
    data: XOR<AlertUpdateWithoutCaliberInput, AlertUncheckedUpdateWithoutCaliberInput>
  }

  export type AlertUpdateManyWithWhereWithoutCaliberInput = {
    where: AlertScalarWhereInput
    data: XOR<AlertUpdateManyMutationInput, AlertUncheckedUpdateManyWithoutCaliberInput>
  }

  export type AlertScalarWhereInput = {
    AND?: AlertScalarWhereInput | AlertScalarWhereInput[]
    OR?: AlertScalarWhereInput[]
    NOT?: AlertScalarWhereInput | AlertScalarWhereInput[]
    id?: StringFilter<"Alert"> | string
    userId?: StringFilter<"Alert"> | string
    type?: EnumAlertTypeFilter<"Alert"> | $Enums.AlertType
    calId?: IntNullableFilter<"Alert"> | number | null
    itemId?: StringNullableFilter<"Alert"> | string | null
    keyword?: StringNullableFilter<"Alert"> | string | null
    targetCpr?: FloatNullableFilter<"Alert"> | number | null
    excludeSteel?: BoolNullableFilter<"Alert"> | boolean | null
    excludeReman?: BoolNullableFilter<"Alert"> | boolean | null
    lastTriggered?: DateTimeNullableFilter<"Alert"> | Date | string | null
    isActive?: BoolNullableFilter<"Alert"> | boolean | null
    createdAt?: DateTimeNullableFilter<"Alert"> | Date | string | null
  }

  export type AmmoSpecsUpsertWithWhereUniqueWithoutCaliberInput = {
    where: AmmoSpecsWhereUniqueInput
    update: XOR<AmmoSpecsUpdateWithoutCaliberInput, AmmoSpecsUncheckedUpdateWithoutCaliberInput>
    create: XOR<AmmoSpecsCreateWithoutCaliberInput, AmmoSpecsUncheckedCreateWithoutCaliberInput>
  }

  export type AmmoSpecsUpdateWithWhereUniqueWithoutCaliberInput = {
    where: AmmoSpecsWhereUniqueInput
    data: XOR<AmmoSpecsUpdateWithoutCaliberInput, AmmoSpecsUncheckedUpdateWithoutCaliberInput>
  }

  export type AmmoSpecsUpdateManyWithWhereWithoutCaliberInput = {
    where: AmmoSpecsScalarWhereInput
    data: XOR<AmmoSpecsUpdateManyMutationInput, AmmoSpecsUncheckedUpdateManyWithoutCaliberInput>
  }

  export type AmmoSpecsScalarWhereInput = {
    AND?: AmmoSpecsScalarWhereInput | AmmoSpecsScalarWhereInput[]
    OR?: AmmoSpecsScalarWhereInput[]
    NOT?: AmmoSpecsScalarWhereInput | AmmoSpecsScalarWhereInput[]
    id?: IntFilter<"AmmoSpecs"> | number
    itemId?: StringFilter<"AmmoSpecs"> | string
    caliberId?: IntFilter<"AmmoSpecs"> | number
    grain?: IntNullableFilter<"AmmoSpecs"> | number | null
    gauge?: StringNullableFilter<"AmmoSpecs"> | string | null
    velocity?: IntNullableFilter<"AmmoSpecs"> | number | null
    energy?: IntNullableFilter<"AmmoSpecs"> | number | null
    casing?: StringNullableFilter<"AmmoSpecs"> | string | null
    bulletType?: StringNullableFilter<"AmmoSpecs"> | string | null
    restrictions?: StringNullableListFilter<"AmmoSpecs">
    pressure?: EnumAmmoPressureNullableFilter<"AmmoSpecs"> | $Enums.AmmoPressure | null
    isSteelCase?: BoolNullableFilter<"AmmoSpecs"> | boolean | null
    isRemanufactured?: BoolNullableFilter<"AmmoSpecs"> | boolean | null
    isSubsonic?: BoolNullableFilter<"AmmoSpecs"> | boolean | null
  }

  export type CaliberAliasUpsertWithWhereUniqueWithoutCaliberInput = {
    where: CaliberAliasWhereUniqueInput
    update: XOR<CaliberAliasUpdateWithoutCaliberInput, CaliberAliasUncheckedUpdateWithoutCaliberInput>
    create: XOR<CaliberAliasCreateWithoutCaliberInput, CaliberAliasUncheckedCreateWithoutCaliberInput>
  }

  export type CaliberAliasUpdateWithWhereUniqueWithoutCaliberInput = {
    where: CaliberAliasWhereUniqueInput
    data: XOR<CaliberAliasUpdateWithoutCaliberInput, CaliberAliasUncheckedUpdateWithoutCaliberInput>
  }

  export type CaliberAliasUpdateManyWithWhereWithoutCaliberInput = {
    where: CaliberAliasScalarWhereInput
    data: XOR<CaliberAliasUpdateManyMutationInput, CaliberAliasUncheckedUpdateManyWithoutCaliberInput>
  }

  export type CaliberAliasScalarWhereInput = {
    AND?: CaliberAliasScalarWhereInput | CaliberAliasScalarWhereInput[]
    OR?: CaliberAliasScalarWhereInput[]
    NOT?: CaliberAliasScalarWhereInput | CaliberAliasScalarWhereInput[]
    id?: IntFilter<"CaliberAlias"> | number
    caliberId?: IntFilter<"CaliberAlias"> | number
    alias?: StringFilter<"CaliberAlias"> | string
  }

  export type FirearmChamberUpsertWithWhereUniqueWithoutCaliberInput = {
    where: FirearmChamberWhereUniqueInput
    update: XOR<FirearmChamberUpdateWithoutCaliberInput, FirearmChamberUncheckedUpdateWithoutCaliberInput>
    create: XOR<FirearmChamberCreateWithoutCaliberInput, FirearmChamberUncheckedCreateWithoutCaliberInput>
  }

  export type FirearmChamberUpdateWithWhereUniqueWithoutCaliberInput = {
    where: FirearmChamberWhereUniqueInput
    data: XOR<FirearmChamberUpdateWithoutCaliberInput, FirearmChamberUncheckedUpdateWithoutCaliberInput>
  }

  export type FirearmChamberUpdateManyWithWhereWithoutCaliberInput = {
    where: FirearmChamberScalarWhereInput
    data: XOR<FirearmChamberUpdateManyMutationInput, FirearmChamberUncheckedUpdateManyWithoutCaliberInput>
  }

  export type FirearmChamberScalarWhereInput = {
    AND?: FirearmChamberScalarWhereInput | FirearmChamberScalarWhereInput[]
    OR?: FirearmChamberScalarWhereInput[]
    NOT?: FirearmChamberScalarWhereInput | FirearmChamberScalarWhereInput[]
    firearmSpecsId?: IntFilter<"FirearmChamber"> | number
    caliberId?: IntFilter<"FirearmChamber"> | number
    note?: StringNullableFilter<"FirearmChamber"> | string | null
  }

  export type AlertDeliveryCreateWithoutOfferInput = {
    id: string
    sentAt?: Date | string | null
    fingerprint: string
    Alert: AlertCreateNestedOneWithoutAlertDeliveryInput
    User: UserCreateNestedOneWithoutAlertDeliveryInput
  }

  export type AlertDeliveryUncheckedCreateWithoutOfferInput = {
    id: string
    alertId: string
    sentAt?: Date | string | null
    fingerprint: string
    userId: string
  }

  export type AlertDeliveryCreateOrConnectWithoutOfferInput = {
    where: AlertDeliveryWhereUniqueInput
    create: XOR<AlertDeliveryCreateWithoutOfferInput, AlertDeliveryUncheckedCreateWithoutOfferInput>
  }

  export type AlertDeliveryCreateManyOfferInputEnvelope = {
    data: AlertDeliveryCreateManyOfferInput | AlertDeliveryCreateManyOfferInput[]
    skipDuplicates?: boolean
  }

  export type CatalogItemCreateWithoutOfferInput = {
    id: string
    kind: $Enums.CatalogKind
    slug: string
    upc?: string | null
    mpn?: string | null
    title: string
    image?: string | null
    description?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    bestPrice?: number | null
    bestRetailerId?: number | null
    bestRetailerName?: string | null
    offerCount?: number | null
    bestCpr?: number | null
    bestCprShipped?: number | null
    upvotes?: number | null
    downvotes?: number | null
    AccessoryFitment?: AccessoryFitmentCreateNestedManyWithoutCatalogItemInput
    AccessorySpecs?: AccessorySpecsCreateNestedOneWithoutCatalogItemInput
    Alert?: AlertCreateNestedManyWithoutCatalogItemInput
    AmmoSpecs?: AmmoSpecsCreateNestedOneWithoutCatalogItemInput
    Brand?: BrandCreateNestedOneWithoutCatalogItemInput
    FirearmSpecs?: FirearmSpecsCreateNestedOneWithoutCatalogItemInput
    OwnedFirearm?: OwnedFirearmCreateNestedManyWithoutCatalogItemInput
  }

  export type CatalogItemUncheckedCreateWithoutOfferInput = {
    id: string
    kind: $Enums.CatalogKind
    slug: string
    upc?: string | null
    mpn?: string | null
    title: string
    image?: string | null
    description?: string | null
    brandId?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    bestPrice?: number | null
    bestRetailerId?: number | null
    bestRetailerName?: string | null
    offerCount?: number | null
    bestCpr?: number | null
    bestCprShipped?: number | null
    upvotes?: number | null
    downvotes?: number | null
    AccessoryFitment?: AccessoryFitmentUncheckedCreateNestedManyWithoutCatalogItemInput
    AccessorySpecs?: AccessorySpecsUncheckedCreateNestedOneWithoutCatalogItemInput
    Alert?: AlertUncheckedCreateNestedManyWithoutCatalogItemInput
    AmmoSpecs?: AmmoSpecsUncheckedCreateNestedOneWithoutCatalogItemInput
    FirearmSpecs?: FirearmSpecsUncheckedCreateNestedOneWithoutCatalogItemInput
    OwnedFirearm?: OwnedFirearmUncheckedCreateNestedManyWithoutCatalogItemInput
  }

  export type CatalogItemCreateOrConnectWithoutOfferInput = {
    where: CatalogItemWhereUniqueInput
    create: XOR<CatalogItemCreateWithoutOfferInput, CatalogItemUncheckedCreateWithoutOfferInput>
  }

  export type RetailerCreateWithoutOffersInput = {
    name: string
    domain?: string | null
    logo?: string | null
    rating?: number | null
    shippingRating?: number | null
    BlockedRetailer?: BlockedRetailerCreateNestedManyWithoutRetailerInput
  }

  export type RetailerUncheckedCreateWithoutOffersInput = {
    id?: number
    name: string
    domain?: string | null
    logo?: string | null
    rating?: number | null
    shippingRating?: number | null
    BlockedRetailer?: BlockedRetailerUncheckedCreateNestedManyWithoutRetailerInput
  }

  export type RetailerCreateOrConnectWithoutOffersInput = {
    where: RetailerWhereUniqueInput
    create: XOR<RetailerCreateWithoutOffersInput, RetailerUncheckedCreateWithoutOffersInput>
  }

  export type AlertDeliveryUpsertWithWhereUniqueWithoutOfferInput = {
    where: AlertDeliveryWhereUniqueInput
    update: XOR<AlertDeliveryUpdateWithoutOfferInput, AlertDeliveryUncheckedUpdateWithoutOfferInput>
    create: XOR<AlertDeliveryCreateWithoutOfferInput, AlertDeliveryUncheckedCreateWithoutOfferInput>
  }

  export type AlertDeliveryUpdateWithWhereUniqueWithoutOfferInput = {
    where: AlertDeliveryWhereUniqueInput
    data: XOR<AlertDeliveryUpdateWithoutOfferInput, AlertDeliveryUncheckedUpdateWithoutOfferInput>
  }

  export type AlertDeliveryUpdateManyWithWhereWithoutOfferInput = {
    where: AlertDeliveryScalarWhereInput
    data: XOR<AlertDeliveryUpdateManyMutationInput, AlertDeliveryUncheckedUpdateManyWithoutOfferInput>
  }

  export type AlertDeliveryScalarWhereInput = {
    AND?: AlertDeliveryScalarWhereInput | AlertDeliveryScalarWhereInput[]
    OR?: AlertDeliveryScalarWhereInput[]
    NOT?: AlertDeliveryScalarWhereInput | AlertDeliveryScalarWhereInput[]
    id?: StringFilter<"AlertDelivery"> | string
    alertId?: StringFilter<"AlertDelivery"> | string
    offerId?: IntNullableFilter<"AlertDelivery"> | number | null
    sentAt?: DateTimeNullableFilter<"AlertDelivery"> | Date | string | null
    fingerprint?: StringFilter<"AlertDelivery"> | string
    userId?: StringFilter<"AlertDelivery"> | string
  }

  export type CatalogItemUpsertWithoutOfferInput = {
    update: XOR<CatalogItemUpdateWithoutOfferInput, CatalogItemUncheckedUpdateWithoutOfferInput>
    create: XOR<CatalogItemCreateWithoutOfferInput, CatalogItemUncheckedCreateWithoutOfferInput>
    where?: CatalogItemWhereInput
  }

  export type CatalogItemUpdateToOneWithWhereWithoutOfferInput = {
    where?: CatalogItemWhereInput
    data: XOR<CatalogItemUpdateWithoutOfferInput, CatalogItemUncheckedUpdateWithoutOfferInput>
  }

  export type CatalogItemUpdateWithoutOfferInput = {
    id?: StringFieldUpdateOperationsInput | string
    kind?: EnumCatalogKindFieldUpdateOperationsInput | $Enums.CatalogKind
    slug?: StringFieldUpdateOperationsInput | string
    upc?: NullableStringFieldUpdateOperationsInput | string | null
    mpn?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bestPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    bestRetailerId?: NullableIntFieldUpdateOperationsInput | number | null
    bestRetailerName?: NullableStringFieldUpdateOperationsInput | string | null
    offerCount?: NullableIntFieldUpdateOperationsInput | number | null
    bestCpr?: NullableFloatFieldUpdateOperationsInput | number | null
    bestCprShipped?: NullableFloatFieldUpdateOperationsInput | number | null
    upvotes?: NullableIntFieldUpdateOperationsInput | number | null
    downvotes?: NullableIntFieldUpdateOperationsInput | number | null
    AccessoryFitment?: AccessoryFitmentUpdateManyWithoutCatalogItemNestedInput
    AccessorySpecs?: AccessorySpecsUpdateOneWithoutCatalogItemNestedInput
    Alert?: AlertUpdateManyWithoutCatalogItemNestedInput
    AmmoSpecs?: AmmoSpecsUpdateOneWithoutCatalogItemNestedInput
    Brand?: BrandUpdateOneWithoutCatalogItemNestedInput
    FirearmSpecs?: FirearmSpecsUpdateOneWithoutCatalogItemNestedInput
    OwnedFirearm?: OwnedFirearmUpdateManyWithoutCatalogItemNestedInput
  }

  export type CatalogItemUncheckedUpdateWithoutOfferInput = {
    id?: StringFieldUpdateOperationsInput | string
    kind?: EnumCatalogKindFieldUpdateOperationsInput | $Enums.CatalogKind
    slug?: StringFieldUpdateOperationsInput | string
    upc?: NullableStringFieldUpdateOperationsInput | string | null
    mpn?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    brandId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bestPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    bestRetailerId?: NullableIntFieldUpdateOperationsInput | number | null
    bestRetailerName?: NullableStringFieldUpdateOperationsInput | string | null
    offerCount?: NullableIntFieldUpdateOperationsInput | number | null
    bestCpr?: NullableFloatFieldUpdateOperationsInput | number | null
    bestCprShipped?: NullableFloatFieldUpdateOperationsInput | number | null
    upvotes?: NullableIntFieldUpdateOperationsInput | number | null
    downvotes?: NullableIntFieldUpdateOperationsInput | number | null
    AccessoryFitment?: AccessoryFitmentUncheckedUpdateManyWithoutCatalogItemNestedInput
    AccessorySpecs?: AccessorySpecsUncheckedUpdateOneWithoutCatalogItemNestedInput
    Alert?: AlertUncheckedUpdateManyWithoutCatalogItemNestedInput
    AmmoSpecs?: AmmoSpecsUncheckedUpdateOneWithoutCatalogItemNestedInput
    FirearmSpecs?: FirearmSpecsUncheckedUpdateOneWithoutCatalogItemNestedInput
    OwnedFirearm?: OwnedFirearmUncheckedUpdateManyWithoutCatalogItemNestedInput
  }

  export type RetailerUpsertWithoutOffersInput = {
    update: XOR<RetailerUpdateWithoutOffersInput, RetailerUncheckedUpdateWithoutOffersInput>
    create: XOR<RetailerCreateWithoutOffersInput, RetailerUncheckedCreateWithoutOffersInput>
    where?: RetailerWhereInput
  }

  export type RetailerUpdateToOneWithWhereWithoutOffersInput = {
    where?: RetailerWhereInput
    data: XOR<RetailerUpdateWithoutOffersInput, RetailerUncheckedUpdateWithoutOffersInput>
  }

  export type RetailerUpdateWithoutOffersInput = {
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    shippingRating?: NullableIntFieldUpdateOperationsInput | number | null
    BlockedRetailer?: BlockedRetailerUpdateManyWithoutRetailerNestedInput
  }

  export type RetailerUncheckedUpdateWithoutOffersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    shippingRating?: NullableIntFieldUpdateOperationsInput | number | null
    BlockedRetailer?: BlockedRetailerUncheckedUpdateManyWithoutRetailerNestedInput
  }

  export type BlockedRetailerCreateWithoutRetailerInput = {
    id: string
    createdAt?: Date | string | null
    User: UserCreateNestedOneWithoutBlockedRetailerInput
  }

  export type BlockedRetailerUncheckedCreateWithoutRetailerInput = {
    id: string
    userId: string
    createdAt?: Date | string | null
  }

  export type BlockedRetailerCreateOrConnectWithoutRetailerInput = {
    where: BlockedRetailerWhereUniqueInput
    create: XOR<BlockedRetailerCreateWithoutRetailerInput, BlockedRetailerUncheckedCreateWithoutRetailerInput>
  }

  export type BlockedRetailerCreateManyRetailerInputEnvelope = {
    data: BlockedRetailerCreateManyRetailerInput | BlockedRetailerCreateManyRetailerInput[]
    skipDuplicates?: boolean
  }

  export type OfferCreateWithoutRetailerInput = {
    url: string
    inStock?: boolean | null
    price: number
    currency?: string | null
    shippingCost?: number | null
    total?: number | null
    freeShipping?: boolean | null
    shippingNote?: string | null
    shippingUpdatedAt?: Date | string | null
    unitsCount?: number | null
    unitLabel?: string | null
    unitPrice?: number | null
    totalUnitPrice?: number | null
    retailerSku?: string | null
    isManuallyOOS?: boolean | null
    oosReportCount?: number | null
    lastStockChange?: Date | string | null
    lastSeen?: Date | string | null
    AlertDelivery?: AlertDeliveryCreateNestedManyWithoutOfferInput
    CatalogItem: CatalogItemCreateNestedOneWithoutOfferInput
  }

  export type OfferUncheckedCreateWithoutRetailerInput = {
    id?: number
    itemId: string
    url: string
    inStock?: boolean | null
    price: number
    currency?: string | null
    shippingCost?: number | null
    total?: number | null
    freeShipping?: boolean | null
    shippingNote?: string | null
    shippingUpdatedAt?: Date | string | null
    unitsCount?: number | null
    unitLabel?: string | null
    unitPrice?: number | null
    totalUnitPrice?: number | null
    retailerSku?: string | null
    isManuallyOOS?: boolean | null
    oosReportCount?: number | null
    lastStockChange?: Date | string | null
    lastSeen?: Date | string | null
    AlertDelivery?: AlertDeliveryUncheckedCreateNestedManyWithoutOfferInput
  }

  export type OfferCreateOrConnectWithoutRetailerInput = {
    where: OfferWhereUniqueInput
    create: XOR<OfferCreateWithoutRetailerInput, OfferUncheckedCreateWithoutRetailerInput>
  }

  export type OfferCreateManyRetailerInputEnvelope = {
    data: OfferCreateManyRetailerInput | OfferCreateManyRetailerInput[]
    skipDuplicates?: boolean
  }

  export type BlockedRetailerUpsertWithWhereUniqueWithoutRetailerInput = {
    where: BlockedRetailerWhereUniqueInput
    update: XOR<BlockedRetailerUpdateWithoutRetailerInput, BlockedRetailerUncheckedUpdateWithoutRetailerInput>
    create: XOR<BlockedRetailerCreateWithoutRetailerInput, BlockedRetailerUncheckedCreateWithoutRetailerInput>
  }

  export type BlockedRetailerUpdateWithWhereUniqueWithoutRetailerInput = {
    where: BlockedRetailerWhereUniqueInput
    data: XOR<BlockedRetailerUpdateWithoutRetailerInput, BlockedRetailerUncheckedUpdateWithoutRetailerInput>
  }

  export type BlockedRetailerUpdateManyWithWhereWithoutRetailerInput = {
    where: BlockedRetailerScalarWhereInput
    data: XOR<BlockedRetailerUpdateManyMutationInput, BlockedRetailerUncheckedUpdateManyWithoutRetailerInput>
  }

  export type BlockedRetailerScalarWhereInput = {
    AND?: BlockedRetailerScalarWhereInput | BlockedRetailerScalarWhereInput[]
    OR?: BlockedRetailerScalarWhereInput[]
    NOT?: BlockedRetailerScalarWhereInput | BlockedRetailerScalarWhereInput[]
    id?: StringFilter<"BlockedRetailer"> | string
    userId?: StringFilter<"BlockedRetailer"> | string
    retailerId?: IntFilter<"BlockedRetailer"> | number
    createdAt?: DateTimeNullableFilter<"BlockedRetailer"> | Date | string | null
  }

  export type OfferUpsertWithWhereUniqueWithoutRetailerInput = {
    where: OfferWhereUniqueInput
    update: XOR<OfferUpdateWithoutRetailerInput, OfferUncheckedUpdateWithoutRetailerInput>
    create: XOR<OfferCreateWithoutRetailerInput, OfferUncheckedCreateWithoutRetailerInput>
  }

  export type OfferUpdateWithWhereUniqueWithoutRetailerInput = {
    where: OfferWhereUniqueInput
    data: XOR<OfferUpdateWithoutRetailerInput, OfferUncheckedUpdateWithoutRetailerInput>
  }

  export type OfferUpdateManyWithWhereWithoutRetailerInput = {
    where: OfferScalarWhereInput
    data: XOR<OfferUpdateManyMutationInput, OfferUncheckedUpdateManyWithoutRetailerInput>
  }

  export type OfferScalarWhereInput = {
    AND?: OfferScalarWhereInput | OfferScalarWhereInput[]
    OR?: OfferScalarWhereInput[]
    NOT?: OfferScalarWhereInput | OfferScalarWhereInput[]
    id?: IntFilter<"Offer"> | number
    itemId?: StringFilter<"Offer"> | string
    retailerId?: IntFilter<"Offer"> | number
    url?: StringFilter<"Offer"> | string
    inStock?: BoolNullableFilter<"Offer"> | boolean | null
    price?: FloatFilter<"Offer"> | number
    currency?: StringNullableFilter<"Offer"> | string | null
    shippingCost?: FloatNullableFilter<"Offer"> | number | null
    total?: FloatNullableFilter<"Offer"> | number | null
    freeShipping?: BoolNullableFilter<"Offer"> | boolean | null
    shippingNote?: StringNullableFilter<"Offer"> | string | null
    shippingUpdatedAt?: DateTimeNullableFilter<"Offer"> | Date | string | null
    unitsCount?: IntNullableFilter<"Offer"> | number | null
    unitLabel?: StringNullableFilter<"Offer"> | string | null
    unitPrice?: FloatNullableFilter<"Offer"> | number | null
    totalUnitPrice?: FloatNullableFilter<"Offer"> | number | null
    retailerSku?: StringNullableFilter<"Offer"> | string | null
    isManuallyOOS?: BoolNullableFilter<"Offer"> | boolean | null
    oosReportCount?: IntNullableFilter<"Offer"> | number | null
    lastStockChange?: DateTimeNullableFilter<"Offer"> | Date | string | null
    lastSeen?: DateTimeNullableFilter<"Offer"> | Date | string | null
  }

  export type AccessorySpecsCreateWithoutAccessoryFitmentInput = {
    material?: string | null
    color?: string | null
    notes?: string | null
    AccessoryType?: AccessoryTypeCreateNestedOneWithoutAccessorySpecsInput
    CatalogItem: CatalogItemCreateNestedOneWithoutAccessorySpecsInput
  }

  export type AccessorySpecsUncheckedCreateWithoutAccessoryFitmentInput = {
    id?: number
    itemId: string
    accessoryTypeId?: number | null
    material?: string | null
    color?: string | null
    notes?: string | null
  }

  export type AccessorySpecsCreateOrConnectWithoutAccessoryFitmentInput = {
    where: AccessorySpecsWhereUniqueInput
    create: XOR<AccessorySpecsCreateWithoutAccessoryFitmentInput, AccessorySpecsUncheckedCreateWithoutAccessoryFitmentInput>
  }

  export type CatalogItemCreateWithoutAccessoryFitmentInput = {
    id: string
    kind: $Enums.CatalogKind
    slug: string
    upc?: string | null
    mpn?: string | null
    title: string
    image?: string | null
    description?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    bestPrice?: number | null
    bestRetailerId?: number | null
    bestRetailerName?: string | null
    offerCount?: number | null
    bestCpr?: number | null
    bestCprShipped?: number | null
    upvotes?: number | null
    downvotes?: number | null
    AccessorySpecs?: AccessorySpecsCreateNestedOneWithoutCatalogItemInput
    Alert?: AlertCreateNestedManyWithoutCatalogItemInput
    AmmoSpecs?: AmmoSpecsCreateNestedOneWithoutCatalogItemInput
    Brand?: BrandCreateNestedOneWithoutCatalogItemInput
    FirearmSpecs?: FirearmSpecsCreateNestedOneWithoutCatalogItemInput
    Offer?: OfferCreateNestedManyWithoutCatalogItemInput
    OwnedFirearm?: OwnedFirearmCreateNestedManyWithoutCatalogItemInput
  }

  export type CatalogItemUncheckedCreateWithoutAccessoryFitmentInput = {
    id: string
    kind: $Enums.CatalogKind
    slug: string
    upc?: string | null
    mpn?: string | null
    title: string
    image?: string | null
    description?: string | null
    brandId?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    bestPrice?: number | null
    bestRetailerId?: number | null
    bestRetailerName?: string | null
    offerCount?: number | null
    bestCpr?: number | null
    bestCprShipped?: number | null
    upvotes?: number | null
    downvotes?: number | null
    AccessorySpecs?: AccessorySpecsUncheckedCreateNestedOneWithoutCatalogItemInput
    Alert?: AlertUncheckedCreateNestedManyWithoutCatalogItemInput
    AmmoSpecs?: AmmoSpecsUncheckedCreateNestedOneWithoutCatalogItemInput
    FirearmSpecs?: FirearmSpecsUncheckedCreateNestedOneWithoutCatalogItemInput
    Offer?: OfferUncheckedCreateNestedManyWithoutCatalogItemInput
    OwnedFirearm?: OwnedFirearmUncheckedCreateNestedManyWithoutCatalogItemInput
  }

  export type CatalogItemCreateOrConnectWithoutAccessoryFitmentInput = {
    where: CatalogItemWhereUniqueInput
    create: XOR<CatalogItemCreateWithoutAccessoryFitmentInput, CatalogItemUncheckedCreateWithoutAccessoryFitmentInput>
  }

  export type AccessorySpecsUpsertWithoutAccessoryFitmentInput = {
    update: XOR<AccessorySpecsUpdateWithoutAccessoryFitmentInput, AccessorySpecsUncheckedUpdateWithoutAccessoryFitmentInput>
    create: XOR<AccessorySpecsCreateWithoutAccessoryFitmentInput, AccessorySpecsUncheckedCreateWithoutAccessoryFitmentInput>
    where?: AccessorySpecsWhereInput
  }

  export type AccessorySpecsUpdateToOneWithWhereWithoutAccessoryFitmentInput = {
    where?: AccessorySpecsWhereInput
    data: XOR<AccessorySpecsUpdateWithoutAccessoryFitmentInput, AccessorySpecsUncheckedUpdateWithoutAccessoryFitmentInput>
  }

  export type AccessorySpecsUpdateWithoutAccessoryFitmentInput = {
    material?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    AccessoryType?: AccessoryTypeUpdateOneWithoutAccessorySpecsNestedInput
    CatalogItem?: CatalogItemUpdateOneRequiredWithoutAccessorySpecsNestedInput
  }

  export type AccessorySpecsUncheckedUpdateWithoutAccessoryFitmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemId?: StringFieldUpdateOperationsInput | string
    accessoryTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CatalogItemUpsertWithoutAccessoryFitmentInput = {
    update: XOR<CatalogItemUpdateWithoutAccessoryFitmentInput, CatalogItemUncheckedUpdateWithoutAccessoryFitmentInput>
    create: XOR<CatalogItemCreateWithoutAccessoryFitmentInput, CatalogItemUncheckedCreateWithoutAccessoryFitmentInput>
    where?: CatalogItemWhereInput
  }

  export type CatalogItemUpdateToOneWithWhereWithoutAccessoryFitmentInput = {
    where?: CatalogItemWhereInput
    data: XOR<CatalogItemUpdateWithoutAccessoryFitmentInput, CatalogItemUncheckedUpdateWithoutAccessoryFitmentInput>
  }

  export type CatalogItemUpdateWithoutAccessoryFitmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    kind?: EnumCatalogKindFieldUpdateOperationsInput | $Enums.CatalogKind
    slug?: StringFieldUpdateOperationsInput | string
    upc?: NullableStringFieldUpdateOperationsInput | string | null
    mpn?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bestPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    bestRetailerId?: NullableIntFieldUpdateOperationsInput | number | null
    bestRetailerName?: NullableStringFieldUpdateOperationsInput | string | null
    offerCount?: NullableIntFieldUpdateOperationsInput | number | null
    bestCpr?: NullableFloatFieldUpdateOperationsInput | number | null
    bestCprShipped?: NullableFloatFieldUpdateOperationsInput | number | null
    upvotes?: NullableIntFieldUpdateOperationsInput | number | null
    downvotes?: NullableIntFieldUpdateOperationsInput | number | null
    AccessorySpecs?: AccessorySpecsUpdateOneWithoutCatalogItemNestedInput
    Alert?: AlertUpdateManyWithoutCatalogItemNestedInput
    AmmoSpecs?: AmmoSpecsUpdateOneWithoutCatalogItemNestedInput
    Brand?: BrandUpdateOneWithoutCatalogItemNestedInput
    FirearmSpecs?: FirearmSpecsUpdateOneWithoutCatalogItemNestedInput
    Offer?: OfferUpdateManyWithoutCatalogItemNestedInput
    OwnedFirearm?: OwnedFirearmUpdateManyWithoutCatalogItemNestedInput
  }

  export type CatalogItemUncheckedUpdateWithoutAccessoryFitmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    kind?: EnumCatalogKindFieldUpdateOperationsInput | $Enums.CatalogKind
    slug?: StringFieldUpdateOperationsInput | string
    upc?: NullableStringFieldUpdateOperationsInput | string | null
    mpn?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    brandId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bestPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    bestRetailerId?: NullableIntFieldUpdateOperationsInput | number | null
    bestRetailerName?: NullableStringFieldUpdateOperationsInput | string | null
    offerCount?: NullableIntFieldUpdateOperationsInput | number | null
    bestCpr?: NullableFloatFieldUpdateOperationsInput | number | null
    bestCprShipped?: NullableFloatFieldUpdateOperationsInput | number | null
    upvotes?: NullableIntFieldUpdateOperationsInput | number | null
    downvotes?: NullableIntFieldUpdateOperationsInput | number | null
    AccessorySpecs?: AccessorySpecsUncheckedUpdateOneWithoutCatalogItemNestedInput
    Alert?: AlertUncheckedUpdateManyWithoutCatalogItemNestedInput
    AmmoSpecs?: AmmoSpecsUncheckedUpdateOneWithoutCatalogItemNestedInput
    FirearmSpecs?: FirearmSpecsUncheckedUpdateOneWithoutCatalogItemNestedInput
    Offer?: OfferUncheckedUpdateManyWithoutCatalogItemNestedInput
    OwnedFirearm?: OwnedFirearmUncheckedUpdateManyWithoutCatalogItemNestedInput
  }

  export type AccessoryFitmentCreateWithoutAccessorySpecsInput = {
    fitmentType: $Enums.FitmentType
    platform?: string | null
    note?: string | null
    CatalogItem?: CatalogItemCreateNestedOneWithoutAccessoryFitmentInput
  }

  export type AccessoryFitmentUncheckedCreateWithoutAccessorySpecsInput = {
    id?: number
    fitmentType: $Enums.FitmentType
    firearmItemId?: string | null
    platform?: string | null
    note?: string | null
  }

  export type AccessoryFitmentCreateOrConnectWithoutAccessorySpecsInput = {
    where: AccessoryFitmentWhereUniqueInput
    create: XOR<AccessoryFitmentCreateWithoutAccessorySpecsInput, AccessoryFitmentUncheckedCreateWithoutAccessorySpecsInput>
  }

  export type AccessoryFitmentCreateManyAccessorySpecsInputEnvelope = {
    data: AccessoryFitmentCreateManyAccessorySpecsInput | AccessoryFitmentCreateManyAccessorySpecsInput[]
    skipDuplicates?: boolean
  }

  export type AccessoryTypeCreateWithoutAccessorySpecsInput = {
    name: string
    slug: string
  }

  export type AccessoryTypeUncheckedCreateWithoutAccessorySpecsInput = {
    id?: number
    name: string
    slug: string
  }

  export type AccessoryTypeCreateOrConnectWithoutAccessorySpecsInput = {
    where: AccessoryTypeWhereUniqueInput
    create: XOR<AccessoryTypeCreateWithoutAccessorySpecsInput, AccessoryTypeUncheckedCreateWithoutAccessorySpecsInput>
  }

  export type CatalogItemCreateWithoutAccessorySpecsInput = {
    id: string
    kind: $Enums.CatalogKind
    slug: string
    upc?: string | null
    mpn?: string | null
    title: string
    image?: string | null
    description?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    bestPrice?: number | null
    bestRetailerId?: number | null
    bestRetailerName?: string | null
    offerCount?: number | null
    bestCpr?: number | null
    bestCprShipped?: number | null
    upvotes?: number | null
    downvotes?: number | null
    AccessoryFitment?: AccessoryFitmentCreateNestedManyWithoutCatalogItemInput
    Alert?: AlertCreateNestedManyWithoutCatalogItemInput
    AmmoSpecs?: AmmoSpecsCreateNestedOneWithoutCatalogItemInput
    Brand?: BrandCreateNestedOneWithoutCatalogItemInput
    FirearmSpecs?: FirearmSpecsCreateNestedOneWithoutCatalogItemInput
    Offer?: OfferCreateNestedManyWithoutCatalogItemInput
    OwnedFirearm?: OwnedFirearmCreateNestedManyWithoutCatalogItemInput
  }

  export type CatalogItemUncheckedCreateWithoutAccessorySpecsInput = {
    id: string
    kind: $Enums.CatalogKind
    slug: string
    upc?: string | null
    mpn?: string | null
    title: string
    image?: string | null
    description?: string | null
    brandId?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    bestPrice?: number | null
    bestRetailerId?: number | null
    bestRetailerName?: string | null
    offerCount?: number | null
    bestCpr?: number | null
    bestCprShipped?: number | null
    upvotes?: number | null
    downvotes?: number | null
    AccessoryFitment?: AccessoryFitmentUncheckedCreateNestedManyWithoutCatalogItemInput
    Alert?: AlertUncheckedCreateNestedManyWithoutCatalogItemInput
    AmmoSpecs?: AmmoSpecsUncheckedCreateNestedOneWithoutCatalogItemInput
    FirearmSpecs?: FirearmSpecsUncheckedCreateNestedOneWithoutCatalogItemInput
    Offer?: OfferUncheckedCreateNestedManyWithoutCatalogItemInput
    OwnedFirearm?: OwnedFirearmUncheckedCreateNestedManyWithoutCatalogItemInput
  }

  export type CatalogItemCreateOrConnectWithoutAccessorySpecsInput = {
    where: CatalogItemWhereUniqueInput
    create: XOR<CatalogItemCreateWithoutAccessorySpecsInput, CatalogItemUncheckedCreateWithoutAccessorySpecsInput>
  }

  export type AccessoryFitmentUpsertWithWhereUniqueWithoutAccessorySpecsInput = {
    where: AccessoryFitmentWhereUniqueInput
    update: XOR<AccessoryFitmentUpdateWithoutAccessorySpecsInput, AccessoryFitmentUncheckedUpdateWithoutAccessorySpecsInput>
    create: XOR<AccessoryFitmentCreateWithoutAccessorySpecsInput, AccessoryFitmentUncheckedCreateWithoutAccessorySpecsInput>
  }

  export type AccessoryFitmentUpdateWithWhereUniqueWithoutAccessorySpecsInput = {
    where: AccessoryFitmentWhereUniqueInput
    data: XOR<AccessoryFitmentUpdateWithoutAccessorySpecsInput, AccessoryFitmentUncheckedUpdateWithoutAccessorySpecsInput>
  }

  export type AccessoryFitmentUpdateManyWithWhereWithoutAccessorySpecsInput = {
    where: AccessoryFitmentScalarWhereInput
    data: XOR<AccessoryFitmentUpdateManyMutationInput, AccessoryFitmentUncheckedUpdateManyWithoutAccessorySpecsInput>
  }

  export type AccessoryFitmentScalarWhereInput = {
    AND?: AccessoryFitmentScalarWhereInput | AccessoryFitmentScalarWhereInput[]
    OR?: AccessoryFitmentScalarWhereInput[]
    NOT?: AccessoryFitmentScalarWhereInput | AccessoryFitmentScalarWhereInput[]
    id?: IntFilter<"AccessoryFitment"> | number
    accessorySpecsId?: IntFilter<"AccessoryFitment"> | number
    fitmentType?: EnumFitmentTypeFilter<"AccessoryFitment"> | $Enums.FitmentType
    firearmItemId?: StringNullableFilter<"AccessoryFitment"> | string | null
    platform?: StringNullableFilter<"AccessoryFitment"> | string | null
    note?: StringNullableFilter<"AccessoryFitment"> | string | null
  }

  export type AccessoryTypeUpsertWithoutAccessorySpecsInput = {
    update: XOR<AccessoryTypeUpdateWithoutAccessorySpecsInput, AccessoryTypeUncheckedUpdateWithoutAccessorySpecsInput>
    create: XOR<AccessoryTypeCreateWithoutAccessorySpecsInput, AccessoryTypeUncheckedCreateWithoutAccessorySpecsInput>
    where?: AccessoryTypeWhereInput
  }

  export type AccessoryTypeUpdateToOneWithWhereWithoutAccessorySpecsInput = {
    where?: AccessoryTypeWhereInput
    data: XOR<AccessoryTypeUpdateWithoutAccessorySpecsInput, AccessoryTypeUncheckedUpdateWithoutAccessorySpecsInput>
  }

  export type AccessoryTypeUpdateWithoutAccessorySpecsInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type AccessoryTypeUncheckedUpdateWithoutAccessorySpecsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type CatalogItemUpsertWithoutAccessorySpecsInput = {
    update: XOR<CatalogItemUpdateWithoutAccessorySpecsInput, CatalogItemUncheckedUpdateWithoutAccessorySpecsInput>
    create: XOR<CatalogItemCreateWithoutAccessorySpecsInput, CatalogItemUncheckedCreateWithoutAccessorySpecsInput>
    where?: CatalogItemWhereInput
  }

  export type CatalogItemUpdateToOneWithWhereWithoutAccessorySpecsInput = {
    where?: CatalogItemWhereInput
    data: XOR<CatalogItemUpdateWithoutAccessorySpecsInput, CatalogItemUncheckedUpdateWithoutAccessorySpecsInput>
  }

  export type CatalogItemUpdateWithoutAccessorySpecsInput = {
    id?: StringFieldUpdateOperationsInput | string
    kind?: EnumCatalogKindFieldUpdateOperationsInput | $Enums.CatalogKind
    slug?: StringFieldUpdateOperationsInput | string
    upc?: NullableStringFieldUpdateOperationsInput | string | null
    mpn?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bestPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    bestRetailerId?: NullableIntFieldUpdateOperationsInput | number | null
    bestRetailerName?: NullableStringFieldUpdateOperationsInput | string | null
    offerCount?: NullableIntFieldUpdateOperationsInput | number | null
    bestCpr?: NullableFloatFieldUpdateOperationsInput | number | null
    bestCprShipped?: NullableFloatFieldUpdateOperationsInput | number | null
    upvotes?: NullableIntFieldUpdateOperationsInput | number | null
    downvotes?: NullableIntFieldUpdateOperationsInput | number | null
    AccessoryFitment?: AccessoryFitmentUpdateManyWithoutCatalogItemNestedInput
    Alert?: AlertUpdateManyWithoutCatalogItemNestedInput
    AmmoSpecs?: AmmoSpecsUpdateOneWithoutCatalogItemNestedInput
    Brand?: BrandUpdateOneWithoutCatalogItemNestedInput
    FirearmSpecs?: FirearmSpecsUpdateOneWithoutCatalogItemNestedInput
    Offer?: OfferUpdateManyWithoutCatalogItemNestedInput
    OwnedFirearm?: OwnedFirearmUpdateManyWithoutCatalogItemNestedInput
  }

  export type CatalogItemUncheckedUpdateWithoutAccessorySpecsInput = {
    id?: StringFieldUpdateOperationsInput | string
    kind?: EnumCatalogKindFieldUpdateOperationsInput | $Enums.CatalogKind
    slug?: StringFieldUpdateOperationsInput | string
    upc?: NullableStringFieldUpdateOperationsInput | string | null
    mpn?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    brandId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bestPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    bestRetailerId?: NullableIntFieldUpdateOperationsInput | number | null
    bestRetailerName?: NullableStringFieldUpdateOperationsInput | string | null
    offerCount?: NullableIntFieldUpdateOperationsInput | number | null
    bestCpr?: NullableFloatFieldUpdateOperationsInput | number | null
    bestCprShipped?: NullableFloatFieldUpdateOperationsInput | number | null
    upvotes?: NullableIntFieldUpdateOperationsInput | number | null
    downvotes?: NullableIntFieldUpdateOperationsInput | number | null
    AccessoryFitment?: AccessoryFitmentUncheckedUpdateManyWithoutCatalogItemNestedInput
    Alert?: AlertUncheckedUpdateManyWithoutCatalogItemNestedInput
    AmmoSpecs?: AmmoSpecsUncheckedUpdateOneWithoutCatalogItemNestedInput
    FirearmSpecs?: FirearmSpecsUncheckedUpdateOneWithoutCatalogItemNestedInput
    Offer?: OfferUncheckedUpdateManyWithoutCatalogItemNestedInput
    OwnedFirearm?: OwnedFirearmUncheckedUpdateManyWithoutCatalogItemNestedInput
  }

  export type AccessorySpecsCreateWithoutAccessoryTypeInput = {
    material?: string | null
    color?: string | null
    notes?: string | null
    AccessoryFitment?: AccessoryFitmentCreateNestedManyWithoutAccessorySpecsInput
    CatalogItem: CatalogItemCreateNestedOneWithoutAccessorySpecsInput
  }

  export type AccessorySpecsUncheckedCreateWithoutAccessoryTypeInput = {
    id?: number
    itemId: string
    material?: string | null
    color?: string | null
    notes?: string | null
    AccessoryFitment?: AccessoryFitmentUncheckedCreateNestedManyWithoutAccessorySpecsInput
  }

  export type AccessorySpecsCreateOrConnectWithoutAccessoryTypeInput = {
    where: AccessorySpecsWhereUniqueInput
    create: XOR<AccessorySpecsCreateWithoutAccessoryTypeInput, AccessorySpecsUncheckedCreateWithoutAccessoryTypeInput>
  }

  export type AccessorySpecsCreateManyAccessoryTypeInputEnvelope = {
    data: AccessorySpecsCreateManyAccessoryTypeInput | AccessorySpecsCreateManyAccessoryTypeInput[]
    skipDuplicates?: boolean
  }

  export type AccessorySpecsUpsertWithWhereUniqueWithoutAccessoryTypeInput = {
    where: AccessorySpecsWhereUniqueInput
    update: XOR<AccessorySpecsUpdateWithoutAccessoryTypeInput, AccessorySpecsUncheckedUpdateWithoutAccessoryTypeInput>
    create: XOR<AccessorySpecsCreateWithoutAccessoryTypeInput, AccessorySpecsUncheckedCreateWithoutAccessoryTypeInput>
  }

  export type AccessorySpecsUpdateWithWhereUniqueWithoutAccessoryTypeInput = {
    where: AccessorySpecsWhereUniqueInput
    data: XOR<AccessorySpecsUpdateWithoutAccessoryTypeInput, AccessorySpecsUncheckedUpdateWithoutAccessoryTypeInput>
  }

  export type AccessorySpecsUpdateManyWithWhereWithoutAccessoryTypeInput = {
    where: AccessorySpecsScalarWhereInput
    data: XOR<AccessorySpecsUpdateManyMutationInput, AccessorySpecsUncheckedUpdateManyWithoutAccessoryTypeInput>
  }

  export type AccessorySpecsScalarWhereInput = {
    AND?: AccessorySpecsScalarWhereInput | AccessorySpecsScalarWhereInput[]
    OR?: AccessorySpecsScalarWhereInput[]
    NOT?: AccessorySpecsScalarWhereInput | AccessorySpecsScalarWhereInput[]
    id?: IntFilter<"AccessorySpecs"> | number
    itemId?: StringFilter<"AccessorySpecs"> | string
    accessoryTypeId?: IntNullableFilter<"AccessorySpecs"> | number | null
    material?: StringNullableFilter<"AccessorySpecs"> | string | null
    color?: StringNullableFilter<"AccessorySpecs"> | string | null
    notes?: StringNullableFilter<"AccessorySpecs"> | string | null
  }

  export type CaliberCreateWithoutAlertInput = {
    name: string
    slug: string
    type?: string | null
    AmmoSpecs?: AmmoSpecsCreateNestedManyWithoutCaliberInput
    CaliberAlias?: CaliberAliasCreateNestedManyWithoutCaliberInput
    FirearmChamber?: FirearmChamberCreateNestedManyWithoutCaliberInput
  }

  export type CaliberUncheckedCreateWithoutAlertInput = {
    id?: number
    name: string
    slug: string
    type?: string | null
    AmmoSpecs?: AmmoSpecsUncheckedCreateNestedManyWithoutCaliberInput
    CaliberAlias?: CaliberAliasUncheckedCreateNestedManyWithoutCaliberInput
    FirearmChamber?: FirearmChamberUncheckedCreateNestedManyWithoutCaliberInput
  }

  export type CaliberCreateOrConnectWithoutAlertInput = {
    where: CaliberWhereUniqueInput
    create: XOR<CaliberCreateWithoutAlertInput, CaliberUncheckedCreateWithoutAlertInput>
  }

  export type CatalogItemCreateWithoutAlertInput = {
    id: string
    kind: $Enums.CatalogKind
    slug: string
    upc?: string | null
    mpn?: string | null
    title: string
    image?: string | null
    description?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    bestPrice?: number | null
    bestRetailerId?: number | null
    bestRetailerName?: string | null
    offerCount?: number | null
    bestCpr?: number | null
    bestCprShipped?: number | null
    upvotes?: number | null
    downvotes?: number | null
    AccessoryFitment?: AccessoryFitmentCreateNestedManyWithoutCatalogItemInput
    AccessorySpecs?: AccessorySpecsCreateNestedOneWithoutCatalogItemInput
    AmmoSpecs?: AmmoSpecsCreateNestedOneWithoutCatalogItemInput
    Brand?: BrandCreateNestedOneWithoutCatalogItemInput
    FirearmSpecs?: FirearmSpecsCreateNestedOneWithoutCatalogItemInput
    Offer?: OfferCreateNestedManyWithoutCatalogItemInput
    OwnedFirearm?: OwnedFirearmCreateNestedManyWithoutCatalogItemInput
  }

  export type CatalogItemUncheckedCreateWithoutAlertInput = {
    id: string
    kind: $Enums.CatalogKind
    slug: string
    upc?: string | null
    mpn?: string | null
    title: string
    image?: string | null
    description?: string | null
    brandId?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    bestPrice?: number | null
    bestRetailerId?: number | null
    bestRetailerName?: string | null
    offerCount?: number | null
    bestCpr?: number | null
    bestCprShipped?: number | null
    upvotes?: number | null
    downvotes?: number | null
    AccessoryFitment?: AccessoryFitmentUncheckedCreateNestedManyWithoutCatalogItemInput
    AccessorySpecs?: AccessorySpecsUncheckedCreateNestedOneWithoutCatalogItemInput
    AmmoSpecs?: AmmoSpecsUncheckedCreateNestedOneWithoutCatalogItemInput
    FirearmSpecs?: FirearmSpecsUncheckedCreateNestedOneWithoutCatalogItemInput
    Offer?: OfferUncheckedCreateNestedManyWithoutCatalogItemInput
    OwnedFirearm?: OwnedFirearmUncheckedCreateNestedManyWithoutCatalogItemInput
  }

  export type CatalogItemCreateOrConnectWithoutAlertInput = {
    where: CatalogItemWhereUniqueInput
    create: XOR<CatalogItemCreateWithoutAlertInput, CatalogItemUncheckedCreateWithoutAlertInput>
  }

  export type UserCreateWithoutAlertInput = {
    id: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    AlertDelivery?: AlertDeliveryCreateNestedManyWithoutUserInput
    BlockedRetailer?: BlockedRetailerCreateNestedManyWithoutUserInput
    OwnedFirearm?: OwnedFirearmCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAlertInput = {
    id: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    AlertDelivery?: AlertDeliveryUncheckedCreateNestedManyWithoutUserInput
    BlockedRetailer?: BlockedRetailerUncheckedCreateNestedManyWithoutUserInput
    OwnedFirearm?: OwnedFirearmUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAlertInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAlertInput, UserUncheckedCreateWithoutAlertInput>
  }

  export type AlertDeliveryCreateWithoutAlertInput = {
    id: string
    sentAt?: Date | string | null
    fingerprint: string
    Offer?: OfferCreateNestedOneWithoutAlertDeliveryInput
    User: UserCreateNestedOneWithoutAlertDeliveryInput
  }

  export type AlertDeliveryUncheckedCreateWithoutAlertInput = {
    id: string
    offerId?: number | null
    sentAt?: Date | string | null
    fingerprint: string
    userId: string
  }

  export type AlertDeliveryCreateOrConnectWithoutAlertInput = {
    where: AlertDeliveryWhereUniqueInput
    create: XOR<AlertDeliveryCreateWithoutAlertInput, AlertDeliveryUncheckedCreateWithoutAlertInput>
  }

  export type AlertDeliveryCreateManyAlertInputEnvelope = {
    data: AlertDeliveryCreateManyAlertInput | AlertDeliveryCreateManyAlertInput[]
    skipDuplicates?: boolean
  }

  export type CaliberUpsertWithoutAlertInput = {
    update: XOR<CaliberUpdateWithoutAlertInput, CaliberUncheckedUpdateWithoutAlertInput>
    create: XOR<CaliberCreateWithoutAlertInput, CaliberUncheckedCreateWithoutAlertInput>
    where?: CaliberWhereInput
  }

  export type CaliberUpdateToOneWithWhereWithoutAlertInput = {
    where?: CaliberWhereInput
    data: XOR<CaliberUpdateWithoutAlertInput, CaliberUncheckedUpdateWithoutAlertInput>
  }

  export type CaliberUpdateWithoutAlertInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    AmmoSpecs?: AmmoSpecsUpdateManyWithoutCaliberNestedInput
    CaliberAlias?: CaliberAliasUpdateManyWithoutCaliberNestedInput
    FirearmChamber?: FirearmChamberUpdateManyWithoutCaliberNestedInput
  }

  export type CaliberUncheckedUpdateWithoutAlertInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    AmmoSpecs?: AmmoSpecsUncheckedUpdateManyWithoutCaliberNestedInput
    CaliberAlias?: CaliberAliasUncheckedUpdateManyWithoutCaliberNestedInput
    FirearmChamber?: FirearmChamberUncheckedUpdateManyWithoutCaliberNestedInput
  }

  export type CatalogItemUpsertWithoutAlertInput = {
    update: XOR<CatalogItemUpdateWithoutAlertInput, CatalogItemUncheckedUpdateWithoutAlertInput>
    create: XOR<CatalogItemCreateWithoutAlertInput, CatalogItemUncheckedCreateWithoutAlertInput>
    where?: CatalogItemWhereInput
  }

  export type CatalogItemUpdateToOneWithWhereWithoutAlertInput = {
    where?: CatalogItemWhereInput
    data: XOR<CatalogItemUpdateWithoutAlertInput, CatalogItemUncheckedUpdateWithoutAlertInput>
  }

  export type CatalogItemUpdateWithoutAlertInput = {
    id?: StringFieldUpdateOperationsInput | string
    kind?: EnumCatalogKindFieldUpdateOperationsInput | $Enums.CatalogKind
    slug?: StringFieldUpdateOperationsInput | string
    upc?: NullableStringFieldUpdateOperationsInput | string | null
    mpn?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bestPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    bestRetailerId?: NullableIntFieldUpdateOperationsInput | number | null
    bestRetailerName?: NullableStringFieldUpdateOperationsInput | string | null
    offerCount?: NullableIntFieldUpdateOperationsInput | number | null
    bestCpr?: NullableFloatFieldUpdateOperationsInput | number | null
    bestCprShipped?: NullableFloatFieldUpdateOperationsInput | number | null
    upvotes?: NullableIntFieldUpdateOperationsInput | number | null
    downvotes?: NullableIntFieldUpdateOperationsInput | number | null
    AccessoryFitment?: AccessoryFitmentUpdateManyWithoutCatalogItemNestedInput
    AccessorySpecs?: AccessorySpecsUpdateOneWithoutCatalogItemNestedInput
    AmmoSpecs?: AmmoSpecsUpdateOneWithoutCatalogItemNestedInput
    Brand?: BrandUpdateOneWithoutCatalogItemNestedInput
    FirearmSpecs?: FirearmSpecsUpdateOneWithoutCatalogItemNestedInput
    Offer?: OfferUpdateManyWithoutCatalogItemNestedInput
    OwnedFirearm?: OwnedFirearmUpdateManyWithoutCatalogItemNestedInput
  }

  export type CatalogItemUncheckedUpdateWithoutAlertInput = {
    id?: StringFieldUpdateOperationsInput | string
    kind?: EnumCatalogKindFieldUpdateOperationsInput | $Enums.CatalogKind
    slug?: StringFieldUpdateOperationsInput | string
    upc?: NullableStringFieldUpdateOperationsInput | string | null
    mpn?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    brandId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bestPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    bestRetailerId?: NullableIntFieldUpdateOperationsInput | number | null
    bestRetailerName?: NullableStringFieldUpdateOperationsInput | string | null
    offerCount?: NullableIntFieldUpdateOperationsInput | number | null
    bestCpr?: NullableFloatFieldUpdateOperationsInput | number | null
    bestCprShipped?: NullableFloatFieldUpdateOperationsInput | number | null
    upvotes?: NullableIntFieldUpdateOperationsInput | number | null
    downvotes?: NullableIntFieldUpdateOperationsInput | number | null
    AccessoryFitment?: AccessoryFitmentUncheckedUpdateManyWithoutCatalogItemNestedInput
    AccessorySpecs?: AccessorySpecsUncheckedUpdateOneWithoutCatalogItemNestedInput
    AmmoSpecs?: AmmoSpecsUncheckedUpdateOneWithoutCatalogItemNestedInput
    FirearmSpecs?: FirearmSpecsUncheckedUpdateOneWithoutCatalogItemNestedInput
    Offer?: OfferUncheckedUpdateManyWithoutCatalogItemNestedInput
    OwnedFirearm?: OwnedFirearmUncheckedUpdateManyWithoutCatalogItemNestedInput
  }

  export type UserUpsertWithoutAlertInput = {
    update: XOR<UserUpdateWithoutAlertInput, UserUncheckedUpdateWithoutAlertInput>
    create: XOR<UserCreateWithoutAlertInput, UserUncheckedCreateWithoutAlertInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAlertInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAlertInput, UserUncheckedUpdateWithoutAlertInput>
  }

  export type UserUpdateWithoutAlertInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    AlertDelivery?: AlertDeliveryUpdateManyWithoutUserNestedInput
    BlockedRetailer?: BlockedRetailerUpdateManyWithoutUserNestedInput
    OwnedFirearm?: OwnedFirearmUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAlertInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    AlertDelivery?: AlertDeliveryUncheckedUpdateManyWithoutUserNestedInput
    BlockedRetailer?: BlockedRetailerUncheckedUpdateManyWithoutUserNestedInput
    OwnedFirearm?: OwnedFirearmUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AlertDeliveryUpsertWithWhereUniqueWithoutAlertInput = {
    where: AlertDeliveryWhereUniqueInput
    update: XOR<AlertDeliveryUpdateWithoutAlertInput, AlertDeliveryUncheckedUpdateWithoutAlertInput>
    create: XOR<AlertDeliveryCreateWithoutAlertInput, AlertDeliveryUncheckedCreateWithoutAlertInput>
  }

  export type AlertDeliveryUpdateWithWhereUniqueWithoutAlertInput = {
    where: AlertDeliveryWhereUniqueInput
    data: XOR<AlertDeliveryUpdateWithoutAlertInput, AlertDeliveryUncheckedUpdateWithoutAlertInput>
  }

  export type AlertDeliveryUpdateManyWithWhereWithoutAlertInput = {
    where: AlertDeliveryScalarWhereInput
    data: XOR<AlertDeliveryUpdateManyMutationInput, AlertDeliveryUncheckedUpdateManyWithoutAlertInput>
  }

  export type AlertCreateWithoutAlertDeliveryInput = {
    id: string
    type: $Enums.AlertType
    keyword?: string | null
    targetCpr?: number | null
    excludeSteel?: boolean | null
    excludeReman?: boolean | null
    lastTriggered?: Date | string | null
    isActive?: boolean | null
    createdAt?: Date | string | null
    Caliber?: CaliberCreateNestedOneWithoutAlertInput
    CatalogItem?: CatalogItemCreateNestedOneWithoutAlertInput
    User: UserCreateNestedOneWithoutAlertInput
  }

  export type AlertUncheckedCreateWithoutAlertDeliveryInput = {
    id: string
    userId: string
    type: $Enums.AlertType
    calId?: number | null
    itemId?: string | null
    keyword?: string | null
    targetCpr?: number | null
    excludeSteel?: boolean | null
    excludeReman?: boolean | null
    lastTriggered?: Date | string | null
    isActive?: boolean | null
    createdAt?: Date | string | null
  }

  export type AlertCreateOrConnectWithoutAlertDeliveryInput = {
    where: AlertWhereUniqueInput
    create: XOR<AlertCreateWithoutAlertDeliveryInput, AlertUncheckedCreateWithoutAlertDeliveryInput>
  }

  export type OfferCreateWithoutAlertDeliveryInput = {
    url: string
    inStock?: boolean | null
    price: number
    currency?: string | null
    shippingCost?: number | null
    total?: number | null
    freeShipping?: boolean | null
    shippingNote?: string | null
    shippingUpdatedAt?: Date | string | null
    unitsCount?: number | null
    unitLabel?: string | null
    unitPrice?: number | null
    totalUnitPrice?: number | null
    retailerSku?: string | null
    isManuallyOOS?: boolean | null
    oosReportCount?: number | null
    lastStockChange?: Date | string | null
    lastSeen?: Date | string | null
    CatalogItem: CatalogItemCreateNestedOneWithoutOfferInput
    retailer: RetailerCreateNestedOneWithoutOffersInput
  }

  export type OfferUncheckedCreateWithoutAlertDeliveryInput = {
    id?: number
    itemId: string
    retailerId: number
    url: string
    inStock?: boolean | null
    price: number
    currency?: string | null
    shippingCost?: number | null
    total?: number | null
    freeShipping?: boolean | null
    shippingNote?: string | null
    shippingUpdatedAt?: Date | string | null
    unitsCount?: number | null
    unitLabel?: string | null
    unitPrice?: number | null
    totalUnitPrice?: number | null
    retailerSku?: string | null
    isManuallyOOS?: boolean | null
    oosReportCount?: number | null
    lastStockChange?: Date | string | null
    lastSeen?: Date | string | null
  }

  export type OfferCreateOrConnectWithoutAlertDeliveryInput = {
    where: OfferWhereUniqueInput
    create: XOR<OfferCreateWithoutAlertDeliveryInput, OfferUncheckedCreateWithoutAlertDeliveryInput>
  }

  export type UserCreateWithoutAlertDeliveryInput = {
    id: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    Alert?: AlertCreateNestedManyWithoutUserInput
    BlockedRetailer?: BlockedRetailerCreateNestedManyWithoutUserInput
    OwnedFirearm?: OwnedFirearmCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAlertDeliveryInput = {
    id: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    Alert?: AlertUncheckedCreateNestedManyWithoutUserInput
    BlockedRetailer?: BlockedRetailerUncheckedCreateNestedManyWithoutUserInput
    OwnedFirearm?: OwnedFirearmUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAlertDeliveryInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAlertDeliveryInput, UserUncheckedCreateWithoutAlertDeliveryInput>
  }

  export type AlertUpsertWithoutAlertDeliveryInput = {
    update: XOR<AlertUpdateWithoutAlertDeliveryInput, AlertUncheckedUpdateWithoutAlertDeliveryInput>
    create: XOR<AlertCreateWithoutAlertDeliveryInput, AlertUncheckedCreateWithoutAlertDeliveryInput>
    where?: AlertWhereInput
  }

  export type AlertUpdateToOneWithWhereWithoutAlertDeliveryInput = {
    where?: AlertWhereInput
    data: XOR<AlertUpdateWithoutAlertDeliveryInput, AlertUncheckedUpdateWithoutAlertDeliveryInput>
  }

  export type AlertUpdateWithoutAlertDeliveryInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAlertTypeFieldUpdateOperationsInput | $Enums.AlertType
    keyword?: NullableStringFieldUpdateOperationsInput | string | null
    targetCpr?: NullableFloatFieldUpdateOperationsInput | number | null
    excludeSteel?: NullableBoolFieldUpdateOperationsInput | boolean | null
    excludeReman?: NullableBoolFieldUpdateOperationsInput | boolean | null
    lastTriggered?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Caliber?: CaliberUpdateOneWithoutAlertNestedInput
    CatalogItem?: CatalogItemUpdateOneWithoutAlertNestedInput
    User?: UserUpdateOneRequiredWithoutAlertNestedInput
  }

  export type AlertUncheckedUpdateWithoutAlertDeliveryInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumAlertTypeFieldUpdateOperationsInput | $Enums.AlertType
    calId?: NullableIntFieldUpdateOperationsInput | number | null
    itemId?: NullableStringFieldUpdateOperationsInput | string | null
    keyword?: NullableStringFieldUpdateOperationsInput | string | null
    targetCpr?: NullableFloatFieldUpdateOperationsInput | number | null
    excludeSteel?: NullableBoolFieldUpdateOperationsInput | boolean | null
    excludeReman?: NullableBoolFieldUpdateOperationsInput | boolean | null
    lastTriggered?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OfferUpsertWithoutAlertDeliveryInput = {
    update: XOR<OfferUpdateWithoutAlertDeliveryInput, OfferUncheckedUpdateWithoutAlertDeliveryInput>
    create: XOR<OfferCreateWithoutAlertDeliveryInput, OfferUncheckedCreateWithoutAlertDeliveryInput>
    where?: OfferWhereInput
  }

  export type OfferUpdateToOneWithWhereWithoutAlertDeliveryInput = {
    where?: OfferWhereInput
    data: XOR<OfferUpdateWithoutAlertDeliveryInput, OfferUncheckedUpdateWithoutAlertDeliveryInput>
  }

  export type OfferUpdateWithoutAlertDeliveryInput = {
    url?: StringFieldUpdateOperationsInput | string
    inStock?: NullableBoolFieldUpdateOperationsInput | boolean | null
    price?: FloatFieldUpdateOperationsInput | number
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    shippingCost?: NullableFloatFieldUpdateOperationsInput | number | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    freeShipping?: NullableBoolFieldUpdateOperationsInput | boolean | null
    shippingNote?: NullableStringFieldUpdateOperationsInput | string | null
    shippingUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unitsCount?: NullableIntFieldUpdateOperationsInput | number | null
    unitLabel?: NullableStringFieldUpdateOperationsInput | string | null
    unitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    totalUnitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    retailerSku?: NullableStringFieldUpdateOperationsInput | string | null
    isManuallyOOS?: NullableBoolFieldUpdateOperationsInput | boolean | null
    oosReportCount?: NullableIntFieldUpdateOperationsInput | number | null
    lastStockChange?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CatalogItem?: CatalogItemUpdateOneRequiredWithoutOfferNestedInput
    retailer?: RetailerUpdateOneRequiredWithoutOffersNestedInput
  }

  export type OfferUncheckedUpdateWithoutAlertDeliveryInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemId?: StringFieldUpdateOperationsInput | string
    retailerId?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    inStock?: NullableBoolFieldUpdateOperationsInput | boolean | null
    price?: FloatFieldUpdateOperationsInput | number
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    shippingCost?: NullableFloatFieldUpdateOperationsInput | number | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    freeShipping?: NullableBoolFieldUpdateOperationsInput | boolean | null
    shippingNote?: NullableStringFieldUpdateOperationsInput | string | null
    shippingUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unitsCount?: NullableIntFieldUpdateOperationsInput | number | null
    unitLabel?: NullableStringFieldUpdateOperationsInput | string | null
    unitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    totalUnitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    retailerSku?: NullableStringFieldUpdateOperationsInput | string | null
    isManuallyOOS?: NullableBoolFieldUpdateOperationsInput | boolean | null
    oosReportCount?: NullableIntFieldUpdateOperationsInput | number | null
    lastStockChange?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUpsertWithoutAlertDeliveryInput = {
    update: XOR<UserUpdateWithoutAlertDeliveryInput, UserUncheckedUpdateWithoutAlertDeliveryInput>
    create: XOR<UserCreateWithoutAlertDeliveryInput, UserUncheckedCreateWithoutAlertDeliveryInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAlertDeliveryInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAlertDeliveryInput, UserUncheckedUpdateWithoutAlertDeliveryInput>
  }

  export type UserUpdateWithoutAlertDeliveryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Alert?: AlertUpdateManyWithoutUserNestedInput
    BlockedRetailer?: BlockedRetailerUpdateManyWithoutUserNestedInput
    OwnedFirearm?: OwnedFirearmUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAlertDeliveryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Alert?: AlertUncheckedUpdateManyWithoutUserNestedInput
    BlockedRetailer?: BlockedRetailerUncheckedUpdateManyWithoutUserNestedInput
    OwnedFirearm?: OwnedFirearmUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CaliberCreateWithoutAmmoSpecsInput = {
    name: string
    slug: string
    type?: string | null
    Alert?: AlertCreateNestedManyWithoutCaliberInput
    CaliberAlias?: CaliberAliasCreateNestedManyWithoutCaliberInput
    FirearmChamber?: FirearmChamberCreateNestedManyWithoutCaliberInput
  }

  export type CaliberUncheckedCreateWithoutAmmoSpecsInput = {
    id?: number
    name: string
    slug: string
    type?: string | null
    Alert?: AlertUncheckedCreateNestedManyWithoutCaliberInput
    CaliberAlias?: CaliberAliasUncheckedCreateNestedManyWithoutCaliberInput
    FirearmChamber?: FirearmChamberUncheckedCreateNestedManyWithoutCaliberInput
  }

  export type CaliberCreateOrConnectWithoutAmmoSpecsInput = {
    where: CaliberWhereUniqueInput
    create: XOR<CaliberCreateWithoutAmmoSpecsInput, CaliberUncheckedCreateWithoutAmmoSpecsInput>
  }

  export type CatalogItemCreateWithoutAmmoSpecsInput = {
    id: string
    kind: $Enums.CatalogKind
    slug: string
    upc?: string | null
    mpn?: string | null
    title: string
    image?: string | null
    description?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    bestPrice?: number | null
    bestRetailerId?: number | null
    bestRetailerName?: string | null
    offerCount?: number | null
    bestCpr?: number | null
    bestCprShipped?: number | null
    upvotes?: number | null
    downvotes?: number | null
    AccessoryFitment?: AccessoryFitmentCreateNestedManyWithoutCatalogItemInput
    AccessorySpecs?: AccessorySpecsCreateNestedOneWithoutCatalogItemInput
    Alert?: AlertCreateNestedManyWithoutCatalogItemInput
    Brand?: BrandCreateNestedOneWithoutCatalogItemInput
    FirearmSpecs?: FirearmSpecsCreateNestedOneWithoutCatalogItemInput
    Offer?: OfferCreateNestedManyWithoutCatalogItemInput
    OwnedFirearm?: OwnedFirearmCreateNestedManyWithoutCatalogItemInput
  }

  export type CatalogItemUncheckedCreateWithoutAmmoSpecsInput = {
    id: string
    kind: $Enums.CatalogKind
    slug: string
    upc?: string | null
    mpn?: string | null
    title: string
    image?: string | null
    description?: string | null
    brandId?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    bestPrice?: number | null
    bestRetailerId?: number | null
    bestRetailerName?: string | null
    offerCount?: number | null
    bestCpr?: number | null
    bestCprShipped?: number | null
    upvotes?: number | null
    downvotes?: number | null
    AccessoryFitment?: AccessoryFitmentUncheckedCreateNestedManyWithoutCatalogItemInput
    AccessorySpecs?: AccessorySpecsUncheckedCreateNestedOneWithoutCatalogItemInput
    Alert?: AlertUncheckedCreateNestedManyWithoutCatalogItemInput
    FirearmSpecs?: FirearmSpecsUncheckedCreateNestedOneWithoutCatalogItemInput
    Offer?: OfferUncheckedCreateNestedManyWithoutCatalogItemInput
    OwnedFirearm?: OwnedFirearmUncheckedCreateNestedManyWithoutCatalogItemInput
  }

  export type CatalogItemCreateOrConnectWithoutAmmoSpecsInput = {
    where: CatalogItemWhereUniqueInput
    create: XOR<CatalogItemCreateWithoutAmmoSpecsInput, CatalogItemUncheckedCreateWithoutAmmoSpecsInput>
  }

  export type CaliberUpsertWithoutAmmoSpecsInput = {
    update: XOR<CaliberUpdateWithoutAmmoSpecsInput, CaliberUncheckedUpdateWithoutAmmoSpecsInput>
    create: XOR<CaliberCreateWithoutAmmoSpecsInput, CaliberUncheckedCreateWithoutAmmoSpecsInput>
    where?: CaliberWhereInput
  }

  export type CaliberUpdateToOneWithWhereWithoutAmmoSpecsInput = {
    where?: CaliberWhereInput
    data: XOR<CaliberUpdateWithoutAmmoSpecsInput, CaliberUncheckedUpdateWithoutAmmoSpecsInput>
  }

  export type CaliberUpdateWithoutAmmoSpecsInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    Alert?: AlertUpdateManyWithoutCaliberNestedInput
    CaliberAlias?: CaliberAliasUpdateManyWithoutCaliberNestedInput
    FirearmChamber?: FirearmChamberUpdateManyWithoutCaliberNestedInput
  }

  export type CaliberUncheckedUpdateWithoutAmmoSpecsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    Alert?: AlertUncheckedUpdateManyWithoutCaliberNestedInput
    CaliberAlias?: CaliberAliasUncheckedUpdateManyWithoutCaliberNestedInput
    FirearmChamber?: FirearmChamberUncheckedUpdateManyWithoutCaliberNestedInput
  }

  export type CatalogItemUpsertWithoutAmmoSpecsInput = {
    update: XOR<CatalogItemUpdateWithoutAmmoSpecsInput, CatalogItemUncheckedUpdateWithoutAmmoSpecsInput>
    create: XOR<CatalogItemCreateWithoutAmmoSpecsInput, CatalogItemUncheckedCreateWithoutAmmoSpecsInput>
    where?: CatalogItemWhereInput
  }

  export type CatalogItemUpdateToOneWithWhereWithoutAmmoSpecsInput = {
    where?: CatalogItemWhereInput
    data: XOR<CatalogItemUpdateWithoutAmmoSpecsInput, CatalogItemUncheckedUpdateWithoutAmmoSpecsInput>
  }

  export type CatalogItemUpdateWithoutAmmoSpecsInput = {
    id?: StringFieldUpdateOperationsInput | string
    kind?: EnumCatalogKindFieldUpdateOperationsInput | $Enums.CatalogKind
    slug?: StringFieldUpdateOperationsInput | string
    upc?: NullableStringFieldUpdateOperationsInput | string | null
    mpn?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bestPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    bestRetailerId?: NullableIntFieldUpdateOperationsInput | number | null
    bestRetailerName?: NullableStringFieldUpdateOperationsInput | string | null
    offerCount?: NullableIntFieldUpdateOperationsInput | number | null
    bestCpr?: NullableFloatFieldUpdateOperationsInput | number | null
    bestCprShipped?: NullableFloatFieldUpdateOperationsInput | number | null
    upvotes?: NullableIntFieldUpdateOperationsInput | number | null
    downvotes?: NullableIntFieldUpdateOperationsInput | number | null
    AccessoryFitment?: AccessoryFitmentUpdateManyWithoutCatalogItemNestedInput
    AccessorySpecs?: AccessorySpecsUpdateOneWithoutCatalogItemNestedInput
    Alert?: AlertUpdateManyWithoutCatalogItemNestedInput
    Brand?: BrandUpdateOneWithoutCatalogItemNestedInput
    FirearmSpecs?: FirearmSpecsUpdateOneWithoutCatalogItemNestedInput
    Offer?: OfferUpdateManyWithoutCatalogItemNestedInput
    OwnedFirearm?: OwnedFirearmUpdateManyWithoutCatalogItemNestedInput
  }

  export type CatalogItemUncheckedUpdateWithoutAmmoSpecsInput = {
    id?: StringFieldUpdateOperationsInput | string
    kind?: EnumCatalogKindFieldUpdateOperationsInput | $Enums.CatalogKind
    slug?: StringFieldUpdateOperationsInput | string
    upc?: NullableStringFieldUpdateOperationsInput | string | null
    mpn?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    brandId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bestPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    bestRetailerId?: NullableIntFieldUpdateOperationsInput | number | null
    bestRetailerName?: NullableStringFieldUpdateOperationsInput | string | null
    offerCount?: NullableIntFieldUpdateOperationsInput | number | null
    bestCpr?: NullableFloatFieldUpdateOperationsInput | number | null
    bestCprShipped?: NullableFloatFieldUpdateOperationsInput | number | null
    upvotes?: NullableIntFieldUpdateOperationsInput | number | null
    downvotes?: NullableIntFieldUpdateOperationsInput | number | null
    AccessoryFitment?: AccessoryFitmentUncheckedUpdateManyWithoutCatalogItemNestedInput
    AccessorySpecs?: AccessorySpecsUncheckedUpdateOneWithoutCatalogItemNestedInput
    Alert?: AlertUncheckedUpdateManyWithoutCatalogItemNestedInput
    FirearmSpecs?: FirearmSpecsUncheckedUpdateOneWithoutCatalogItemNestedInput
    Offer?: OfferUncheckedUpdateManyWithoutCatalogItemNestedInput
    OwnedFirearm?: OwnedFirearmUncheckedUpdateManyWithoutCatalogItemNestedInput
  }

  export type RetailerCreateWithoutBlockedRetailerInput = {
    name: string
    domain?: string | null
    logo?: string | null
    rating?: number | null
    shippingRating?: number | null
    offers?: OfferCreateNestedManyWithoutRetailerInput
  }

  export type RetailerUncheckedCreateWithoutBlockedRetailerInput = {
    id?: number
    name: string
    domain?: string | null
    logo?: string | null
    rating?: number | null
    shippingRating?: number | null
    offers?: OfferUncheckedCreateNestedManyWithoutRetailerInput
  }

  export type RetailerCreateOrConnectWithoutBlockedRetailerInput = {
    where: RetailerWhereUniqueInput
    create: XOR<RetailerCreateWithoutBlockedRetailerInput, RetailerUncheckedCreateWithoutBlockedRetailerInput>
  }

  export type UserCreateWithoutBlockedRetailerInput = {
    id: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    Alert?: AlertCreateNestedManyWithoutUserInput
    AlertDelivery?: AlertDeliveryCreateNestedManyWithoutUserInput
    OwnedFirearm?: OwnedFirearmCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBlockedRetailerInput = {
    id: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    Alert?: AlertUncheckedCreateNestedManyWithoutUserInput
    AlertDelivery?: AlertDeliveryUncheckedCreateNestedManyWithoutUserInput
    OwnedFirearm?: OwnedFirearmUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBlockedRetailerInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBlockedRetailerInput, UserUncheckedCreateWithoutBlockedRetailerInput>
  }

  export type RetailerUpsertWithoutBlockedRetailerInput = {
    update: XOR<RetailerUpdateWithoutBlockedRetailerInput, RetailerUncheckedUpdateWithoutBlockedRetailerInput>
    create: XOR<RetailerCreateWithoutBlockedRetailerInput, RetailerUncheckedCreateWithoutBlockedRetailerInput>
    where?: RetailerWhereInput
  }

  export type RetailerUpdateToOneWithWhereWithoutBlockedRetailerInput = {
    where?: RetailerWhereInput
    data: XOR<RetailerUpdateWithoutBlockedRetailerInput, RetailerUncheckedUpdateWithoutBlockedRetailerInput>
  }

  export type RetailerUpdateWithoutBlockedRetailerInput = {
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    shippingRating?: NullableIntFieldUpdateOperationsInput | number | null
    offers?: OfferUpdateManyWithoutRetailerNestedInput
  }

  export type RetailerUncheckedUpdateWithoutBlockedRetailerInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    shippingRating?: NullableIntFieldUpdateOperationsInput | number | null
    offers?: OfferUncheckedUpdateManyWithoutRetailerNestedInput
  }

  export type UserUpsertWithoutBlockedRetailerInput = {
    update: XOR<UserUpdateWithoutBlockedRetailerInput, UserUncheckedUpdateWithoutBlockedRetailerInput>
    create: XOR<UserCreateWithoutBlockedRetailerInput, UserUncheckedCreateWithoutBlockedRetailerInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBlockedRetailerInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBlockedRetailerInput, UserUncheckedUpdateWithoutBlockedRetailerInput>
  }

  export type UserUpdateWithoutBlockedRetailerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Alert?: AlertUpdateManyWithoutUserNestedInput
    AlertDelivery?: AlertDeliveryUpdateManyWithoutUserNestedInput
    OwnedFirearm?: OwnedFirearmUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBlockedRetailerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Alert?: AlertUncheckedUpdateManyWithoutUserNestedInput
    AlertDelivery?: AlertDeliveryUncheckedUpdateManyWithoutUserNestedInput
    OwnedFirearm?: OwnedFirearmUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CaliberCreateWithoutCaliberAliasInput = {
    name: string
    slug: string
    type?: string | null
    Alert?: AlertCreateNestedManyWithoutCaliberInput
    AmmoSpecs?: AmmoSpecsCreateNestedManyWithoutCaliberInput
    FirearmChamber?: FirearmChamberCreateNestedManyWithoutCaliberInput
  }

  export type CaliberUncheckedCreateWithoutCaliberAliasInput = {
    id?: number
    name: string
    slug: string
    type?: string | null
    Alert?: AlertUncheckedCreateNestedManyWithoutCaliberInput
    AmmoSpecs?: AmmoSpecsUncheckedCreateNestedManyWithoutCaliberInput
    FirearmChamber?: FirearmChamberUncheckedCreateNestedManyWithoutCaliberInput
  }

  export type CaliberCreateOrConnectWithoutCaliberAliasInput = {
    where: CaliberWhereUniqueInput
    create: XOR<CaliberCreateWithoutCaliberAliasInput, CaliberUncheckedCreateWithoutCaliberAliasInput>
  }

  export type CaliberUpsertWithoutCaliberAliasInput = {
    update: XOR<CaliberUpdateWithoutCaliberAliasInput, CaliberUncheckedUpdateWithoutCaliberAliasInput>
    create: XOR<CaliberCreateWithoutCaliberAliasInput, CaliberUncheckedCreateWithoutCaliberAliasInput>
    where?: CaliberWhereInput
  }

  export type CaliberUpdateToOneWithWhereWithoutCaliberAliasInput = {
    where?: CaliberWhereInput
    data: XOR<CaliberUpdateWithoutCaliberAliasInput, CaliberUncheckedUpdateWithoutCaliberAliasInput>
  }

  export type CaliberUpdateWithoutCaliberAliasInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    Alert?: AlertUpdateManyWithoutCaliberNestedInput
    AmmoSpecs?: AmmoSpecsUpdateManyWithoutCaliberNestedInput
    FirearmChamber?: FirearmChamberUpdateManyWithoutCaliberNestedInput
  }

  export type CaliberUncheckedUpdateWithoutCaliberAliasInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    Alert?: AlertUncheckedUpdateManyWithoutCaliberNestedInput
    AmmoSpecs?: AmmoSpecsUncheckedUpdateManyWithoutCaliberNestedInput
    FirearmChamber?: FirearmChamberUncheckedUpdateManyWithoutCaliberNestedInput
  }

  export type AccessoryFitmentCreateWithoutCatalogItemInput = {
    fitmentType: $Enums.FitmentType
    platform?: string | null
    note?: string | null
    AccessorySpecs: AccessorySpecsCreateNestedOneWithoutAccessoryFitmentInput
  }

  export type AccessoryFitmentUncheckedCreateWithoutCatalogItemInput = {
    id?: number
    accessorySpecsId: number
    fitmentType: $Enums.FitmentType
    platform?: string | null
    note?: string | null
  }

  export type AccessoryFitmentCreateOrConnectWithoutCatalogItemInput = {
    where: AccessoryFitmentWhereUniqueInput
    create: XOR<AccessoryFitmentCreateWithoutCatalogItemInput, AccessoryFitmentUncheckedCreateWithoutCatalogItemInput>
  }

  export type AccessoryFitmentCreateManyCatalogItemInputEnvelope = {
    data: AccessoryFitmentCreateManyCatalogItemInput | AccessoryFitmentCreateManyCatalogItemInput[]
    skipDuplicates?: boolean
  }

  export type AccessorySpecsCreateWithoutCatalogItemInput = {
    material?: string | null
    color?: string | null
    notes?: string | null
    AccessoryFitment?: AccessoryFitmentCreateNestedManyWithoutAccessorySpecsInput
    AccessoryType?: AccessoryTypeCreateNestedOneWithoutAccessorySpecsInput
  }

  export type AccessorySpecsUncheckedCreateWithoutCatalogItemInput = {
    id?: number
    accessoryTypeId?: number | null
    material?: string | null
    color?: string | null
    notes?: string | null
    AccessoryFitment?: AccessoryFitmentUncheckedCreateNestedManyWithoutAccessorySpecsInput
  }

  export type AccessorySpecsCreateOrConnectWithoutCatalogItemInput = {
    where: AccessorySpecsWhereUniqueInput
    create: XOR<AccessorySpecsCreateWithoutCatalogItemInput, AccessorySpecsUncheckedCreateWithoutCatalogItemInput>
  }

  export type AlertCreateWithoutCatalogItemInput = {
    id: string
    type: $Enums.AlertType
    keyword?: string | null
    targetCpr?: number | null
    excludeSteel?: boolean | null
    excludeReman?: boolean | null
    lastTriggered?: Date | string | null
    isActive?: boolean | null
    createdAt?: Date | string | null
    Caliber?: CaliberCreateNestedOneWithoutAlertInput
    User: UserCreateNestedOneWithoutAlertInput
    AlertDelivery?: AlertDeliveryCreateNestedManyWithoutAlertInput
  }

  export type AlertUncheckedCreateWithoutCatalogItemInput = {
    id: string
    userId: string
    type: $Enums.AlertType
    calId?: number | null
    keyword?: string | null
    targetCpr?: number | null
    excludeSteel?: boolean | null
    excludeReman?: boolean | null
    lastTriggered?: Date | string | null
    isActive?: boolean | null
    createdAt?: Date | string | null
    AlertDelivery?: AlertDeliveryUncheckedCreateNestedManyWithoutAlertInput
  }

  export type AlertCreateOrConnectWithoutCatalogItemInput = {
    where: AlertWhereUniqueInput
    create: XOR<AlertCreateWithoutCatalogItemInput, AlertUncheckedCreateWithoutCatalogItemInput>
  }

  export type AlertCreateManyCatalogItemInputEnvelope = {
    data: AlertCreateManyCatalogItemInput | AlertCreateManyCatalogItemInput[]
    skipDuplicates?: boolean
  }

  export type AmmoSpecsCreateWithoutCatalogItemInput = {
    grain?: number | null
    gauge?: string | null
    velocity?: number | null
    energy?: number | null
    casing?: string | null
    bulletType?: string | null
    restrictions?: AmmoSpecsCreaterestrictionsInput | string[]
    pressure?: $Enums.AmmoPressure | null
    isSteelCase?: boolean | null
    isRemanufactured?: boolean | null
    isSubsonic?: boolean | null
    Caliber: CaliberCreateNestedOneWithoutAmmoSpecsInput
  }

  export type AmmoSpecsUncheckedCreateWithoutCatalogItemInput = {
    id?: number
    caliberId: number
    grain?: number | null
    gauge?: string | null
    velocity?: number | null
    energy?: number | null
    casing?: string | null
    bulletType?: string | null
    restrictions?: AmmoSpecsCreaterestrictionsInput | string[]
    pressure?: $Enums.AmmoPressure | null
    isSteelCase?: boolean | null
    isRemanufactured?: boolean | null
    isSubsonic?: boolean | null
  }

  export type AmmoSpecsCreateOrConnectWithoutCatalogItemInput = {
    where: AmmoSpecsWhereUniqueInput
    create: XOR<AmmoSpecsCreateWithoutCatalogItemInput, AmmoSpecsUncheckedCreateWithoutCatalogItemInput>
  }

  export type BrandCreateWithoutCatalogItemInput = {
    name: string
    slug: string
    website?: string | null
    logo?: string | null
    description?: string | null
  }

  export type BrandUncheckedCreateWithoutCatalogItemInput = {
    id?: number
    name: string
    slug: string
    website?: string | null
    logo?: string | null
    description?: string | null
  }

  export type BrandCreateOrConnectWithoutCatalogItemInput = {
    where: BrandWhereUniqueInput
    create: XOR<BrandCreateWithoutCatalogItemInput, BrandUncheckedCreateWithoutCatalogItemInput>
  }

  export type FirearmSpecsCreateWithoutCatalogItemInput = {
    manufacturer?: string | null
    model?: string | null
    platform?: string | null
    barrelLengthIn?: number | null
    actionType?: string | null
    isThreaded?: boolean | null
    pressureRating?: $Enums.FirearmPressureRating | null
    firearmType?: string | null
    capacity?: string | null
    finish?: string | null
    weight?: string | null
    overallLength?: string | null
    features?: string | null
    sight?: string | null
    safety?: string | null
    FirearmChamber?: FirearmChamberCreateNestedManyWithoutFirearmSpecsInput
    FirearmCategory?: FirearmCategoryCreateNestedOneWithoutFirearmSpecsInput
  }

  export type FirearmSpecsUncheckedCreateWithoutCatalogItemInput = {
    id?: number
    manufacturer?: string | null
    model?: string | null
    platform?: string | null
    firearmCategoryId?: number | null
    barrelLengthIn?: number | null
    actionType?: string | null
    isThreaded?: boolean | null
    pressureRating?: $Enums.FirearmPressureRating | null
    firearmType?: string | null
    capacity?: string | null
    finish?: string | null
    weight?: string | null
    overallLength?: string | null
    features?: string | null
    sight?: string | null
    safety?: string | null
    FirearmChamber?: FirearmChamberUncheckedCreateNestedManyWithoutFirearmSpecsInput
  }

  export type FirearmSpecsCreateOrConnectWithoutCatalogItemInput = {
    where: FirearmSpecsWhereUniqueInput
    create: XOR<FirearmSpecsCreateWithoutCatalogItemInput, FirearmSpecsUncheckedCreateWithoutCatalogItemInput>
  }

  export type OfferCreateWithoutCatalogItemInput = {
    url: string
    inStock?: boolean | null
    price: number
    currency?: string | null
    shippingCost?: number | null
    total?: number | null
    freeShipping?: boolean | null
    shippingNote?: string | null
    shippingUpdatedAt?: Date | string | null
    unitsCount?: number | null
    unitLabel?: string | null
    unitPrice?: number | null
    totalUnitPrice?: number | null
    retailerSku?: string | null
    isManuallyOOS?: boolean | null
    oosReportCount?: number | null
    lastStockChange?: Date | string | null
    lastSeen?: Date | string | null
    AlertDelivery?: AlertDeliveryCreateNestedManyWithoutOfferInput
    retailer: RetailerCreateNestedOneWithoutOffersInput
  }

  export type OfferUncheckedCreateWithoutCatalogItemInput = {
    id?: number
    retailerId: number
    url: string
    inStock?: boolean | null
    price: number
    currency?: string | null
    shippingCost?: number | null
    total?: number | null
    freeShipping?: boolean | null
    shippingNote?: string | null
    shippingUpdatedAt?: Date | string | null
    unitsCount?: number | null
    unitLabel?: string | null
    unitPrice?: number | null
    totalUnitPrice?: number | null
    retailerSku?: string | null
    isManuallyOOS?: boolean | null
    oosReportCount?: number | null
    lastStockChange?: Date | string | null
    lastSeen?: Date | string | null
    AlertDelivery?: AlertDeliveryUncheckedCreateNestedManyWithoutOfferInput
  }

  export type OfferCreateOrConnectWithoutCatalogItemInput = {
    where: OfferWhereUniqueInput
    create: XOR<OfferCreateWithoutCatalogItemInput, OfferUncheckedCreateWithoutCatalogItemInput>
  }

  export type OfferCreateManyCatalogItemInputEnvelope = {
    data: OfferCreateManyCatalogItemInput | OfferCreateManyCatalogItemInput[]
    skipDuplicates?: boolean
  }

  export type OwnedFirearmCreateWithoutCatalogItemInput = {
    id: string
    nickname?: string | null
    createdAt?: Date | string | null
    User: UserCreateNestedOneWithoutOwnedFirearmInput
  }

  export type OwnedFirearmUncheckedCreateWithoutCatalogItemInput = {
    id: string
    userId: string
    nickname?: string | null
    createdAt?: Date | string | null
  }

  export type OwnedFirearmCreateOrConnectWithoutCatalogItemInput = {
    where: OwnedFirearmWhereUniqueInput
    create: XOR<OwnedFirearmCreateWithoutCatalogItemInput, OwnedFirearmUncheckedCreateWithoutCatalogItemInput>
  }

  export type OwnedFirearmCreateManyCatalogItemInputEnvelope = {
    data: OwnedFirearmCreateManyCatalogItemInput | OwnedFirearmCreateManyCatalogItemInput[]
    skipDuplicates?: boolean
  }

  export type AccessoryFitmentUpsertWithWhereUniqueWithoutCatalogItemInput = {
    where: AccessoryFitmentWhereUniqueInput
    update: XOR<AccessoryFitmentUpdateWithoutCatalogItemInput, AccessoryFitmentUncheckedUpdateWithoutCatalogItemInput>
    create: XOR<AccessoryFitmentCreateWithoutCatalogItemInput, AccessoryFitmentUncheckedCreateWithoutCatalogItemInput>
  }

  export type AccessoryFitmentUpdateWithWhereUniqueWithoutCatalogItemInput = {
    where: AccessoryFitmentWhereUniqueInput
    data: XOR<AccessoryFitmentUpdateWithoutCatalogItemInput, AccessoryFitmentUncheckedUpdateWithoutCatalogItemInput>
  }

  export type AccessoryFitmentUpdateManyWithWhereWithoutCatalogItemInput = {
    where: AccessoryFitmentScalarWhereInput
    data: XOR<AccessoryFitmentUpdateManyMutationInput, AccessoryFitmentUncheckedUpdateManyWithoutCatalogItemInput>
  }

  export type AccessorySpecsUpsertWithoutCatalogItemInput = {
    update: XOR<AccessorySpecsUpdateWithoutCatalogItemInput, AccessorySpecsUncheckedUpdateWithoutCatalogItemInput>
    create: XOR<AccessorySpecsCreateWithoutCatalogItemInput, AccessorySpecsUncheckedCreateWithoutCatalogItemInput>
    where?: AccessorySpecsWhereInput
  }

  export type AccessorySpecsUpdateToOneWithWhereWithoutCatalogItemInput = {
    where?: AccessorySpecsWhereInput
    data: XOR<AccessorySpecsUpdateWithoutCatalogItemInput, AccessorySpecsUncheckedUpdateWithoutCatalogItemInput>
  }

  export type AccessorySpecsUpdateWithoutCatalogItemInput = {
    material?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    AccessoryFitment?: AccessoryFitmentUpdateManyWithoutAccessorySpecsNestedInput
    AccessoryType?: AccessoryTypeUpdateOneWithoutAccessorySpecsNestedInput
  }

  export type AccessorySpecsUncheckedUpdateWithoutCatalogItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    accessoryTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    AccessoryFitment?: AccessoryFitmentUncheckedUpdateManyWithoutAccessorySpecsNestedInput
  }

  export type AlertUpsertWithWhereUniqueWithoutCatalogItemInput = {
    where: AlertWhereUniqueInput
    update: XOR<AlertUpdateWithoutCatalogItemInput, AlertUncheckedUpdateWithoutCatalogItemInput>
    create: XOR<AlertCreateWithoutCatalogItemInput, AlertUncheckedCreateWithoutCatalogItemInput>
  }

  export type AlertUpdateWithWhereUniqueWithoutCatalogItemInput = {
    where: AlertWhereUniqueInput
    data: XOR<AlertUpdateWithoutCatalogItemInput, AlertUncheckedUpdateWithoutCatalogItemInput>
  }

  export type AlertUpdateManyWithWhereWithoutCatalogItemInput = {
    where: AlertScalarWhereInput
    data: XOR<AlertUpdateManyMutationInput, AlertUncheckedUpdateManyWithoutCatalogItemInput>
  }

  export type AmmoSpecsUpsertWithoutCatalogItemInput = {
    update: XOR<AmmoSpecsUpdateWithoutCatalogItemInput, AmmoSpecsUncheckedUpdateWithoutCatalogItemInput>
    create: XOR<AmmoSpecsCreateWithoutCatalogItemInput, AmmoSpecsUncheckedCreateWithoutCatalogItemInput>
    where?: AmmoSpecsWhereInput
  }

  export type AmmoSpecsUpdateToOneWithWhereWithoutCatalogItemInput = {
    where?: AmmoSpecsWhereInput
    data: XOR<AmmoSpecsUpdateWithoutCatalogItemInput, AmmoSpecsUncheckedUpdateWithoutCatalogItemInput>
  }

  export type AmmoSpecsUpdateWithoutCatalogItemInput = {
    grain?: NullableIntFieldUpdateOperationsInput | number | null
    gauge?: NullableStringFieldUpdateOperationsInput | string | null
    velocity?: NullableIntFieldUpdateOperationsInput | number | null
    energy?: NullableIntFieldUpdateOperationsInput | number | null
    casing?: NullableStringFieldUpdateOperationsInput | string | null
    bulletType?: NullableStringFieldUpdateOperationsInput | string | null
    restrictions?: AmmoSpecsUpdaterestrictionsInput | string[]
    pressure?: NullableEnumAmmoPressureFieldUpdateOperationsInput | $Enums.AmmoPressure | null
    isSteelCase?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isRemanufactured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isSubsonic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Caliber?: CaliberUpdateOneRequiredWithoutAmmoSpecsNestedInput
  }

  export type AmmoSpecsUncheckedUpdateWithoutCatalogItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    caliberId?: IntFieldUpdateOperationsInput | number
    grain?: NullableIntFieldUpdateOperationsInput | number | null
    gauge?: NullableStringFieldUpdateOperationsInput | string | null
    velocity?: NullableIntFieldUpdateOperationsInput | number | null
    energy?: NullableIntFieldUpdateOperationsInput | number | null
    casing?: NullableStringFieldUpdateOperationsInput | string | null
    bulletType?: NullableStringFieldUpdateOperationsInput | string | null
    restrictions?: AmmoSpecsUpdaterestrictionsInput | string[]
    pressure?: NullableEnumAmmoPressureFieldUpdateOperationsInput | $Enums.AmmoPressure | null
    isSteelCase?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isRemanufactured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isSubsonic?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type BrandUpsertWithoutCatalogItemInput = {
    update: XOR<BrandUpdateWithoutCatalogItemInput, BrandUncheckedUpdateWithoutCatalogItemInput>
    create: XOR<BrandCreateWithoutCatalogItemInput, BrandUncheckedCreateWithoutCatalogItemInput>
    where?: BrandWhereInput
  }

  export type BrandUpdateToOneWithWhereWithoutCatalogItemInput = {
    where?: BrandWhereInput
    data: XOR<BrandUpdateWithoutCatalogItemInput, BrandUncheckedUpdateWithoutCatalogItemInput>
  }

  export type BrandUpdateWithoutCatalogItemInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BrandUncheckedUpdateWithoutCatalogItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FirearmSpecsUpsertWithoutCatalogItemInput = {
    update: XOR<FirearmSpecsUpdateWithoutCatalogItemInput, FirearmSpecsUncheckedUpdateWithoutCatalogItemInput>
    create: XOR<FirearmSpecsCreateWithoutCatalogItemInput, FirearmSpecsUncheckedCreateWithoutCatalogItemInput>
    where?: FirearmSpecsWhereInput
  }

  export type FirearmSpecsUpdateToOneWithWhereWithoutCatalogItemInput = {
    where?: FirearmSpecsWhereInput
    data: XOR<FirearmSpecsUpdateWithoutCatalogItemInput, FirearmSpecsUncheckedUpdateWithoutCatalogItemInput>
  }

  export type FirearmSpecsUpdateWithoutCatalogItemInput = {
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    barrelLengthIn?: NullableFloatFieldUpdateOperationsInput | number | null
    actionType?: NullableStringFieldUpdateOperationsInput | string | null
    isThreaded?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pressureRating?: NullableEnumFirearmPressureRatingFieldUpdateOperationsInput | $Enums.FirearmPressureRating | null
    firearmType?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableStringFieldUpdateOperationsInput | string | null
    finish?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableStringFieldUpdateOperationsInput | string | null
    overallLength?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableStringFieldUpdateOperationsInput | string | null
    sight?: NullableStringFieldUpdateOperationsInput | string | null
    safety?: NullableStringFieldUpdateOperationsInput | string | null
    FirearmChamber?: FirearmChamberUpdateManyWithoutFirearmSpecsNestedInput
    FirearmCategory?: FirearmCategoryUpdateOneWithoutFirearmSpecsNestedInput
  }

  export type FirearmSpecsUncheckedUpdateWithoutCatalogItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    firearmCategoryId?: NullableIntFieldUpdateOperationsInput | number | null
    barrelLengthIn?: NullableFloatFieldUpdateOperationsInput | number | null
    actionType?: NullableStringFieldUpdateOperationsInput | string | null
    isThreaded?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pressureRating?: NullableEnumFirearmPressureRatingFieldUpdateOperationsInput | $Enums.FirearmPressureRating | null
    firearmType?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableStringFieldUpdateOperationsInput | string | null
    finish?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableStringFieldUpdateOperationsInput | string | null
    overallLength?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableStringFieldUpdateOperationsInput | string | null
    sight?: NullableStringFieldUpdateOperationsInput | string | null
    safety?: NullableStringFieldUpdateOperationsInput | string | null
    FirearmChamber?: FirearmChamberUncheckedUpdateManyWithoutFirearmSpecsNestedInput
  }

  export type OfferUpsertWithWhereUniqueWithoutCatalogItemInput = {
    where: OfferWhereUniqueInput
    update: XOR<OfferUpdateWithoutCatalogItemInput, OfferUncheckedUpdateWithoutCatalogItemInput>
    create: XOR<OfferCreateWithoutCatalogItemInput, OfferUncheckedCreateWithoutCatalogItemInput>
  }

  export type OfferUpdateWithWhereUniqueWithoutCatalogItemInput = {
    where: OfferWhereUniqueInput
    data: XOR<OfferUpdateWithoutCatalogItemInput, OfferUncheckedUpdateWithoutCatalogItemInput>
  }

  export type OfferUpdateManyWithWhereWithoutCatalogItemInput = {
    where: OfferScalarWhereInput
    data: XOR<OfferUpdateManyMutationInput, OfferUncheckedUpdateManyWithoutCatalogItemInput>
  }

  export type OwnedFirearmUpsertWithWhereUniqueWithoutCatalogItemInput = {
    where: OwnedFirearmWhereUniqueInput
    update: XOR<OwnedFirearmUpdateWithoutCatalogItemInput, OwnedFirearmUncheckedUpdateWithoutCatalogItemInput>
    create: XOR<OwnedFirearmCreateWithoutCatalogItemInput, OwnedFirearmUncheckedCreateWithoutCatalogItemInput>
  }

  export type OwnedFirearmUpdateWithWhereUniqueWithoutCatalogItemInput = {
    where: OwnedFirearmWhereUniqueInput
    data: XOR<OwnedFirearmUpdateWithoutCatalogItemInput, OwnedFirearmUncheckedUpdateWithoutCatalogItemInput>
  }

  export type OwnedFirearmUpdateManyWithWhereWithoutCatalogItemInput = {
    where: OwnedFirearmScalarWhereInput
    data: XOR<OwnedFirearmUpdateManyMutationInput, OwnedFirearmUncheckedUpdateManyWithoutCatalogItemInput>
  }

  export type OwnedFirearmScalarWhereInput = {
    AND?: OwnedFirearmScalarWhereInput | OwnedFirearmScalarWhereInput[]
    OR?: OwnedFirearmScalarWhereInput[]
    NOT?: OwnedFirearmScalarWhereInput | OwnedFirearmScalarWhereInput[]
    id?: StringFilter<"OwnedFirearm"> | string
    userId?: StringFilter<"OwnedFirearm"> | string
    firearmItemId?: StringFilter<"OwnedFirearm"> | string
    nickname?: StringNullableFilter<"OwnedFirearm"> | string | null
    createdAt?: DateTimeNullableFilter<"OwnedFirearm"> | Date | string | null
  }

  export type FirearmSpecsCreateWithoutFirearmCategoryInput = {
    manufacturer?: string | null
    model?: string | null
    platform?: string | null
    barrelLengthIn?: number | null
    actionType?: string | null
    isThreaded?: boolean | null
    pressureRating?: $Enums.FirearmPressureRating | null
    firearmType?: string | null
    capacity?: string | null
    finish?: string | null
    weight?: string | null
    overallLength?: string | null
    features?: string | null
    sight?: string | null
    safety?: string | null
    FirearmChamber?: FirearmChamberCreateNestedManyWithoutFirearmSpecsInput
    CatalogItem: CatalogItemCreateNestedOneWithoutFirearmSpecsInput
  }

  export type FirearmSpecsUncheckedCreateWithoutFirearmCategoryInput = {
    id?: number
    itemId: string
    manufacturer?: string | null
    model?: string | null
    platform?: string | null
    barrelLengthIn?: number | null
    actionType?: string | null
    isThreaded?: boolean | null
    pressureRating?: $Enums.FirearmPressureRating | null
    firearmType?: string | null
    capacity?: string | null
    finish?: string | null
    weight?: string | null
    overallLength?: string | null
    features?: string | null
    sight?: string | null
    safety?: string | null
    FirearmChamber?: FirearmChamberUncheckedCreateNestedManyWithoutFirearmSpecsInput
  }

  export type FirearmSpecsCreateOrConnectWithoutFirearmCategoryInput = {
    where: FirearmSpecsWhereUniqueInput
    create: XOR<FirearmSpecsCreateWithoutFirearmCategoryInput, FirearmSpecsUncheckedCreateWithoutFirearmCategoryInput>
  }

  export type FirearmSpecsCreateManyFirearmCategoryInputEnvelope = {
    data: FirearmSpecsCreateManyFirearmCategoryInput | FirearmSpecsCreateManyFirearmCategoryInput[]
    skipDuplicates?: boolean
  }

  export type FirearmSpecsUpsertWithWhereUniqueWithoutFirearmCategoryInput = {
    where: FirearmSpecsWhereUniqueInput
    update: XOR<FirearmSpecsUpdateWithoutFirearmCategoryInput, FirearmSpecsUncheckedUpdateWithoutFirearmCategoryInput>
    create: XOR<FirearmSpecsCreateWithoutFirearmCategoryInput, FirearmSpecsUncheckedCreateWithoutFirearmCategoryInput>
  }

  export type FirearmSpecsUpdateWithWhereUniqueWithoutFirearmCategoryInput = {
    where: FirearmSpecsWhereUniqueInput
    data: XOR<FirearmSpecsUpdateWithoutFirearmCategoryInput, FirearmSpecsUncheckedUpdateWithoutFirearmCategoryInput>
  }

  export type FirearmSpecsUpdateManyWithWhereWithoutFirearmCategoryInput = {
    where: FirearmSpecsScalarWhereInput
    data: XOR<FirearmSpecsUpdateManyMutationInput, FirearmSpecsUncheckedUpdateManyWithoutFirearmCategoryInput>
  }

  export type FirearmSpecsScalarWhereInput = {
    AND?: FirearmSpecsScalarWhereInput | FirearmSpecsScalarWhereInput[]
    OR?: FirearmSpecsScalarWhereInput[]
    NOT?: FirearmSpecsScalarWhereInput | FirearmSpecsScalarWhereInput[]
    id?: IntFilter<"FirearmSpecs"> | number
    itemId?: StringFilter<"FirearmSpecs"> | string
    manufacturer?: StringNullableFilter<"FirearmSpecs"> | string | null
    model?: StringNullableFilter<"FirearmSpecs"> | string | null
    platform?: StringNullableFilter<"FirearmSpecs"> | string | null
    firearmCategoryId?: IntNullableFilter<"FirearmSpecs"> | number | null
    barrelLengthIn?: FloatNullableFilter<"FirearmSpecs"> | number | null
    actionType?: StringNullableFilter<"FirearmSpecs"> | string | null
    isThreaded?: BoolNullableFilter<"FirearmSpecs"> | boolean | null
    pressureRating?: EnumFirearmPressureRatingNullableFilter<"FirearmSpecs"> | $Enums.FirearmPressureRating | null
    firearmType?: StringNullableFilter<"FirearmSpecs"> | string | null
    capacity?: StringNullableFilter<"FirearmSpecs"> | string | null
    finish?: StringNullableFilter<"FirearmSpecs"> | string | null
    weight?: StringNullableFilter<"FirearmSpecs"> | string | null
    overallLength?: StringNullableFilter<"FirearmSpecs"> | string | null
    features?: StringNullableFilter<"FirearmSpecs"> | string | null
    sight?: StringNullableFilter<"FirearmSpecs"> | string | null
    safety?: StringNullableFilter<"FirearmSpecs"> | string | null
  }

  export type CaliberCreateWithoutFirearmChamberInput = {
    name: string
    slug: string
    type?: string | null
    Alert?: AlertCreateNestedManyWithoutCaliberInput
    AmmoSpecs?: AmmoSpecsCreateNestedManyWithoutCaliberInput
    CaliberAlias?: CaliberAliasCreateNestedManyWithoutCaliberInput
  }

  export type CaliberUncheckedCreateWithoutFirearmChamberInput = {
    id?: number
    name: string
    slug: string
    type?: string | null
    Alert?: AlertUncheckedCreateNestedManyWithoutCaliberInput
    AmmoSpecs?: AmmoSpecsUncheckedCreateNestedManyWithoutCaliberInput
    CaliberAlias?: CaliberAliasUncheckedCreateNestedManyWithoutCaliberInput
  }

  export type CaliberCreateOrConnectWithoutFirearmChamberInput = {
    where: CaliberWhereUniqueInput
    create: XOR<CaliberCreateWithoutFirearmChamberInput, CaliberUncheckedCreateWithoutFirearmChamberInput>
  }

  export type FirearmSpecsCreateWithoutFirearmChamberInput = {
    manufacturer?: string | null
    model?: string | null
    platform?: string | null
    barrelLengthIn?: number | null
    actionType?: string | null
    isThreaded?: boolean | null
    pressureRating?: $Enums.FirearmPressureRating | null
    firearmType?: string | null
    capacity?: string | null
    finish?: string | null
    weight?: string | null
    overallLength?: string | null
    features?: string | null
    sight?: string | null
    safety?: string | null
    FirearmCategory?: FirearmCategoryCreateNestedOneWithoutFirearmSpecsInput
    CatalogItem: CatalogItemCreateNestedOneWithoutFirearmSpecsInput
  }

  export type FirearmSpecsUncheckedCreateWithoutFirearmChamberInput = {
    id?: number
    itemId: string
    manufacturer?: string | null
    model?: string | null
    platform?: string | null
    firearmCategoryId?: number | null
    barrelLengthIn?: number | null
    actionType?: string | null
    isThreaded?: boolean | null
    pressureRating?: $Enums.FirearmPressureRating | null
    firearmType?: string | null
    capacity?: string | null
    finish?: string | null
    weight?: string | null
    overallLength?: string | null
    features?: string | null
    sight?: string | null
    safety?: string | null
  }

  export type FirearmSpecsCreateOrConnectWithoutFirearmChamberInput = {
    where: FirearmSpecsWhereUniqueInput
    create: XOR<FirearmSpecsCreateWithoutFirearmChamberInput, FirearmSpecsUncheckedCreateWithoutFirearmChamberInput>
  }

  export type CaliberUpsertWithoutFirearmChamberInput = {
    update: XOR<CaliberUpdateWithoutFirearmChamberInput, CaliberUncheckedUpdateWithoutFirearmChamberInput>
    create: XOR<CaliberCreateWithoutFirearmChamberInput, CaliberUncheckedCreateWithoutFirearmChamberInput>
    where?: CaliberWhereInput
  }

  export type CaliberUpdateToOneWithWhereWithoutFirearmChamberInput = {
    where?: CaliberWhereInput
    data: XOR<CaliberUpdateWithoutFirearmChamberInput, CaliberUncheckedUpdateWithoutFirearmChamberInput>
  }

  export type CaliberUpdateWithoutFirearmChamberInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    Alert?: AlertUpdateManyWithoutCaliberNestedInput
    AmmoSpecs?: AmmoSpecsUpdateManyWithoutCaliberNestedInput
    CaliberAlias?: CaliberAliasUpdateManyWithoutCaliberNestedInput
  }

  export type CaliberUncheckedUpdateWithoutFirearmChamberInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    Alert?: AlertUncheckedUpdateManyWithoutCaliberNestedInput
    AmmoSpecs?: AmmoSpecsUncheckedUpdateManyWithoutCaliberNestedInput
    CaliberAlias?: CaliberAliasUncheckedUpdateManyWithoutCaliberNestedInput
  }

  export type FirearmSpecsUpsertWithoutFirearmChamberInput = {
    update: XOR<FirearmSpecsUpdateWithoutFirearmChamberInput, FirearmSpecsUncheckedUpdateWithoutFirearmChamberInput>
    create: XOR<FirearmSpecsCreateWithoutFirearmChamberInput, FirearmSpecsUncheckedCreateWithoutFirearmChamberInput>
    where?: FirearmSpecsWhereInput
  }

  export type FirearmSpecsUpdateToOneWithWhereWithoutFirearmChamberInput = {
    where?: FirearmSpecsWhereInput
    data: XOR<FirearmSpecsUpdateWithoutFirearmChamberInput, FirearmSpecsUncheckedUpdateWithoutFirearmChamberInput>
  }

  export type FirearmSpecsUpdateWithoutFirearmChamberInput = {
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    barrelLengthIn?: NullableFloatFieldUpdateOperationsInput | number | null
    actionType?: NullableStringFieldUpdateOperationsInput | string | null
    isThreaded?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pressureRating?: NullableEnumFirearmPressureRatingFieldUpdateOperationsInput | $Enums.FirearmPressureRating | null
    firearmType?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableStringFieldUpdateOperationsInput | string | null
    finish?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableStringFieldUpdateOperationsInput | string | null
    overallLength?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableStringFieldUpdateOperationsInput | string | null
    sight?: NullableStringFieldUpdateOperationsInput | string | null
    safety?: NullableStringFieldUpdateOperationsInput | string | null
    FirearmCategory?: FirearmCategoryUpdateOneWithoutFirearmSpecsNestedInput
    CatalogItem?: CatalogItemUpdateOneRequiredWithoutFirearmSpecsNestedInput
  }

  export type FirearmSpecsUncheckedUpdateWithoutFirearmChamberInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemId?: StringFieldUpdateOperationsInput | string
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    firearmCategoryId?: NullableIntFieldUpdateOperationsInput | number | null
    barrelLengthIn?: NullableFloatFieldUpdateOperationsInput | number | null
    actionType?: NullableStringFieldUpdateOperationsInput | string | null
    isThreaded?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pressureRating?: NullableEnumFirearmPressureRatingFieldUpdateOperationsInput | $Enums.FirearmPressureRating | null
    firearmType?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableStringFieldUpdateOperationsInput | string | null
    finish?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableStringFieldUpdateOperationsInput | string | null
    overallLength?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableStringFieldUpdateOperationsInput | string | null
    sight?: NullableStringFieldUpdateOperationsInput | string | null
    safety?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FirearmChamberCreateWithoutFirearmSpecsInput = {
    note?: string | null
    Caliber: CaliberCreateNestedOneWithoutFirearmChamberInput
  }

  export type FirearmChamberUncheckedCreateWithoutFirearmSpecsInput = {
    caliberId: number
    note?: string | null
  }

  export type FirearmChamberCreateOrConnectWithoutFirearmSpecsInput = {
    where: FirearmChamberWhereUniqueInput
    create: XOR<FirearmChamberCreateWithoutFirearmSpecsInput, FirearmChamberUncheckedCreateWithoutFirearmSpecsInput>
  }

  export type FirearmChamberCreateManyFirearmSpecsInputEnvelope = {
    data: FirearmChamberCreateManyFirearmSpecsInput | FirearmChamberCreateManyFirearmSpecsInput[]
    skipDuplicates?: boolean
  }

  export type FirearmCategoryCreateWithoutFirearmSpecsInput = {
    name: string
    slug: string
  }

  export type FirearmCategoryUncheckedCreateWithoutFirearmSpecsInput = {
    id?: number
    name: string
    slug: string
  }

  export type FirearmCategoryCreateOrConnectWithoutFirearmSpecsInput = {
    where: FirearmCategoryWhereUniqueInput
    create: XOR<FirearmCategoryCreateWithoutFirearmSpecsInput, FirearmCategoryUncheckedCreateWithoutFirearmSpecsInput>
  }

  export type CatalogItemCreateWithoutFirearmSpecsInput = {
    id: string
    kind: $Enums.CatalogKind
    slug: string
    upc?: string | null
    mpn?: string | null
    title: string
    image?: string | null
    description?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    bestPrice?: number | null
    bestRetailerId?: number | null
    bestRetailerName?: string | null
    offerCount?: number | null
    bestCpr?: number | null
    bestCprShipped?: number | null
    upvotes?: number | null
    downvotes?: number | null
    AccessoryFitment?: AccessoryFitmentCreateNestedManyWithoutCatalogItemInput
    AccessorySpecs?: AccessorySpecsCreateNestedOneWithoutCatalogItemInput
    Alert?: AlertCreateNestedManyWithoutCatalogItemInput
    AmmoSpecs?: AmmoSpecsCreateNestedOneWithoutCatalogItemInput
    Brand?: BrandCreateNestedOneWithoutCatalogItemInput
    Offer?: OfferCreateNestedManyWithoutCatalogItemInput
    OwnedFirearm?: OwnedFirearmCreateNestedManyWithoutCatalogItemInput
  }

  export type CatalogItemUncheckedCreateWithoutFirearmSpecsInput = {
    id: string
    kind: $Enums.CatalogKind
    slug: string
    upc?: string | null
    mpn?: string | null
    title: string
    image?: string | null
    description?: string | null
    brandId?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    bestPrice?: number | null
    bestRetailerId?: number | null
    bestRetailerName?: string | null
    offerCount?: number | null
    bestCpr?: number | null
    bestCprShipped?: number | null
    upvotes?: number | null
    downvotes?: number | null
    AccessoryFitment?: AccessoryFitmentUncheckedCreateNestedManyWithoutCatalogItemInput
    AccessorySpecs?: AccessorySpecsUncheckedCreateNestedOneWithoutCatalogItemInput
    Alert?: AlertUncheckedCreateNestedManyWithoutCatalogItemInput
    AmmoSpecs?: AmmoSpecsUncheckedCreateNestedOneWithoutCatalogItemInput
    Offer?: OfferUncheckedCreateNestedManyWithoutCatalogItemInput
    OwnedFirearm?: OwnedFirearmUncheckedCreateNestedManyWithoutCatalogItemInput
  }

  export type CatalogItemCreateOrConnectWithoutFirearmSpecsInput = {
    where: CatalogItemWhereUniqueInput
    create: XOR<CatalogItemCreateWithoutFirearmSpecsInput, CatalogItemUncheckedCreateWithoutFirearmSpecsInput>
  }

  export type FirearmChamberUpsertWithWhereUniqueWithoutFirearmSpecsInput = {
    where: FirearmChamberWhereUniqueInput
    update: XOR<FirearmChamberUpdateWithoutFirearmSpecsInput, FirearmChamberUncheckedUpdateWithoutFirearmSpecsInput>
    create: XOR<FirearmChamberCreateWithoutFirearmSpecsInput, FirearmChamberUncheckedCreateWithoutFirearmSpecsInput>
  }

  export type FirearmChamberUpdateWithWhereUniqueWithoutFirearmSpecsInput = {
    where: FirearmChamberWhereUniqueInput
    data: XOR<FirearmChamberUpdateWithoutFirearmSpecsInput, FirearmChamberUncheckedUpdateWithoutFirearmSpecsInput>
  }

  export type FirearmChamberUpdateManyWithWhereWithoutFirearmSpecsInput = {
    where: FirearmChamberScalarWhereInput
    data: XOR<FirearmChamberUpdateManyMutationInput, FirearmChamberUncheckedUpdateManyWithoutFirearmSpecsInput>
  }

  export type FirearmCategoryUpsertWithoutFirearmSpecsInput = {
    update: XOR<FirearmCategoryUpdateWithoutFirearmSpecsInput, FirearmCategoryUncheckedUpdateWithoutFirearmSpecsInput>
    create: XOR<FirearmCategoryCreateWithoutFirearmSpecsInput, FirearmCategoryUncheckedCreateWithoutFirearmSpecsInput>
    where?: FirearmCategoryWhereInput
  }

  export type FirearmCategoryUpdateToOneWithWhereWithoutFirearmSpecsInput = {
    where?: FirearmCategoryWhereInput
    data: XOR<FirearmCategoryUpdateWithoutFirearmSpecsInput, FirearmCategoryUncheckedUpdateWithoutFirearmSpecsInput>
  }

  export type FirearmCategoryUpdateWithoutFirearmSpecsInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type FirearmCategoryUncheckedUpdateWithoutFirearmSpecsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type CatalogItemUpsertWithoutFirearmSpecsInput = {
    update: XOR<CatalogItemUpdateWithoutFirearmSpecsInput, CatalogItemUncheckedUpdateWithoutFirearmSpecsInput>
    create: XOR<CatalogItemCreateWithoutFirearmSpecsInput, CatalogItemUncheckedCreateWithoutFirearmSpecsInput>
    where?: CatalogItemWhereInput
  }

  export type CatalogItemUpdateToOneWithWhereWithoutFirearmSpecsInput = {
    where?: CatalogItemWhereInput
    data: XOR<CatalogItemUpdateWithoutFirearmSpecsInput, CatalogItemUncheckedUpdateWithoutFirearmSpecsInput>
  }

  export type CatalogItemUpdateWithoutFirearmSpecsInput = {
    id?: StringFieldUpdateOperationsInput | string
    kind?: EnumCatalogKindFieldUpdateOperationsInput | $Enums.CatalogKind
    slug?: StringFieldUpdateOperationsInput | string
    upc?: NullableStringFieldUpdateOperationsInput | string | null
    mpn?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bestPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    bestRetailerId?: NullableIntFieldUpdateOperationsInput | number | null
    bestRetailerName?: NullableStringFieldUpdateOperationsInput | string | null
    offerCount?: NullableIntFieldUpdateOperationsInput | number | null
    bestCpr?: NullableFloatFieldUpdateOperationsInput | number | null
    bestCprShipped?: NullableFloatFieldUpdateOperationsInput | number | null
    upvotes?: NullableIntFieldUpdateOperationsInput | number | null
    downvotes?: NullableIntFieldUpdateOperationsInput | number | null
    AccessoryFitment?: AccessoryFitmentUpdateManyWithoutCatalogItemNestedInput
    AccessorySpecs?: AccessorySpecsUpdateOneWithoutCatalogItemNestedInput
    Alert?: AlertUpdateManyWithoutCatalogItemNestedInput
    AmmoSpecs?: AmmoSpecsUpdateOneWithoutCatalogItemNestedInput
    Brand?: BrandUpdateOneWithoutCatalogItemNestedInput
    Offer?: OfferUpdateManyWithoutCatalogItemNestedInput
    OwnedFirearm?: OwnedFirearmUpdateManyWithoutCatalogItemNestedInput
  }

  export type CatalogItemUncheckedUpdateWithoutFirearmSpecsInput = {
    id?: StringFieldUpdateOperationsInput | string
    kind?: EnumCatalogKindFieldUpdateOperationsInput | $Enums.CatalogKind
    slug?: StringFieldUpdateOperationsInput | string
    upc?: NullableStringFieldUpdateOperationsInput | string | null
    mpn?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    brandId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bestPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    bestRetailerId?: NullableIntFieldUpdateOperationsInput | number | null
    bestRetailerName?: NullableStringFieldUpdateOperationsInput | string | null
    offerCount?: NullableIntFieldUpdateOperationsInput | number | null
    bestCpr?: NullableFloatFieldUpdateOperationsInput | number | null
    bestCprShipped?: NullableFloatFieldUpdateOperationsInput | number | null
    upvotes?: NullableIntFieldUpdateOperationsInput | number | null
    downvotes?: NullableIntFieldUpdateOperationsInput | number | null
    AccessoryFitment?: AccessoryFitmentUncheckedUpdateManyWithoutCatalogItemNestedInput
    AccessorySpecs?: AccessorySpecsUncheckedUpdateOneWithoutCatalogItemNestedInput
    Alert?: AlertUncheckedUpdateManyWithoutCatalogItemNestedInput
    AmmoSpecs?: AmmoSpecsUncheckedUpdateOneWithoutCatalogItemNestedInput
    Offer?: OfferUncheckedUpdateManyWithoutCatalogItemNestedInput
    OwnedFirearm?: OwnedFirearmUncheckedUpdateManyWithoutCatalogItemNestedInput
  }

  export type CatalogItemCreateWithoutOwnedFirearmInput = {
    id: string
    kind: $Enums.CatalogKind
    slug: string
    upc?: string | null
    mpn?: string | null
    title: string
    image?: string | null
    description?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    bestPrice?: number | null
    bestRetailerId?: number | null
    bestRetailerName?: string | null
    offerCount?: number | null
    bestCpr?: number | null
    bestCprShipped?: number | null
    upvotes?: number | null
    downvotes?: number | null
    AccessoryFitment?: AccessoryFitmentCreateNestedManyWithoutCatalogItemInput
    AccessorySpecs?: AccessorySpecsCreateNestedOneWithoutCatalogItemInput
    Alert?: AlertCreateNestedManyWithoutCatalogItemInput
    AmmoSpecs?: AmmoSpecsCreateNestedOneWithoutCatalogItemInput
    Brand?: BrandCreateNestedOneWithoutCatalogItemInput
    FirearmSpecs?: FirearmSpecsCreateNestedOneWithoutCatalogItemInput
    Offer?: OfferCreateNestedManyWithoutCatalogItemInput
  }

  export type CatalogItemUncheckedCreateWithoutOwnedFirearmInput = {
    id: string
    kind: $Enums.CatalogKind
    slug: string
    upc?: string | null
    mpn?: string | null
    title: string
    image?: string | null
    description?: string | null
    brandId?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    bestPrice?: number | null
    bestRetailerId?: number | null
    bestRetailerName?: string | null
    offerCount?: number | null
    bestCpr?: number | null
    bestCprShipped?: number | null
    upvotes?: number | null
    downvotes?: number | null
    AccessoryFitment?: AccessoryFitmentUncheckedCreateNestedManyWithoutCatalogItemInput
    AccessorySpecs?: AccessorySpecsUncheckedCreateNestedOneWithoutCatalogItemInput
    Alert?: AlertUncheckedCreateNestedManyWithoutCatalogItemInput
    AmmoSpecs?: AmmoSpecsUncheckedCreateNestedOneWithoutCatalogItemInput
    FirearmSpecs?: FirearmSpecsUncheckedCreateNestedOneWithoutCatalogItemInput
    Offer?: OfferUncheckedCreateNestedManyWithoutCatalogItemInput
  }

  export type CatalogItemCreateOrConnectWithoutOwnedFirearmInput = {
    where: CatalogItemWhereUniqueInput
    create: XOR<CatalogItemCreateWithoutOwnedFirearmInput, CatalogItemUncheckedCreateWithoutOwnedFirearmInput>
  }

  export type UserCreateWithoutOwnedFirearmInput = {
    id: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    Alert?: AlertCreateNestedManyWithoutUserInput
    AlertDelivery?: AlertDeliveryCreateNestedManyWithoutUserInput
    BlockedRetailer?: BlockedRetailerCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOwnedFirearmInput = {
    id: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    Alert?: AlertUncheckedCreateNestedManyWithoutUserInput
    AlertDelivery?: AlertDeliveryUncheckedCreateNestedManyWithoutUserInput
    BlockedRetailer?: BlockedRetailerUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOwnedFirearmInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOwnedFirearmInput, UserUncheckedCreateWithoutOwnedFirearmInput>
  }

  export type CatalogItemUpsertWithoutOwnedFirearmInput = {
    update: XOR<CatalogItemUpdateWithoutOwnedFirearmInput, CatalogItemUncheckedUpdateWithoutOwnedFirearmInput>
    create: XOR<CatalogItemCreateWithoutOwnedFirearmInput, CatalogItemUncheckedCreateWithoutOwnedFirearmInput>
    where?: CatalogItemWhereInput
  }

  export type CatalogItemUpdateToOneWithWhereWithoutOwnedFirearmInput = {
    where?: CatalogItemWhereInput
    data: XOR<CatalogItemUpdateWithoutOwnedFirearmInput, CatalogItemUncheckedUpdateWithoutOwnedFirearmInput>
  }

  export type CatalogItemUpdateWithoutOwnedFirearmInput = {
    id?: StringFieldUpdateOperationsInput | string
    kind?: EnumCatalogKindFieldUpdateOperationsInput | $Enums.CatalogKind
    slug?: StringFieldUpdateOperationsInput | string
    upc?: NullableStringFieldUpdateOperationsInput | string | null
    mpn?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bestPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    bestRetailerId?: NullableIntFieldUpdateOperationsInput | number | null
    bestRetailerName?: NullableStringFieldUpdateOperationsInput | string | null
    offerCount?: NullableIntFieldUpdateOperationsInput | number | null
    bestCpr?: NullableFloatFieldUpdateOperationsInput | number | null
    bestCprShipped?: NullableFloatFieldUpdateOperationsInput | number | null
    upvotes?: NullableIntFieldUpdateOperationsInput | number | null
    downvotes?: NullableIntFieldUpdateOperationsInput | number | null
    AccessoryFitment?: AccessoryFitmentUpdateManyWithoutCatalogItemNestedInput
    AccessorySpecs?: AccessorySpecsUpdateOneWithoutCatalogItemNestedInput
    Alert?: AlertUpdateManyWithoutCatalogItemNestedInput
    AmmoSpecs?: AmmoSpecsUpdateOneWithoutCatalogItemNestedInput
    Brand?: BrandUpdateOneWithoutCatalogItemNestedInput
    FirearmSpecs?: FirearmSpecsUpdateOneWithoutCatalogItemNestedInput
    Offer?: OfferUpdateManyWithoutCatalogItemNestedInput
  }

  export type CatalogItemUncheckedUpdateWithoutOwnedFirearmInput = {
    id?: StringFieldUpdateOperationsInput | string
    kind?: EnumCatalogKindFieldUpdateOperationsInput | $Enums.CatalogKind
    slug?: StringFieldUpdateOperationsInput | string
    upc?: NullableStringFieldUpdateOperationsInput | string | null
    mpn?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    brandId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bestPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    bestRetailerId?: NullableIntFieldUpdateOperationsInput | number | null
    bestRetailerName?: NullableStringFieldUpdateOperationsInput | string | null
    offerCount?: NullableIntFieldUpdateOperationsInput | number | null
    bestCpr?: NullableFloatFieldUpdateOperationsInput | number | null
    bestCprShipped?: NullableFloatFieldUpdateOperationsInput | number | null
    upvotes?: NullableIntFieldUpdateOperationsInput | number | null
    downvotes?: NullableIntFieldUpdateOperationsInput | number | null
    AccessoryFitment?: AccessoryFitmentUncheckedUpdateManyWithoutCatalogItemNestedInput
    AccessorySpecs?: AccessorySpecsUncheckedUpdateOneWithoutCatalogItemNestedInput
    Alert?: AlertUncheckedUpdateManyWithoutCatalogItemNestedInput
    AmmoSpecs?: AmmoSpecsUncheckedUpdateOneWithoutCatalogItemNestedInput
    FirearmSpecs?: FirearmSpecsUncheckedUpdateOneWithoutCatalogItemNestedInput
    Offer?: OfferUncheckedUpdateManyWithoutCatalogItemNestedInput
  }

  export type UserUpsertWithoutOwnedFirearmInput = {
    update: XOR<UserUpdateWithoutOwnedFirearmInput, UserUncheckedUpdateWithoutOwnedFirearmInput>
    create: XOR<UserCreateWithoutOwnedFirearmInput, UserUncheckedCreateWithoutOwnedFirearmInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOwnedFirearmInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOwnedFirearmInput, UserUncheckedUpdateWithoutOwnedFirearmInput>
  }

  export type UserUpdateWithoutOwnedFirearmInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Alert?: AlertUpdateManyWithoutUserNestedInput
    AlertDelivery?: AlertDeliveryUpdateManyWithoutUserNestedInput
    BlockedRetailer?: BlockedRetailerUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOwnedFirearmInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Alert?: AlertUncheckedUpdateManyWithoutUserNestedInput
    AlertDelivery?: AlertDeliveryUncheckedUpdateManyWithoutUserNestedInput
    BlockedRetailer?: BlockedRetailerUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AlertCreateWithoutUserInput = {
    id: string
    type: $Enums.AlertType
    keyword?: string | null
    targetCpr?: number | null
    excludeSteel?: boolean | null
    excludeReman?: boolean | null
    lastTriggered?: Date | string | null
    isActive?: boolean | null
    createdAt?: Date | string | null
    Caliber?: CaliberCreateNestedOneWithoutAlertInput
    CatalogItem?: CatalogItemCreateNestedOneWithoutAlertInput
    AlertDelivery?: AlertDeliveryCreateNestedManyWithoutAlertInput
  }

  export type AlertUncheckedCreateWithoutUserInput = {
    id: string
    type: $Enums.AlertType
    calId?: number | null
    itemId?: string | null
    keyword?: string | null
    targetCpr?: number | null
    excludeSteel?: boolean | null
    excludeReman?: boolean | null
    lastTriggered?: Date | string | null
    isActive?: boolean | null
    createdAt?: Date | string | null
    AlertDelivery?: AlertDeliveryUncheckedCreateNestedManyWithoutAlertInput
  }

  export type AlertCreateOrConnectWithoutUserInput = {
    where: AlertWhereUniqueInput
    create: XOR<AlertCreateWithoutUserInput, AlertUncheckedCreateWithoutUserInput>
  }

  export type AlertCreateManyUserInputEnvelope = {
    data: AlertCreateManyUserInput | AlertCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AlertDeliveryCreateWithoutUserInput = {
    id: string
    sentAt?: Date | string | null
    fingerprint: string
    Alert: AlertCreateNestedOneWithoutAlertDeliveryInput
    Offer?: OfferCreateNestedOneWithoutAlertDeliveryInput
  }

  export type AlertDeliveryUncheckedCreateWithoutUserInput = {
    id: string
    alertId: string
    offerId?: number | null
    sentAt?: Date | string | null
    fingerprint: string
  }

  export type AlertDeliveryCreateOrConnectWithoutUserInput = {
    where: AlertDeliveryWhereUniqueInput
    create: XOR<AlertDeliveryCreateWithoutUserInput, AlertDeliveryUncheckedCreateWithoutUserInput>
  }

  export type AlertDeliveryCreateManyUserInputEnvelope = {
    data: AlertDeliveryCreateManyUserInput | AlertDeliveryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BlockedRetailerCreateWithoutUserInput = {
    id: string
    createdAt?: Date | string | null
    Retailer: RetailerCreateNestedOneWithoutBlockedRetailerInput
  }

  export type BlockedRetailerUncheckedCreateWithoutUserInput = {
    id: string
    retailerId: number
    createdAt?: Date | string | null
  }

  export type BlockedRetailerCreateOrConnectWithoutUserInput = {
    where: BlockedRetailerWhereUniqueInput
    create: XOR<BlockedRetailerCreateWithoutUserInput, BlockedRetailerUncheckedCreateWithoutUserInput>
  }

  export type BlockedRetailerCreateManyUserInputEnvelope = {
    data: BlockedRetailerCreateManyUserInput | BlockedRetailerCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type OwnedFirearmCreateWithoutUserInput = {
    id: string
    nickname?: string | null
    createdAt?: Date | string | null
    CatalogItem: CatalogItemCreateNestedOneWithoutOwnedFirearmInput
  }

  export type OwnedFirearmUncheckedCreateWithoutUserInput = {
    id: string
    firearmItemId: string
    nickname?: string | null
    createdAt?: Date | string | null
  }

  export type OwnedFirearmCreateOrConnectWithoutUserInput = {
    where: OwnedFirearmWhereUniqueInput
    create: XOR<OwnedFirearmCreateWithoutUserInput, OwnedFirearmUncheckedCreateWithoutUserInput>
  }

  export type OwnedFirearmCreateManyUserInputEnvelope = {
    data: OwnedFirearmCreateManyUserInput | OwnedFirearmCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AlertUpsertWithWhereUniqueWithoutUserInput = {
    where: AlertWhereUniqueInput
    update: XOR<AlertUpdateWithoutUserInput, AlertUncheckedUpdateWithoutUserInput>
    create: XOR<AlertCreateWithoutUserInput, AlertUncheckedCreateWithoutUserInput>
  }

  export type AlertUpdateWithWhereUniqueWithoutUserInput = {
    where: AlertWhereUniqueInput
    data: XOR<AlertUpdateWithoutUserInput, AlertUncheckedUpdateWithoutUserInput>
  }

  export type AlertUpdateManyWithWhereWithoutUserInput = {
    where: AlertScalarWhereInput
    data: XOR<AlertUpdateManyMutationInput, AlertUncheckedUpdateManyWithoutUserInput>
  }

  export type AlertDeliveryUpsertWithWhereUniqueWithoutUserInput = {
    where: AlertDeliveryWhereUniqueInput
    update: XOR<AlertDeliveryUpdateWithoutUserInput, AlertDeliveryUncheckedUpdateWithoutUserInput>
    create: XOR<AlertDeliveryCreateWithoutUserInput, AlertDeliveryUncheckedCreateWithoutUserInput>
  }

  export type AlertDeliveryUpdateWithWhereUniqueWithoutUserInput = {
    where: AlertDeliveryWhereUniqueInput
    data: XOR<AlertDeliveryUpdateWithoutUserInput, AlertDeliveryUncheckedUpdateWithoutUserInput>
  }

  export type AlertDeliveryUpdateManyWithWhereWithoutUserInput = {
    where: AlertDeliveryScalarWhereInput
    data: XOR<AlertDeliveryUpdateManyMutationInput, AlertDeliveryUncheckedUpdateManyWithoutUserInput>
  }

  export type BlockedRetailerUpsertWithWhereUniqueWithoutUserInput = {
    where: BlockedRetailerWhereUniqueInput
    update: XOR<BlockedRetailerUpdateWithoutUserInput, BlockedRetailerUncheckedUpdateWithoutUserInput>
    create: XOR<BlockedRetailerCreateWithoutUserInput, BlockedRetailerUncheckedCreateWithoutUserInput>
  }

  export type BlockedRetailerUpdateWithWhereUniqueWithoutUserInput = {
    where: BlockedRetailerWhereUniqueInput
    data: XOR<BlockedRetailerUpdateWithoutUserInput, BlockedRetailerUncheckedUpdateWithoutUserInput>
  }

  export type BlockedRetailerUpdateManyWithWhereWithoutUserInput = {
    where: BlockedRetailerScalarWhereInput
    data: XOR<BlockedRetailerUpdateManyMutationInput, BlockedRetailerUncheckedUpdateManyWithoutUserInput>
  }

  export type OwnedFirearmUpsertWithWhereUniqueWithoutUserInput = {
    where: OwnedFirearmWhereUniqueInput
    update: XOR<OwnedFirearmUpdateWithoutUserInput, OwnedFirearmUncheckedUpdateWithoutUserInput>
    create: XOR<OwnedFirearmCreateWithoutUserInput, OwnedFirearmUncheckedCreateWithoutUserInput>
  }

  export type OwnedFirearmUpdateWithWhereUniqueWithoutUserInput = {
    where: OwnedFirearmWhereUniqueInput
    data: XOR<OwnedFirearmUpdateWithoutUserInput, OwnedFirearmUncheckedUpdateWithoutUserInput>
  }

  export type OwnedFirearmUpdateManyWithWhereWithoutUserInput = {
    where: OwnedFirearmScalarWhereInput
    data: XOR<OwnedFirearmUpdateManyMutationInput, OwnedFirearmUncheckedUpdateManyWithoutUserInput>
  }

  export type CatalogItemCreateManyBrandInput = {
    id: string
    kind: $Enums.CatalogKind
    slug: string
    upc?: string | null
    mpn?: string | null
    title: string
    image?: string | null
    description?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    bestPrice?: number | null
    bestRetailerId?: number | null
    bestRetailerName?: string | null
    offerCount?: number | null
    bestCpr?: number | null
    bestCprShipped?: number | null
    upvotes?: number | null
    downvotes?: number | null
  }

  export type CatalogItemUpdateWithoutBrandInput = {
    id?: StringFieldUpdateOperationsInput | string
    kind?: EnumCatalogKindFieldUpdateOperationsInput | $Enums.CatalogKind
    slug?: StringFieldUpdateOperationsInput | string
    upc?: NullableStringFieldUpdateOperationsInput | string | null
    mpn?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bestPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    bestRetailerId?: NullableIntFieldUpdateOperationsInput | number | null
    bestRetailerName?: NullableStringFieldUpdateOperationsInput | string | null
    offerCount?: NullableIntFieldUpdateOperationsInput | number | null
    bestCpr?: NullableFloatFieldUpdateOperationsInput | number | null
    bestCprShipped?: NullableFloatFieldUpdateOperationsInput | number | null
    upvotes?: NullableIntFieldUpdateOperationsInput | number | null
    downvotes?: NullableIntFieldUpdateOperationsInput | number | null
    AccessoryFitment?: AccessoryFitmentUpdateManyWithoutCatalogItemNestedInput
    AccessorySpecs?: AccessorySpecsUpdateOneWithoutCatalogItemNestedInput
    Alert?: AlertUpdateManyWithoutCatalogItemNestedInput
    AmmoSpecs?: AmmoSpecsUpdateOneWithoutCatalogItemNestedInput
    FirearmSpecs?: FirearmSpecsUpdateOneWithoutCatalogItemNestedInput
    Offer?: OfferUpdateManyWithoutCatalogItemNestedInput
    OwnedFirearm?: OwnedFirearmUpdateManyWithoutCatalogItemNestedInput
  }

  export type CatalogItemUncheckedUpdateWithoutBrandInput = {
    id?: StringFieldUpdateOperationsInput | string
    kind?: EnumCatalogKindFieldUpdateOperationsInput | $Enums.CatalogKind
    slug?: StringFieldUpdateOperationsInput | string
    upc?: NullableStringFieldUpdateOperationsInput | string | null
    mpn?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bestPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    bestRetailerId?: NullableIntFieldUpdateOperationsInput | number | null
    bestRetailerName?: NullableStringFieldUpdateOperationsInput | string | null
    offerCount?: NullableIntFieldUpdateOperationsInput | number | null
    bestCpr?: NullableFloatFieldUpdateOperationsInput | number | null
    bestCprShipped?: NullableFloatFieldUpdateOperationsInput | number | null
    upvotes?: NullableIntFieldUpdateOperationsInput | number | null
    downvotes?: NullableIntFieldUpdateOperationsInput | number | null
    AccessoryFitment?: AccessoryFitmentUncheckedUpdateManyWithoutCatalogItemNestedInput
    AccessorySpecs?: AccessorySpecsUncheckedUpdateOneWithoutCatalogItemNestedInput
    Alert?: AlertUncheckedUpdateManyWithoutCatalogItemNestedInput
    AmmoSpecs?: AmmoSpecsUncheckedUpdateOneWithoutCatalogItemNestedInput
    FirearmSpecs?: FirearmSpecsUncheckedUpdateOneWithoutCatalogItemNestedInput
    Offer?: OfferUncheckedUpdateManyWithoutCatalogItemNestedInput
    OwnedFirearm?: OwnedFirearmUncheckedUpdateManyWithoutCatalogItemNestedInput
  }

  export type CatalogItemUncheckedUpdateManyWithoutBrandInput = {
    id?: StringFieldUpdateOperationsInput | string
    kind?: EnumCatalogKindFieldUpdateOperationsInput | $Enums.CatalogKind
    slug?: StringFieldUpdateOperationsInput | string
    upc?: NullableStringFieldUpdateOperationsInput | string | null
    mpn?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bestPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    bestRetailerId?: NullableIntFieldUpdateOperationsInput | number | null
    bestRetailerName?: NullableStringFieldUpdateOperationsInput | string | null
    offerCount?: NullableIntFieldUpdateOperationsInput | number | null
    bestCpr?: NullableFloatFieldUpdateOperationsInput | number | null
    bestCprShipped?: NullableFloatFieldUpdateOperationsInput | number | null
    upvotes?: NullableIntFieldUpdateOperationsInput | number | null
    downvotes?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AlertCreateManyCaliberInput = {
    id: string
    userId: string
    type: $Enums.AlertType
    itemId?: string | null
    keyword?: string | null
    targetCpr?: number | null
    excludeSteel?: boolean | null
    excludeReman?: boolean | null
    lastTriggered?: Date | string | null
    isActive?: boolean | null
    createdAt?: Date | string | null
  }

  export type AmmoSpecsCreateManyCaliberInput = {
    id?: number
    itemId: string
    grain?: number | null
    gauge?: string | null
    velocity?: number | null
    energy?: number | null
    casing?: string | null
    bulletType?: string | null
    restrictions?: AmmoSpecsCreaterestrictionsInput | string[]
    pressure?: $Enums.AmmoPressure | null
    isSteelCase?: boolean | null
    isRemanufactured?: boolean | null
    isSubsonic?: boolean | null
  }

  export type CaliberAliasCreateManyCaliberInput = {
    id?: number
    alias: string
  }

  export type FirearmChamberCreateManyCaliberInput = {
    firearmSpecsId: number
    note?: string | null
  }

  export type AlertUpdateWithoutCaliberInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAlertTypeFieldUpdateOperationsInput | $Enums.AlertType
    keyword?: NullableStringFieldUpdateOperationsInput | string | null
    targetCpr?: NullableFloatFieldUpdateOperationsInput | number | null
    excludeSteel?: NullableBoolFieldUpdateOperationsInput | boolean | null
    excludeReman?: NullableBoolFieldUpdateOperationsInput | boolean | null
    lastTriggered?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CatalogItem?: CatalogItemUpdateOneWithoutAlertNestedInput
    User?: UserUpdateOneRequiredWithoutAlertNestedInput
    AlertDelivery?: AlertDeliveryUpdateManyWithoutAlertNestedInput
  }

  export type AlertUncheckedUpdateWithoutCaliberInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumAlertTypeFieldUpdateOperationsInput | $Enums.AlertType
    itemId?: NullableStringFieldUpdateOperationsInput | string | null
    keyword?: NullableStringFieldUpdateOperationsInput | string | null
    targetCpr?: NullableFloatFieldUpdateOperationsInput | number | null
    excludeSteel?: NullableBoolFieldUpdateOperationsInput | boolean | null
    excludeReman?: NullableBoolFieldUpdateOperationsInput | boolean | null
    lastTriggered?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    AlertDelivery?: AlertDeliveryUncheckedUpdateManyWithoutAlertNestedInput
  }

  export type AlertUncheckedUpdateManyWithoutCaliberInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumAlertTypeFieldUpdateOperationsInput | $Enums.AlertType
    itemId?: NullableStringFieldUpdateOperationsInput | string | null
    keyword?: NullableStringFieldUpdateOperationsInput | string | null
    targetCpr?: NullableFloatFieldUpdateOperationsInput | number | null
    excludeSteel?: NullableBoolFieldUpdateOperationsInput | boolean | null
    excludeReman?: NullableBoolFieldUpdateOperationsInput | boolean | null
    lastTriggered?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AmmoSpecsUpdateWithoutCaliberInput = {
    grain?: NullableIntFieldUpdateOperationsInput | number | null
    gauge?: NullableStringFieldUpdateOperationsInput | string | null
    velocity?: NullableIntFieldUpdateOperationsInput | number | null
    energy?: NullableIntFieldUpdateOperationsInput | number | null
    casing?: NullableStringFieldUpdateOperationsInput | string | null
    bulletType?: NullableStringFieldUpdateOperationsInput | string | null
    restrictions?: AmmoSpecsUpdaterestrictionsInput | string[]
    pressure?: NullableEnumAmmoPressureFieldUpdateOperationsInput | $Enums.AmmoPressure | null
    isSteelCase?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isRemanufactured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isSubsonic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    CatalogItem?: CatalogItemUpdateOneRequiredWithoutAmmoSpecsNestedInput
  }

  export type AmmoSpecsUncheckedUpdateWithoutCaliberInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemId?: StringFieldUpdateOperationsInput | string
    grain?: NullableIntFieldUpdateOperationsInput | number | null
    gauge?: NullableStringFieldUpdateOperationsInput | string | null
    velocity?: NullableIntFieldUpdateOperationsInput | number | null
    energy?: NullableIntFieldUpdateOperationsInput | number | null
    casing?: NullableStringFieldUpdateOperationsInput | string | null
    bulletType?: NullableStringFieldUpdateOperationsInput | string | null
    restrictions?: AmmoSpecsUpdaterestrictionsInput | string[]
    pressure?: NullableEnumAmmoPressureFieldUpdateOperationsInput | $Enums.AmmoPressure | null
    isSteelCase?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isRemanufactured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isSubsonic?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type AmmoSpecsUncheckedUpdateManyWithoutCaliberInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemId?: StringFieldUpdateOperationsInput | string
    grain?: NullableIntFieldUpdateOperationsInput | number | null
    gauge?: NullableStringFieldUpdateOperationsInput | string | null
    velocity?: NullableIntFieldUpdateOperationsInput | number | null
    energy?: NullableIntFieldUpdateOperationsInput | number | null
    casing?: NullableStringFieldUpdateOperationsInput | string | null
    bulletType?: NullableStringFieldUpdateOperationsInput | string | null
    restrictions?: AmmoSpecsUpdaterestrictionsInput | string[]
    pressure?: NullableEnumAmmoPressureFieldUpdateOperationsInput | $Enums.AmmoPressure | null
    isSteelCase?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isRemanufactured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isSubsonic?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type CaliberAliasUpdateWithoutCaliberInput = {
    alias?: StringFieldUpdateOperationsInput | string
  }

  export type CaliberAliasUncheckedUpdateWithoutCaliberInput = {
    id?: IntFieldUpdateOperationsInput | number
    alias?: StringFieldUpdateOperationsInput | string
  }

  export type CaliberAliasUncheckedUpdateManyWithoutCaliberInput = {
    id?: IntFieldUpdateOperationsInput | number
    alias?: StringFieldUpdateOperationsInput | string
  }

  export type FirearmChamberUpdateWithoutCaliberInput = {
    note?: NullableStringFieldUpdateOperationsInput | string | null
    FirearmSpecs?: FirearmSpecsUpdateOneRequiredWithoutFirearmChamberNestedInput
  }

  export type FirearmChamberUncheckedUpdateWithoutCaliberInput = {
    firearmSpecsId?: IntFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FirearmChamberUncheckedUpdateManyWithoutCaliberInput = {
    firearmSpecsId?: IntFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AlertDeliveryCreateManyOfferInput = {
    id: string
    alertId: string
    sentAt?: Date | string | null
    fingerprint: string
    userId: string
  }

  export type AlertDeliveryUpdateWithoutOfferInput = {
    id?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fingerprint?: StringFieldUpdateOperationsInput | string
    Alert?: AlertUpdateOneRequiredWithoutAlertDeliveryNestedInput
    User?: UserUpdateOneRequiredWithoutAlertDeliveryNestedInput
  }

  export type AlertDeliveryUncheckedUpdateWithoutOfferInput = {
    id?: StringFieldUpdateOperationsInput | string
    alertId?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fingerprint?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type AlertDeliveryUncheckedUpdateManyWithoutOfferInput = {
    id?: StringFieldUpdateOperationsInput | string
    alertId?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fingerprint?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type BlockedRetailerCreateManyRetailerInput = {
    id: string
    userId: string
    createdAt?: Date | string | null
  }

  export type OfferCreateManyRetailerInput = {
    id?: number
    itemId: string
    url: string
    inStock?: boolean | null
    price: number
    currency?: string | null
    shippingCost?: number | null
    total?: number | null
    freeShipping?: boolean | null
    shippingNote?: string | null
    shippingUpdatedAt?: Date | string | null
    unitsCount?: number | null
    unitLabel?: string | null
    unitPrice?: number | null
    totalUnitPrice?: number | null
    retailerSku?: string | null
    isManuallyOOS?: boolean | null
    oosReportCount?: number | null
    lastStockChange?: Date | string | null
    lastSeen?: Date | string | null
  }

  export type BlockedRetailerUpdateWithoutRetailerInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    User?: UserUpdateOneRequiredWithoutBlockedRetailerNestedInput
  }

  export type BlockedRetailerUncheckedUpdateWithoutRetailerInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BlockedRetailerUncheckedUpdateManyWithoutRetailerInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OfferUpdateWithoutRetailerInput = {
    url?: StringFieldUpdateOperationsInput | string
    inStock?: NullableBoolFieldUpdateOperationsInput | boolean | null
    price?: FloatFieldUpdateOperationsInput | number
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    shippingCost?: NullableFloatFieldUpdateOperationsInput | number | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    freeShipping?: NullableBoolFieldUpdateOperationsInput | boolean | null
    shippingNote?: NullableStringFieldUpdateOperationsInput | string | null
    shippingUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unitsCount?: NullableIntFieldUpdateOperationsInput | number | null
    unitLabel?: NullableStringFieldUpdateOperationsInput | string | null
    unitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    totalUnitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    retailerSku?: NullableStringFieldUpdateOperationsInput | string | null
    isManuallyOOS?: NullableBoolFieldUpdateOperationsInput | boolean | null
    oosReportCount?: NullableIntFieldUpdateOperationsInput | number | null
    lastStockChange?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    AlertDelivery?: AlertDeliveryUpdateManyWithoutOfferNestedInput
    CatalogItem?: CatalogItemUpdateOneRequiredWithoutOfferNestedInput
  }

  export type OfferUncheckedUpdateWithoutRetailerInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    inStock?: NullableBoolFieldUpdateOperationsInput | boolean | null
    price?: FloatFieldUpdateOperationsInput | number
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    shippingCost?: NullableFloatFieldUpdateOperationsInput | number | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    freeShipping?: NullableBoolFieldUpdateOperationsInput | boolean | null
    shippingNote?: NullableStringFieldUpdateOperationsInput | string | null
    shippingUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unitsCount?: NullableIntFieldUpdateOperationsInput | number | null
    unitLabel?: NullableStringFieldUpdateOperationsInput | string | null
    unitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    totalUnitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    retailerSku?: NullableStringFieldUpdateOperationsInput | string | null
    isManuallyOOS?: NullableBoolFieldUpdateOperationsInput | boolean | null
    oosReportCount?: NullableIntFieldUpdateOperationsInput | number | null
    lastStockChange?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    AlertDelivery?: AlertDeliveryUncheckedUpdateManyWithoutOfferNestedInput
  }

  export type OfferUncheckedUpdateManyWithoutRetailerInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    inStock?: NullableBoolFieldUpdateOperationsInput | boolean | null
    price?: FloatFieldUpdateOperationsInput | number
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    shippingCost?: NullableFloatFieldUpdateOperationsInput | number | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    freeShipping?: NullableBoolFieldUpdateOperationsInput | boolean | null
    shippingNote?: NullableStringFieldUpdateOperationsInput | string | null
    shippingUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unitsCount?: NullableIntFieldUpdateOperationsInput | number | null
    unitLabel?: NullableStringFieldUpdateOperationsInput | string | null
    unitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    totalUnitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    retailerSku?: NullableStringFieldUpdateOperationsInput | string | null
    isManuallyOOS?: NullableBoolFieldUpdateOperationsInput | boolean | null
    oosReportCount?: NullableIntFieldUpdateOperationsInput | number | null
    lastStockChange?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AccessoryFitmentCreateManyAccessorySpecsInput = {
    id?: number
    fitmentType: $Enums.FitmentType
    firearmItemId?: string | null
    platform?: string | null
    note?: string | null
  }

  export type AccessoryFitmentUpdateWithoutAccessorySpecsInput = {
    fitmentType?: EnumFitmentTypeFieldUpdateOperationsInput | $Enums.FitmentType
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    CatalogItem?: CatalogItemUpdateOneWithoutAccessoryFitmentNestedInput
  }

  export type AccessoryFitmentUncheckedUpdateWithoutAccessorySpecsInput = {
    id?: IntFieldUpdateOperationsInput | number
    fitmentType?: EnumFitmentTypeFieldUpdateOperationsInput | $Enums.FitmentType
    firearmItemId?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccessoryFitmentUncheckedUpdateManyWithoutAccessorySpecsInput = {
    id?: IntFieldUpdateOperationsInput | number
    fitmentType?: EnumFitmentTypeFieldUpdateOperationsInput | $Enums.FitmentType
    firearmItemId?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccessorySpecsCreateManyAccessoryTypeInput = {
    id?: number
    itemId: string
    material?: string | null
    color?: string | null
    notes?: string | null
  }

  export type AccessorySpecsUpdateWithoutAccessoryTypeInput = {
    material?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    AccessoryFitment?: AccessoryFitmentUpdateManyWithoutAccessorySpecsNestedInput
    CatalogItem?: CatalogItemUpdateOneRequiredWithoutAccessorySpecsNestedInput
  }

  export type AccessorySpecsUncheckedUpdateWithoutAccessoryTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemId?: StringFieldUpdateOperationsInput | string
    material?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    AccessoryFitment?: AccessoryFitmentUncheckedUpdateManyWithoutAccessorySpecsNestedInput
  }

  export type AccessorySpecsUncheckedUpdateManyWithoutAccessoryTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemId?: StringFieldUpdateOperationsInput | string
    material?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AlertDeliveryCreateManyAlertInput = {
    id: string
    offerId?: number | null
    sentAt?: Date | string | null
    fingerprint: string
    userId: string
  }

  export type AlertDeliveryUpdateWithoutAlertInput = {
    id?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fingerprint?: StringFieldUpdateOperationsInput | string
    Offer?: OfferUpdateOneWithoutAlertDeliveryNestedInput
    User?: UserUpdateOneRequiredWithoutAlertDeliveryNestedInput
  }

  export type AlertDeliveryUncheckedUpdateWithoutAlertInput = {
    id?: StringFieldUpdateOperationsInput | string
    offerId?: NullableIntFieldUpdateOperationsInput | number | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fingerprint?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type AlertDeliveryUncheckedUpdateManyWithoutAlertInput = {
    id?: StringFieldUpdateOperationsInput | string
    offerId?: NullableIntFieldUpdateOperationsInput | number | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fingerprint?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type AccessoryFitmentCreateManyCatalogItemInput = {
    id?: number
    accessorySpecsId: number
    fitmentType: $Enums.FitmentType
    platform?: string | null
    note?: string | null
  }

  export type AlertCreateManyCatalogItemInput = {
    id: string
    userId: string
    type: $Enums.AlertType
    calId?: number | null
    keyword?: string | null
    targetCpr?: number | null
    excludeSteel?: boolean | null
    excludeReman?: boolean | null
    lastTriggered?: Date | string | null
    isActive?: boolean | null
    createdAt?: Date | string | null
  }

  export type OfferCreateManyCatalogItemInput = {
    id?: number
    retailerId: number
    url: string
    inStock?: boolean | null
    price: number
    currency?: string | null
    shippingCost?: number | null
    total?: number | null
    freeShipping?: boolean | null
    shippingNote?: string | null
    shippingUpdatedAt?: Date | string | null
    unitsCount?: number | null
    unitLabel?: string | null
    unitPrice?: number | null
    totalUnitPrice?: number | null
    retailerSku?: string | null
    isManuallyOOS?: boolean | null
    oosReportCount?: number | null
    lastStockChange?: Date | string | null
    lastSeen?: Date | string | null
  }

  export type OwnedFirearmCreateManyCatalogItemInput = {
    id: string
    userId: string
    nickname?: string | null
    createdAt?: Date | string | null
  }

  export type AccessoryFitmentUpdateWithoutCatalogItemInput = {
    fitmentType?: EnumFitmentTypeFieldUpdateOperationsInput | $Enums.FitmentType
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    AccessorySpecs?: AccessorySpecsUpdateOneRequiredWithoutAccessoryFitmentNestedInput
  }

  export type AccessoryFitmentUncheckedUpdateWithoutCatalogItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    accessorySpecsId?: IntFieldUpdateOperationsInput | number
    fitmentType?: EnumFitmentTypeFieldUpdateOperationsInput | $Enums.FitmentType
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccessoryFitmentUncheckedUpdateManyWithoutCatalogItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    accessorySpecsId?: IntFieldUpdateOperationsInput | number
    fitmentType?: EnumFitmentTypeFieldUpdateOperationsInput | $Enums.FitmentType
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AlertUpdateWithoutCatalogItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAlertTypeFieldUpdateOperationsInput | $Enums.AlertType
    keyword?: NullableStringFieldUpdateOperationsInput | string | null
    targetCpr?: NullableFloatFieldUpdateOperationsInput | number | null
    excludeSteel?: NullableBoolFieldUpdateOperationsInput | boolean | null
    excludeReman?: NullableBoolFieldUpdateOperationsInput | boolean | null
    lastTriggered?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Caliber?: CaliberUpdateOneWithoutAlertNestedInput
    User?: UserUpdateOneRequiredWithoutAlertNestedInput
    AlertDelivery?: AlertDeliveryUpdateManyWithoutAlertNestedInput
  }

  export type AlertUncheckedUpdateWithoutCatalogItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumAlertTypeFieldUpdateOperationsInput | $Enums.AlertType
    calId?: NullableIntFieldUpdateOperationsInput | number | null
    keyword?: NullableStringFieldUpdateOperationsInput | string | null
    targetCpr?: NullableFloatFieldUpdateOperationsInput | number | null
    excludeSteel?: NullableBoolFieldUpdateOperationsInput | boolean | null
    excludeReman?: NullableBoolFieldUpdateOperationsInput | boolean | null
    lastTriggered?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    AlertDelivery?: AlertDeliveryUncheckedUpdateManyWithoutAlertNestedInput
  }

  export type AlertUncheckedUpdateManyWithoutCatalogItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumAlertTypeFieldUpdateOperationsInput | $Enums.AlertType
    calId?: NullableIntFieldUpdateOperationsInput | number | null
    keyword?: NullableStringFieldUpdateOperationsInput | string | null
    targetCpr?: NullableFloatFieldUpdateOperationsInput | number | null
    excludeSteel?: NullableBoolFieldUpdateOperationsInput | boolean | null
    excludeReman?: NullableBoolFieldUpdateOperationsInput | boolean | null
    lastTriggered?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OfferUpdateWithoutCatalogItemInput = {
    url?: StringFieldUpdateOperationsInput | string
    inStock?: NullableBoolFieldUpdateOperationsInput | boolean | null
    price?: FloatFieldUpdateOperationsInput | number
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    shippingCost?: NullableFloatFieldUpdateOperationsInput | number | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    freeShipping?: NullableBoolFieldUpdateOperationsInput | boolean | null
    shippingNote?: NullableStringFieldUpdateOperationsInput | string | null
    shippingUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unitsCount?: NullableIntFieldUpdateOperationsInput | number | null
    unitLabel?: NullableStringFieldUpdateOperationsInput | string | null
    unitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    totalUnitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    retailerSku?: NullableStringFieldUpdateOperationsInput | string | null
    isManuallyOOS?: NullableBoolFieldUpdateOperationsInput | boolean | null
    oosReportCount?: NullableIntFieldUpdateOperationsInput | number | null
    lastStockChange?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    AlertDelivery?: AlertDeliveryUpdateManyWithoutOfferNestedInput
    retailer?: RetailerUpdateOneRequiredWithoutOffersNestedInput
  }

  export type OfferUncheckedUpdateWithoutCatalogItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    retailerId?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    inStock?: NullableBoolFieldUpdateOperationsInput | boolean | null
    price?: FloatFieldUpdateOperationsInput | number
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    shippingCost?: NullableFloatFieldUpdateOperationsInput | number | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    freeShipping?: NullableBoolFieldUpdateOperationsInput | boolean | null
    shippingNote?: NullableStringFieldUpdateOperationsInput | string | null
    shippingUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unitsCount?: NullableIntFieldUpdateOperationsInput | number | null
    unitLabel?: NullableStringFieldUpdateOperationsInput | string | null
    unitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    totalUnitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    retailerSku?: NullableStringFieldUpdateOperationsInput | string | null
    isManuallyOOS?: NullableBoolFieldUpdateOperationsInput | boolean | null
    oosReportCount?: NullableIntFieldUpdateOperationsInput | number | null
    lastStockChange?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    AlertDelivery?: AlertDeliveryUncheckedUpdateManyWithoutOfferNestedInput
  }

  export type OfferUncheckedUpdateManyWithoutCatalogItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    retailerId?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    inStock?: NullableBoolFieldUpdateOperationsInput | boolean | null
    price?: FloatFieldUpdateOperationsInput | number
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    shippingCost?: NullableFloatFieldUpdateOperationsInput | number | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    freeShipping?: NullableBoolFieldUpdateOperationsInput | boolean | null
    shippingNote?: NullableStringFieldUpdateOperationsInput | string | null
    shippingUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unitsCount?: NullableIntFieldUpdateOperationsInput | number | null
    unitLabel?: NullableStringFieldUpdateOperationsInput | string | null
    unitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    totalUnitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    retailerSku?: NullableStringFieldUpdateOperationsInput | string | null
    isManuallyOOS?: NullableBoolFieldUpdateOperationsInput | boolean | null
    oosReportCount?: NullableIntFieldUpdateOperationsInput | number | null
    lastStockChange?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OwnedFirearmUpdateWithoutCatalogItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    User?: UserUpdateOneRequiredWithoutOwnedFirearmNestedInput
  }

  export type OwnedFirearmUncheckedUpdateWithoutCatalogItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OwnedFirearmUncheckedUpdateManyWithoutCatalogItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FirearmSpecsCreateManyFirearmCategoryInput = {
    id?: number
    itemId: string
    manufacturer?: string | null
    model?: string | null
    platform?: string | null
    barrelLengthIn?: number | null
    actionType?: string | null
    isThreaded?: boolean | null
    pressureRating?: $Enums.FirearmPressureRating | null
    firearmType?: string | null
    capacity?: string | null
    finish?: string | null
    weight?: string | null
    overallLength?: string | null
    features?: string | null
    sight?: string | null
    safety?: string | null
  }

  export type FirearmSpecsUpdateWithoutFirearmCategoryInput = {
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    barrelLengthIn?: NullableFloatFieldUpdateOperationsInput | number | null
    actionType?: NullableStringFieldUpdateOperationsInput | string | null
    isThreaded?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pressureRating?: NullableEnumFirearmPressureRatingFieldUpdateOperationsInput | $Enums.FirearmPressureRating | null
    firearmType?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableStringFieldUpdateOperationsInput | string | null
    finish?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableStringFieldUpdateOperationsInput | string | null
    overallLength?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableStringFieldUpdateOperationsInput | string | null
    sight?: NullableStringFieldUpdateOperationsInput | string | null
    safety?: NullableStringFieldUpdateOperationsInput | string | null
    FirearmChamber?: FirearmChamberUpdateManyWithoutFirearmSpecsNestedInput
    CatalogItem?: CatalogItemUpdateOneRequiredWithoutFirearmSpecsNestedInput
  }

  export type FirearmSpecsUncheckedUpdateWithoutFirearmCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemId?: StringFieldUpdateOperationsInput | string
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    barrelLengthIn?: NullableFloatFieldUpdateOperationsInput | number | null
    actionType?: NullableStringFieldUpdateOperationsInput | string | null
    isThreaded?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pressureRating?: NullableEnumFirearmPressureRatingFieldUpdateOperationsInput | $Enums.FirearmPressureRating | null
    firearmType?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableStringFieldUpdateOperationsInput | string | null
    finish?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableStringFieldUpdateOperationsInput | string | null
    overallLength?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableStringFieldUpdateOperationsInput | string | null
    sight?: NullableStringFieldUpdateOperationsInput | string | null
    safety?: NullableStringFieldUpdateOperationsInput | string | null
    FirearmChamber?: FirearmChamberUncheckedUpdateManyWithoutFirearmSpecsNestedInput
  }

  export type FirearmSpecsUncheckedUpdateManyWithoutFirearmCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemId?: StringFieldUpdateOperationsInput | string
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    barrelLengthIn?: NullableFloatFieldUpdateOperationsInput | number | null
    actionType?: NullableStringFieldUpdateOperationsInput | string | null
    isThreaded?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pressureRating?: NullableEnumFirearmPressureRatingFieldUpdateOperationsInput | $Enums.FirearmPressureRating | null
    firearmType?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableStringFieldUpdateOperationsInput | string | null
    finish?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableStringFieldUpdateOperationsInput | string | null
    overallLength?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableStringFieldUpdateOperationsInput | string | null
    sight?: NullableStringFieldUpdateOperationsInput | string | null
    safety?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FirearmChamberCreateManyFirearmSpecsInput = {
    caliberId: number
    note?: string | null
  }

  export type FirearmChamberUpdateWithoutFirearmSpecsInput = {
    note?: NullableStringFieldUpdateOperationsInput | string | null
    Caliber?: CaliberUpdateOneRequiredWithoutFirearmChamberNestedInput
  }

  export type FirearmChamberUncheckedUpdateWithoutFirearmSpecsInput = {
    caliberId?: IntFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FirearmChamberUncheckedUpdateManyWithoutFirearmSpecsInput = {
    caliberId?: IntFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AlertCreateManyUserInput = {
    id: string
    type: $Enums.AlertType
    calId?: number | null
    itemId?: string | null
    keyword?: string | null
    targetCpr?: number | null
    excludeSteel?: boolean | null
    excludeReman?: boolean | null
    lastTriggered?: Date | string | null
    isActive?: boolean | null
    createdAt?: Date | string | null
  }

  export type AlertDeliveryCreateManyUserInput = {
    id: string
    alertId: string
    offerId?: number | null
    sentAt?: Date | string | null
    fingerprint: string
  }

  export type BlockedRetailerCreateManyUserInput = {
    id: string
    retailerId: number
    createdAt?: Date | string | null
  }

  export type OwnedFirearmCreateManyUserInput = {
    id: string
    firearmItemId: string
    nickname?: string | null
    createdAt?: Date | string | null
  }

  export type AlertUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAlertTypeFieldUpdateOperationsInput | $Enums.AlertType
    keyword?: NullableStringFieldUpdateOperationsInput | string | null
    targetCpr?: NullableFloatFieldUpdateOperationsInput | number | null
    excludeSteel?: NullableBoolFieldUpdateOperationsInput | boolean | null
    excludeReman?: NullableBoolFieldUpdateOperationsInput | boolean | null
    lastTriggered?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Caliber?: CaliberUpdateOneWithoutAlertNestedInput
    CatalogItem?: CatalogItemUpdateOneWithoutAlertNestedInput
    AlertDelivery?: AlertDeliveryUpdateManyWithoutAlertNestedInput
  }

  export type AlertUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAlertTypeFieldUpdateOperationsInput | $Enums.AlertType
    calId?: NullableIntFieldUpdateOperationsInput | number | null
    itemId?: NullableStringFieldUpdateOperationsInput | string | null
    keyword?: NullableStringFieldUpdateOperationsInput | string | null
    targetCpr?: NullableFloatFieldUpdateOperationsInput | number | null
    excludeSteel?: NullableBoolFieldUpdateOperationsInput | boolean | null
    excludeReman?: NullableBoolFieldUpdateOperationsInput | boolean | null
    lastTriggered?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    AlertDelivery?: AlertDeliveryUncheckedUpdateManyWithoutAlertNestedInput
  }

  export type AlertUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAlertTypeFieldUpdateOperationsInput | $Enums.AlertType
    calId?: NullableIntFieldUpdateOperationsInput | number | null
    itemId?: NullableStringFieldUpdateOperationsInput | string | null
    keyword?: NullableStringFieldUpdateOperationsInput | string | null
    targetCpr?: NullableFloatFieldUpdateOperationsInput | number | null
    excludeSteel?: NullableBoolFieldUpdateOperationsInput | boolean | null
    excludeReman?: NullableBoolFieldUpdateOperationsInput | boolean | null
    lastTriggered?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AlertDeliveryUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fingerprint?: StringFieldUpdateOperationsInput | string
    Alert?: AlertUpdateOneRequiredWithoutAlertDeliveryNestedInput
    Offer?: OfferUpdateOneWithoutAlertDeliveryNestedInput
  }

  export type AlertDeliveryUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    alertId?: StringFieldUpdateOperationsInput | string
    offerId?: NullableIntFieldUpdateOperationsInput | number | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fingerprint?: StringFieldUpdateOperationsInput | string
  }

  export type AlertDeliveryUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    alertId?: StringFieldUpdateOperationsInput | string
    offerId?: NullableIntFieldUpdateOperationsInput | number | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fingerprint?: StringFieldUpdateOperationsInput | string
  }

  export type BlockedRetailerUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Retailer?: RetailerUpdateOneRequiredWithoutBlockedRetailerNestedInput
  }

  export type BlockedRetailerUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    retailerId?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BlockedRetailerUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    retailerId?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OwnedFirearmUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CatalogItem?: CatalogItemUpdateOneRequiredWithoutOwnedFirearmNestedInput
  }

  export type OwnedFirearmUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    firearmItemId?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OwnedFirearmUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    firearmItemId?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}